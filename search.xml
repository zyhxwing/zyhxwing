<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeScript</title>
      <link href="/zyhxwing/2023/08/13/typescript/"/>
      <url>/zyhxwing/2023/08/13/typescript/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p><a href="https://wangdoc.com/typescript/">参考</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>javascript和typescript的区别是什么</p><p>区别：</p><ul><li>TypeScript中的数据要求带有明确的类型，JavaScript不要求。</li><li>TypeScript引入了JavaScript中没有的“类”概念。</li><li>TypeScript通过类型注解提供编译时的静态类型检查（ 虽然JavaScript是弱类型语言，但是在将其升级改造引入”类型注解”这一概念后的TypeScript中，类型注解相当于强类型语言中声明了某个变量的类型，以后该变量就必须为此类型，否则ts编译器将报错，并不能正确地编译成js文件。）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>display</title>
      <link href="/zyhxwing/2023/08/11/display/"/>
      <url>/zyhxwing/2023/08/11/display/</url>
      
        <content type="html"><![CDATA[<h1 id="display"><a href="#display" class="headerlink" title="display"></a>display</h1><p><a href="https://blog.csdn.net/m0_46612221/article/details/127541838">参考</a></p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><h2 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h2><p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">参考</a></p><h2 id="contents"><a href="#contents" class="headerlink" title="contents"></a>contents</h2><p><a href="https://www.cnblogs.com/wunuolin/articles/11211755.html">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> display </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见工具</title>
      <link href="/zyhxwing/2023/08/11/qian-duan-chang-jian-gong-ju-yu-xiang-mu/"/>
      <url>/zyhxwing/2023/08/11/qian-duan-chang-jian-gong-ju-yu-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>Vim 主要是使用模式的切换来进行输入、移动游标、选取、复制与粘贴等操作。在 Vim 主要常用的有几个模式:Normal 模式以及 Insert 模式，Normal 模式，又称命令模式，在这个模式下，无法输入文字，仅能进行复制与粘贴、存档或离开动作。</p><p><img src="/zyhxwing/../images/img/vim-vi-workmodel.png" alt="vim操作流程"></p><ul><li>初始处于Normal模式，需要先按下i、a或o这三个键其中一个进入Insert 模式，便能进行编辑。其中，i表示 insert，a 表示 appen读，而o则是表示会新增一行并开始输入。</li><li>在Insert 模式下，点击鼠标右键粘贴，enter键为换行，在编辑完毕之后，按下 ESC 键或是 Ctrl +[ 组合键，可退回至 Normal 模式。</li><li>在 Normal 模式下，按下 :w 会进行存档，按下 :g 会关闭这个档案 (但若未存档会提示先存档再离开) ，而 :wq 则是存档完成后直接关闭这个档案，通常确认无误之后使用:wq指令。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm</title>
      <link href="/zyhxwing/2023/08/10/npm/"/>
      <url>/zyhxwing/2023/08/10/npm/</url>
      
        <content type="html"><![CDATA[<h1 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h1><p>利用nrm工具管理npm源地址</p><ul><li>npm install -g nrm (安装nrm)</li><li>nrm ls(查看源列表)</li><li>nrm add <registry> <url> (添加源registry为源名称)</li><li>nrm use <registry> (使用源)</li><li>nrm del <registry> (删除源)</li><li>nrm test <registry> (测试源速度)</li></ul><h1 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h1><p>利用nvm工具管理node版本.</p><p>首先<a href="https://github.com/coreybutler/nvm-windows/releases">下载</a>安装nvm，安装位置即之后各种版本的nodejs的安装位置</p><ul><li>nvm -v(查看nvm版本)</li><li>nvm list available(查看可供下载的node)</li><li>nvm install xxxx(在线安装node也可以去node官网下载离线安装包解压后放入nvm安装目录下)</li><li>nvm uninstall xx.xx.x(卸载)</li><li>nvm usexxxxx(使用某个版本的node)</li><li>nvm ls(查看当前node版本列表)</li></ul><h1 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h1><p>利用pnpm工具管理项目依赖，<a href="https://juejin.cn/post/7124142007659790372">参考网址</a>。项目共享依赖包，pnpm将依赖存放在一个统一的位置，在版本不一致的情况下，仅保存版本之间不同的文件，节省硬盘空间，提高安装速度，</p><ul><li>npm install -g pnpm (安装pnpm)</li><li>pnpm -v(查看版本)</li><li><ul><li>pnpm init(初始化)</li></ul></li><li>pnpm install(安装项目所有依赖)</li><li>pnpm update(更新项目依赖)</li><li>pnpm run xxx(运行自定义脚本)</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>pnpm使用符号链接Symbolic link<br>(软链接,相对路径，快捷方式) 来创建依赖项的嵌套结构，将项目的直接依赖符号链接到node_modules的根目录，直接依赖的实际位置在<code>.pnpm/&lt;name&gt;@&lt;version&gt;node_modules/&lt;name&gt;</code>，依赖包中的每个文件再硬链接 (Hard link，多个文件名指向同一索引节点，通过索引节点链接)到pnpm store。</p><h2 id="pnpm-store"><a href="#pnpm-store" class="headerlink" title="pnpm store"></a>pnpm store</h2><p>pnpm store为pnpm资源在磁盘上的存储位置。在项目中执行pnpm<br>install的时候，依赖包存在于store中，直接创建依赖包硬链接到 store中，如果不存在，则从远程下载后存储在store中，并从项目的node_modules依赖包中创建硬链接到store中。</p><h2 id="workspace"><a href="#workspace" class="headerlink" title="workspace"></a>workspace</h2><p>pnpm 支持 workspace 协议 (写法:workspace:&lt;版本号&gt;)。当使用此协议时，pnpm 将拒绝解析除本地workspace 包含的 package 之外的任何内容。因此，如果设置为”foo””workspace:2.0.0”时，安装将会失败，因为”<a href="mailto:&#102;&#x6f;&#x6f;&#x40;&#x32;&#46;&#x30;&#x2e;&#x30;">&#102;&#x6f;&#x6f;&#x40;&#x32;&#46;&#x30;&#x2e;&#x30;</a>“不存在于此workspace 中。</p><h2 id="支持-monorepo"><a href="#支持-monorepo" class="headerlink" title="支持 monorepo"></a>支持 monorepo</h2><p>对于多个项目的管理，过往都是使用多个 git 仓库进行管理，但 monorepo的宗旨就是用一个git 仓库来管理多个子项目，所有的子项目都存放在根目录的packages目录下，那么一个子项目就代表一个package，类似微服务。</p><h1 id="npm发包流程"><a href="#npm发包流程" class="headerlink" title="npm发包流程"></a>npm发包流程</h1><h2 id="切换npm镜像"><a href="#切换npm镜像" class="headerlink" title="切换npm镜像"></a>切换npm镜像</h2><ul><li>npm config set registry + 地址</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>npm init</li></ul><p>根据发包环境使用不同指令</p><ul><li>npm login (外部环境，需要先注册npm账号)</li><li>npm config set auth xxxxxxXXX (内部环境)</li></ul><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>利用以下指令打包生成dist文件，并在生成后，修改dist文件的版本号</p><ul><li>pnpm build</li></ul><h2 id="发包"><a href="#发包" class="headerlink" title="发包"></a>发包</h2><ul><li>npm publish</li></ul><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>修改json文件的版本号再进行发布，该命令在原来的版本上自动加1</p><ul><li>npm version patch</li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul><li>npm unpublish <a href="mailto:&#120;&#120;&#x78;&#64;&#49;&#x2e;&#48;&#x2e;&#x30;">&#120;&#120;&#x78;&#64;&#49;&#x2e;&#48;&#x2e;&#x30;</a> –force(强制)</li><li>npm unpublish <a href="mailto:&#120;&#120;&#x78;&#64;&#49;&#x2e;&#48;&#46;&#x30;">&#120;&#120;&#x78;&#64;&#49;&#x2e;&#48;&#46;&#x30;</a> (非强制)</li></ul><h2 id="弃用"><a href="#弃用" class="headerlink" title="弃用"></a>弃用</h2><ul><li>npm deprecate <a href="mailto:&#x78;&#x78;&#x78;&#x40;&#x31;&#46;&#x30;&#x2e;&#48;">&#x78;&#x78;&#x78;&#x40;&#x31;&#46;&#x30;&#x2e;&#48;</a> 弃用信息XXXX</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在使用到该包的项目中卸载依赖，如果采用 vite构建项目，需要删除 vite目录下的deps文件夹，再进行安装依赖</p><ul><li>npm uninstall xxx</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node</title>
      <link href="/zyhxwing/2022/10/26/node/"/>
      <url>/zyhxwing/2022/10/26/node/</url>
      
        <content type="html"><![CDATA[<h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><h2 id="node的中间件"><a href="#node的中间件" class="headerlink" title="node的中间件"></a>node的中间件</h2><p>nodejs中间件从概念上讲是一种功能的封装方式，主要是指封装所有Http请求细节处理的方法。</p><p>在nodeJS中，中间件主要是指封装所有Http请求细节处理的方法，一次Http请求通常包含很多工作：如记录日志，IP过滤，查询字符串、请求体解析，cookie处理、权限验证、参数验证、异常处理等、但对web应用而言，并不希望接触到这么多细节性的处理，因此使用中间件来简化及隔离这些基础设施与业务逻辑之间的细节，让开发者更关注在业务的开发上，他的工作模式如下：<br><img src="https://img.php.cn/upload/image/223/929/368/1650014160430643.png" alt="常见的工作模式"></p><p>中间件是从Http请求发起到响应结束过程中的处理方法，通常需要对请求和响应进行处理，因此一个基本的中间件的形式如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 定义简单的三个中间件</span>      <span class="token keyword">const</span> httpMeth1 <span class="token operator">=</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>我是请求<span class="token number">1</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">)</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">const</span> httpMeth2 <span class="token operator">=</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>我是请求<span class="token number">2</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">)</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">const</span> httpMeth3 <span class="token operator">=</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>我是请求<span class="token number">3</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">)</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 中间件数组</span>      <span class="token keyword">const</span> allHttpMeth <span class="token operator">=</span> <span class="token punctuation">[</span>httpMeth1<span class="token punctuation">,</span> httpMeth2<span class="token punctuation">,</span> httpMeth3<span class="token punctuation">]</span>      <span class="token keyword">function</span> <span class="token function">run</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> next <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 获取中间件</span>          <span class="token keyword">const</span> allHttpMethitem <span class="token operator">=</span> allHttpMeth<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>allHttpMethitem<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 执行</span>            <span class="token function">allHttpMethitem</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>      <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 模拟请求发起</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react</title>
      <link href="/zyhxwing/2022/09/25/react/"/>
      <url>/zyhxwing/2022/09/25/react/</url>
      
        <content type="html"><![CDATA[<h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><h2 id="react和vue的区别"><a href="#react和vue的区别" class="headerlink" title="react和vue的区别"></a>react和vue的区别</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/a2c200ca3c46bdf4fdceda49d4a5bcbb.png" alt="react和vue的区别"></p><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>Vue和React存在着很多的共同点：</p><ol><li><p><strong>数据驱动视图</strong><br>在jquery时代，我们需要频繁的操作DOM来实现页面效果与交互；而Vue和React 解决了这一痛点，采用数据驱动视图方式，隐藏操作DOM的频繁操作。所以我们在开发时，只需要关注数据变化即可，但是二者实现方式不尽相同。</p></li><li><p><strong>组件化</strong><br>React与Vue都遵循组件化思想，它们把注意力放在UI层，将页面分成一些细块，这些块就是组件，组件之间的组合嵌套就形成最后的网页界面。<br>所以在开发时都有相同的套路，比如都有父子组件传递， 都有数据状态管理、前端路由、插槽等。</p></li><li><p><strong>Virtual DOM</strong><br>Vue与React都使用了 Virtual DOM + Diff算法， 不管是Vue的Template模板+options api 写法， 还是React的Class或者Function写法,最后都是生成render函数，而render函数执行返回VNode(虚拟DOM的数据结构，本质上是棵树)。<br>当每一次UI更新时，总会根据render重新生成最新的VNode，然后跟以前缓存起来老的VNode进行比对，再使用Diff算法（框架核心）去真正更新真实DOM（虚拟DOM是JS对象结构，同样在JS引擎中，而真实DOM在浏览器渲染引擎中，所以操作虚拟DOM比操作真实DOM开销要小的多）</p></li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>Vue和React两者虽然都是用于构建用户界面的框架，但是也有很大的差异，首先二者核心的思想就不同。</p><ol><li><strong>核心思想不同</strong><br>Vue早期开发就尤雨溪大佬，所以定位就是尽可能的降低前端开发的门槛，让更多的人能够更快地上手开发。这就有了vue的主要特点：<strong>灵活易用的渐进式框架</strong>，进行数据拦截&#x2F;代理，它对侦测数据的变化更敏感、更精确。</li></ol><p>React 从一开始的定位就是提出 UI 开发的新思路。背靠大公司Facebook 的React，从开始起就不缺关注和用户，而且React想要做的是用更好的方式去颠覆前端开发方式。所以React推崇<strong>函数式编程（纯组件）</strong>，数据不可变以及单向数据流，当然需要双向的地方也可以手动实现，比如借助onChange和setState来实现。</p><p>由于两者核心思想的不同，所以导致Vue和React在后续设计产生了许多的差异。</p><ol start="2"><li><strong>组件写法差异</strong><br>React推荐的做法是JSX + inline style, 也就是<strong>把 HTML 和 CSS 全都写进 JavaScript 中</strong>,即 all in js; Vue 推荐的做法是 <strong>template 的单文件组件格式</strong>(简单易懂，从传统前端转过来易于理解),即 html,css,JS 写在同一个文件(vue也支持JSX写法)</li></ol><p>这个差异一定程度上也是由于二者核心思想不同而导致的。</p><ol start="3"><li><strong>diff算法不同</strong></li></ol><p>不同的组件产生不同的 DOM 结构。当type不相同时，对应DOM操作就是直接销毁老的DOM，创建新的DOM。<br>同一层次的一组子节点，可以通过唯一的 key 区分。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a98d2787101a15d54a770ea27d21d602.png" alt="React的Diff算法核心实现"></p><p>react首先对新集合进行遍历，for( name in nextChildren)。<br>通过唯一key来判断老集合中是否存在相同的节点。如果没有的话创建<br>如果有的话，if (preChild &#x3D;&#x3D;&#x3D; nextChild )<br>会将节点在新集合中的位置和在老集合中lastIndex进行比较<br>如果if (child._mountIndex &lt; lastIndex) 进行移动操作，否则不进行移动操作。<br>如果遍历的过程中，发现在新集合中没有，但在老集合中有的节点，会进行删除操作</p><p>从左侧a节点依次进行对比：a-&gt;d、a-&gt;e、a-&gt;b、a-&gt;a、a-&gt;c, 剩下的其他节点也是与右侧树每个节点进行对比。<br>将两颗树中所有的节点一一对比需要O(n2)的复杂度，在对比过程中发现旧节点在新的树中未找到，那么就需要把旧节点删除，删除一棵树的一个节点(找到一个合适的节点放到被删除的位置)的时间复杂度为O(n),同理添加新节点的复杂度也是O(n),合起来diff两个树的复杂度就是O(n3)</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a397e3817405816ff6e543b0128303aa.png" alt="Vue的Diff算法核心实现"><br>updateChildren是vue diff的核心, 过程可以概括为：<br>旧children和新children各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明旧children和新children至少有一个已经遍历完了，就会结束比较。</p><p>Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p><ol start="4"><li><strong>响应式原理不同</strong></li></ol><p>Vue依赖收集，自动优化，数据可变。Vue递归监听data的所有属性,直接修改。当数据改变时，自动找到引用组件重新渲染。<br>React基于状态机，手动优化，数据不可变，需要setState驱动新的state替换老的state。当数据改变时，以组件为根目录，默认全部重新渲染, 所以 React 中会需要 shouldComponentUpdate 这个生命周期函数方法来进行控制</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/zyhxwing/2022/09/22/git/"/>
      <url>/zyhxwing/2022/09/22/git/</url>
      
        <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="项目开发流程与git指令"><a href="#项目开发流程与git指令" class="headerlink" title="项目开发流程与git指令"></a>项目开发流程与git指令</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>git clone </li><li>git remote add person + 仓库链接（和远程仓库建立连接）</li></ul><h3 id="设置用户名和邮件"><a href="#设置用户名和邮件" class="headerlink" title="设置用户名和邮件"></a>设置用户名和邮件</h3><ul><li>git config –global user.name “username”</li><li>git config –global user.email “<a href="mailto:&#x75;&#115;&#x65;&#114;&#x65;&#x6d;&#x61;&#x69;&#x6c;&#64;&#x78;&#120;&#x78;&#x2e;&#x63;&#111;&#109;">&#x75;&#115;&#x65;&#114;&#x65;&#x6d;&#x61;&#x69;&#x6c;&#64;&#x78;&#120;&#x78;&#x2e;&#x63;&#111;&#109;</a>“</li></ul><h3 id="拉取远端最新代码"><a href="#拉取远端最新代码" class="headerlink" title="拉取远端最新代码"></a>拉取远端最新代码</h3><ul><li>git pull (已经经过建立链接)</li><li>git pull 主机名+远程分支名:本地分支名</li></ul><p>git pull 的操作相当于git fetch 和 gitmerge的简写，即以下两个操作的简<br>git fetch 主机名<br>git merge 主机名&#x2F;远程分支名</p><h3 id="本地代码提交"><a href="#本地代码提交" class="headerlink" title="本地代码提交"></a>本地代码提交</h3><p>代码提交至缓存区查看当前代码状态</p><ul><li>git status</li></ul><p>提交代码到本地git缓存区</p><ul><li>git add .</li></ul><p>提交代码到本地git仓库<br>git commit -m “Commit message</p><h3 id="修改commit-message信息"><a href="#修改commit-message信息" class="headerlink" title="修改commit message信息"></a>修改commit message信息</h3><p>在git commit提交代码至本地仓库后，如果想修改message信息，同时需要避免重新再生成新的提交记录此时可以使用</p><ul><li>git commit –amend<br>进入vim编辑器进行修改</li></ul><h3 id="提交本地代码至远程分支"><a href="#提交本地代码至远程分支" class="headerlink" title="提交本地代码至远程分支"></a>提交本地代码至远程分支</h3><p>commit之后，push本地代码至远程分支，并查看提交情况</p><ul><li>git push</li><li>git push 主机名 + 分支名</li></ul><p>最终利用以下指令查看代码提交状态</p><ul><li>git log</li></ul><h2 id="版本回退指令"><a href="#版本回退指令" class="headerlink" title="版本回退指令"></a>版本回退指令</h2><ul><li><p>回退版本：<br>git reset –hard HEAD^ &#x2F;&#x2F;回退到上一个版本，HEAD指当前版本 ‘^’上一个<br>git reset –hard commit_id &#x2F;&#x2F;回退到指定commit id版本，可通过git log查看提交日志<br>git revert commit_id &#x2F;&#x2F;前进一个版本此版本的内容为指定的commit_id版本的内容</p></li><li><p>配合使用：<br>git log –pretty&#x3D;online &#x2F;&#x2F;查看提交日志，从而查到commit_id<br>git reflog &#x2F;&#x2F;查看命令历史</p></li><li><p>git revert与git reset的区别</p></li></ul><p>如果已经有A -&gt; B -&gt; C，想回到B：<br><strong>方法一</strong>：reset到B，丢失C：<br>相当于变成A -&gt; B</p><p><strong>方法二：</strong>再提交一个revert反向修改，变成B：<br>相当于变成A -&gt; B -&gt; C -&gt; B<br>C还在，但是两个B是重复的</p><p>看你的需求，也许C就是瞎提交错了（比如把密码提交上去了），必须reset<br>如果C就是修改，现在又要改回来，将来可能再改成C，那你就revert</p><h2 id="git-flow流程"><a href="#git-flow流程" class="headerlink" title="git flow流程"></a>git flow流程</h2><p>通过利用Git创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上，实现了软件开发过程不同阶段的相互隔离。这种软件开发的活动模型被Vincent称为Git Flow（Git工作流程）。</p><p>Git Flow的核心就是分支(Branch），通过在项目的不同阶段对分支的不同操作（包括但不限于创建、合并、变基等）来实现一个完整的高效率的工作流程。Git Flow的分支主要分为两大类：主分支和辅助分支。其中<strong>主分支包含主要分支和开发分支</strong>，而<strong>辅助分支包含功能分支、预发分支、热修复分支以及其他自定义分支</strong>。</p><ol><li>主要分支（Master）</li></ol><p>主要分支上存放的是最稳定的正式版本，并且该分支的代码应该是随时可在生产环境中使用的代码。当一个版本开发完毕后，产生了一份新的稳定的可供发布的代码时，主要分支上的代码要被更新。同时，每一次更新，都需要在主要分支上打上对应的版本号。</p><p>任何人不允许在主要分支上进行代码的直接提交，只接受其他分支的合入。原则上主要分支上的代码必须是合并自经过多轮测试及已经发布一段时间且线上稳定的预发分支。</p><ol start="2"><li>开发分支（Develop）</li></ol><p>开发分支是主开发分支，其上更新的代码始终反映着下一个发布版本需要交付的新功能。当开发分支到达一个稳定的点并准备好发布时，应该从该点拉取一个预发分支并附上发布版本号。也有人称开发分支为集成分支，因为会基于该分支和持续集成工具做自动化的构建。<strong>开发分支拉取自主要分支，接受其他辅助分支的合入，最常见的就是功能分支</strong>，开发一个新功能时拉取新的功能分支，开发完成后再并入开发分支。需要注意的是，合入开发的分支必须保证功能完整，不影响开发分支的正常运行。</p><ol start="3"><li>功能分支（Feature）</li></ol><p>功能分支一般命名为 Feature&#x2F;xxx，用于开发即将发布版本或未来版本的新功能或者探索新功能。该分支通常存在于开发人员的本地代码库而不要求提交到远程代码库上，除非几个人合作在同一个功能分支开发。关于这点，Thought Works洞见上有一篇文章“Git Flow有害论”做了非常有意思的阐述，文章下的评论也异常激烈。也许该文章的名字可能有失偏颇，但文章的本意以及评论传达了一个观点：功能分支要求足够细粒度以避免成为长期存在的功能分支，应当小步合并而不是一次合并大量代码。<strong>功能分支只能拉取自开发分支，开发完成后要么合并回开发分支，</strong>要么因为新功能的尝试不如人意而直接丢弃。</p><ol start="4"><li>预发分支（Release）</li></ol><p>预发分支一般命名为 Release&#x2F;1.2（后面是版本号），该分支专为测试—发布新的版本而开辟，允许做小量级的Bug修复和准备发布版本的元数据信息（版本号、编译时间等）。通过创建预发分支，使得开发分支得以空闲出来接受下一个版本的新的功能分支的合入。预发分支需要提交到服务器上，交由测试工程师进行测试，并由开发工程师修复Bug。同时根据该分支的特性我们可以部署自动化测试以及生产环境代码的自动化更新和部署。<strong>预发分支只能拉取自开发分支，合并回开发分支和主要分支。</strong></p><ol start="5"><li>热修复分支（Hotfix）</li></ol><p>热修复分支一般命名为Hotfix&#x2F;1.2.1（后面是版本号），当生产环境的代码（主要分支上代码）遇到严重到必须立即修复的缺陷时，就需要从主要分支上指定的tag版本（比如1.2）拉取热修复分支进行代码的紧急修复，并附上版本号（比如1.2.1）。这样做的好处是不会打断正在进行的开发分支的开发工作，能够让团队中负责功能开发的人与负责修复的人并行、独立的开展工作。<strong>热修复分支只能主要分支上拉取，测试通过后合并回主要分支和开发分支。</strong></p><p>Git Flow模型通过不同的分支从源代码管理的角度对软件开发活动进行了约束，为我们的软件开发提供了一个可供参考的管理模型。</p><ul><li>高效率。能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。</li><li>隔离开发环境。Git Flow模型让代码仓库保持整洁，让小组各个成员之间的开发相互隔离，</li><li>高拓展性。不同的开发团队存在不同的文化，在不同的项目背景情况下都可能根据该模型进行适当的精简或扩充。</li><li>更好管理。防控中心通过合理使用Git Flow，更好地管理代码仓库，提高工作的效率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写代码</title>
      <link href="/zyhxwing/2022/09/13/handwriting/"/>
      <url>/zyhxwing/2022/09/13/handwriting/</url>
      
        <content type="html"><![CDATA[<h1 id="手写代码汇总"><a href="#手写代码汇总" class="headerlink" title="手写代码汇总"></a>手写代码汇总</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fd41339dfd14200bb006815eab31324~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="手写代码重要性"></p><p><a href="https://juejin.cn/post/6946136940164939813#heading-7">参考</a></p><h2 id="h5页面"><a href="#h5页面" class="headerlink" title="h5页面"></a>h5页面</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>hellow world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">function</span> <span class="token function">hello</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"11111"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>    <span class="token comment">//以防抖为例，触发防抖</span>    btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span><span class="token function">debounce</span><span class="token punctuation">(</span>hello<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>防抖的应用场景:</p><ul><li>每次 resize&#x2F;scroll 触发统计事件</li><li>文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//防抖</span>   <span class="token comment">//指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</span>     <span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        <span class="token comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>          timer <span class="token operator">=</span> <span class="token keyword">null</span>       <span class="token punctuation">&#125;</span>        <span class="token comment">// 设置定时器，使事件间隔指定事件后执行</span>       timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>         <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>函数节流的应用场景有:</p><ul><li>DOM 元素的拖拽功能实现（mousemove）</li><li>射击游戏的 mousedown&#x2F;keydown 事件（单位时间只能发射一颗子弹）</li><li>计算鼠标移动的距离（mousemove）</li><li>Canvas 模拟画板功能（mousemove）</li><li>搜索联想（keyup）</li><li>监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//节流</span><span class="token comment">//指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</span>  <span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>         timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>          <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>          timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>       <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">"pending"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token constant">RESOLVED</span> <span class="token operator">=</span> <span class="token string">"resolved"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">"rejected"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">MyPromise</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 保存初始化状态</span>  <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化状态</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token constant">PENDING</span><span class="token punctuation">;</span>  <span class="token comment">// 用于保存 resolve 或者 rejected 传入的值</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 用于保存 resolve 的回调函数</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>resolvedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 用于保存 reject 的回调函数</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>rejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 状态转变为 resolved 方法</span>  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 保证代码的执行顺序为本轮事件循环的末尾</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 只有状态为 pending 时才能转变，</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 修改状态</span>        self<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token constant">RESOLVED</span><span class="token punctuation">;</span>        <span class="token comment">// 设置传入的值</span>        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token comment">// 执行回调函数</span>        self<span class="token punctuation">.</span>resolvedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">callback</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>          <span class="token function">callback</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 状态转变为 rejected 方法</span>  <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 保证代码的执行顺序为本轮事件循环的末尾</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 只有状态为 pending 时才能转变</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 修改状态</span>        self<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token constant">REJECTED</span><span class="token punctuation">;</span>        <span class="token comment">// 设置传入的值</span>        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token comment">// 执行回调函数</span>        self<span class="token punctuation">.</span>rejectedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">callback</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>          <span class="token function">callback</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 将两个方法传入函数执行</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token function">fn</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 遇到错误时，捕获错误，执行 reject 函数</span>    <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">MyPromise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">onResolved<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span>  onResolved <span class="token operator">=</span>    <span class="token keyword">typeof</span> onResolved <span class="token operator">===</span> <span class="token string">"function"</span>      <span class="token operator">?</span> <span class="token function-variable function">onResolved</span>      <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> value<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  onRejected <span class="token operator">=</span>    <span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">"function"</span>      <span class="token operator">?</span> <span class="token function-variable function">onRejected</span>      <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">throw</span> error<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 如果是等待状态，则将函数加入对应列表中</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>resolvedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>onResolved<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>rejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 如果状态已经凝固，则直接执行对应状态的函数</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">RESOLVED</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">onResolved</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="promise-then"><a href="#promise-then" class="headerlink" title="promise.then"></a>promise.then</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">onFulfilled<span class="token punctuation">,</span> onReject</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 保存前一个promise的this</span>    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 封装前一个promise成功时执行的函数</span>      <span class="token keyword">let</span> <span class="token function-variable function">fulfilled</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>          <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 承前</span>          <span class="token keyword">return</span> result <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token operator">?</span> result<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//启后</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 封装前一个promise失败时执行的函数</span>      <span class="token keyword">let</span> <span class="token function-variable function">rejected</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>          <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">onReject</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> result <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token operator">?</span> result<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">reject</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">switch</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token constant">PENDING</span><span class="token operator">:</span>           self<span class="token punctuation">.</span>onFulfilledCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fulfilled<span class="token punctuation">)</span><span class="token punctuation">;</span>          self<span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token constant">FULFILLED</span><span class="token operator">:</span>          <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token constant">REJECT</span><span class="token operator">:</span>          <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all"></a>promise.all</h2><p>Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来</p><ul><li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数</li><li>这个方法返回一个新的 promise 对象，</li><li>遍历传入的参数，用Promise.resolve()将参数”包一层”，使其变成一个promise对象</li><li>参数所有回调成功才是成功，返回值数组与参数顺序一致</li><li>参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">promiseAll</span><span class="token punctuation">(</span><span class="token parameter">promises</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">argument must be a array</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> resolvedCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> promiseNum <span class="token operator">=</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">var</span> resolvedResult <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promiseNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        resolvedCounter<span class="token operator">++</span><span class="token punctuation">;</span>        resolvedResult<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedCounter <span class="token operator">==</span> promiseNum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>resolvedResult<span class="token punctuation">)</span>          <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token parameter">error</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>    <span class="token comment">// test</span>    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token function">promiseAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p3<span class="token punctuation">,</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// [3, 1, 2]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="promise-race"><a href="#promise-race" class="headerlink" title="promise.race"></a>promise.race</h2><p>该方法的参数是 Promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行. 因为 Promise 的状态只能改变一次, 那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function-variable function">race</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 获取对象的原型</span>      prototype <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 获取构造函数的 prototype 对象</span>  <span class="token comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>proto<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">===</span> prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span>  test <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">str</span><span class="token operator">:</span><span class="token string">"Hello"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// test实际类型是String，但是Object是所有类的父类</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">myInstanceof</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span>Object<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">myInstanceof</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span>Array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回false </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">myInstanceof</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">objectFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> newObject <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> constructor <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 判断参数是否是一个函数</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> constructor <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"type error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span>  newObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将 this 指向新建对象，并执行函数</span>  result <span class="token operator">=</span> <span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>newObject<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 判断返回对象</span>  <span class="token keyword">let</span> flag <span class="token operator">=</span> result <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 判断返回结果</span>  <span class="token keyword">return</span> flag <span class="token operator">?</span> result <span class="token operator">:</span> newObject<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 使用方法</span><span class="token function">objectFactory</span><span class="token punctuation">(</span>构造函数<span class="token punctuation">,</span> 初始化参数<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><ul><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// call函数实现</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 判断调用对象</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"type error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 获取参数</span>  <span class="token keyword">let</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 判断 context 是否传入，如果未传入则设置为 window</span>  context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>  <span class="token comment">// 将调用函数设为对象的方法</span>  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token comment">// 调用函数</span>  result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将属性删除</span>  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><ul><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// apply 函数实现</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 判断调用对象是否为函数</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 判断 context 是否存在，如果未传入则为 window</span>  context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>  <span class="token comment">// 将函数设为对象的方法</span>  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token comment">// 调用方法</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 将属性删除</span>  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><ul><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// bind 函数实现</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 判断调用对象是否为函数</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 获取参数</span>  <span class="token comment">//第一个arguments代表bind定义时传入的参数</span>  <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 根据调用方式，传入不同绑定值</span>    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>      <span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Fn</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> context<span class="token punctuation">,</span>        <span class="token comment">//第二个arguments代表bind定义的函数在调用时传入的参数</span>      args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组的扁平化"><a href="#数组的扁平化" class="headerlink" title="数组的扁平化"></a>数组的扁平化</h2><p>递归实现</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      result <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">flatten</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">flatten</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//  [1, 2, 3, 4，5]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拓展运算符实现</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">flatten</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  [1, 2, 3, 4，5]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token parameter">object</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>object <span class="token operator">||</span> <span class="token keyword">typeof</span> object <span class="token operator">!==</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> newObject <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> object<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>object<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      newObject<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span>        <span class="token keyword">typeof</span> object<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">?</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>object<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> object<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> newObject<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i</title>
      <link href="/zyhxwing/2022/09/05/i/"/>
      <url>/zyhxwing/2022/09/05/i/</url>
      
        <content type="html"><![CDATA[<h1 id="xwing"><a href="#xwing" class="headerlink" title="xwing"></a>xwing</h1><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="微网格管理系统"><a href="#微网格管理系统" class="headerlink" title="微网格管理系统"></a>微网格管理系统</h3><p>项目内容：兼容三维、二维等多种数据格式的社区网格化管理平台。支持动态处理事件，把“人、地、物、事、组织”等全部纳入网格管理，对每一网格实施精细化、主动化、可视化。</p><p>项目技术：SpringBoot、java、Vue2.0、Ant DesignVue</p><p>负责模块：利用axure设计单位管理等界面效果图，参与实有人口管理、地址与房屋管理、车辆管理、行政区划管理、单位管理（学校管理、党政机关管理、医院管理）、工单管理的前端开发。</p><p>个人收获， 我主要负责的内容是前端开发，项目开发的经历首先增长了我前端的开发知识，比如supermap 地图功能的实现、print打印功能、文件下载功能。同时时间的紧迫也培养了我良好的时间意识，保证了在工期压力之下依旧能够稳定地产出高质量的代码。最后我也是了解到 在项目开发的时候切记个人主义，不要你想什么就是什么，  不要假想用户会了解软件设计的详细过程，也不要想当然的认为用户会耐心的看用户帮助文档，一切从用户的角度出发思考问题</p><h4 id="axure绘制原型图"><a href="#axure绘制原型图" class="headerlink" title="axure绘制原型图"></a>axure绘制原型图</h4><p>在项目的前期需要去<strong>绘制原型图</strong>，项目工期很赶，要求半天时间就需要把原型图弄好。因为需要利用axure去绘制原型图，所以通过边查阅资料边实际上手操作的方式，及时完成了任务。<strong>（主要做交互，开发的参考，  页面、控件、跳转、动态面板，条件判断，给页面、面板取名字）</strong>在完成这个任务的过程中，遇到实现动态面板与条件判断的问题。动态面板简而言之就是在某个大页面中，有一个局部的小页面，称之为面板，点击某个按钮，要去实现小页面的动态转换，从a面板变成b面板。条件判断就是，比如点击登陆按钮，要判断账号输入框里是否有文字，没有的话就要显示一条提示，提示放在一个动态面板中，默认为不）</p><h4 id="自定义权限指令细化到按钮级别"><a href="#自定义权限指令细化到按钮级别" class="headerlink" title="自定义权限指令细化到按钮级别"></a>自定义权限指令细化到按钮级别</h4><p>当时在做按钮的权限管理时，没有用那种传统的v-if（每个页面都要获取一次权限信息，代码往往很冗余），而是通过自定义指令进行按钮权限的判断（将获取权限的方法封装起来），首先该自定义指令绑定在某个按钮上，在该按钮被渲染时调用inserted钩子函数，传入当前按钮的v-hasPermi的值，检查保存在vuex、localstorage内的权限树是否有当前按钮的权限，有则进行渲染，无则删除子节点，返回父节点 </p><p>拓展：权限树的获取步骤</p><ol><li>用户输入账号密码进行登录，登录完拿到token，将token存到cookie和localstorage，之后每次往后端发送请求都通过axios请求拦截器进行拦截，每次请求的时候头部携带token</li><li>在页面初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制。</li><li>在用户登录完之后，在beforeeach 路由钩子函数中设置，每次进行跳转时都先判断缓存内是否有用户的路由表信息，以及跳转的路由是否存在在用户的路由表信息中</li><li>如果没有的话，需要先去获取用户的权限信息，然后筛选有权限访问的路由，最后根据roles权限利用addRoutes方法动态添加该用户可访问的路由表</li></ol><p>钩子函数（自定义指令）</p><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li><code>update</code>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</li><li><code>componentUpdated</code>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li><li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li></ul><p>首先当时因为我们的按钮有两个判定条件，一个是根据左侧一个树的层级来显示的，所以我们一开始先在按钮上绑定了一个v-if，来控制它在哪一层显示和隐藏，第二个则是根据用户是否有当前按钮的权限。</p><p>但当我把自定义指令加到按钮上时，系统报错了，这时候我发现v-if和v-permission，也就是自定义指令会产生冲突（当同时存在 v-if 和自定义隐藏的指令 el 会被删除，但元素上的指令依旧会执行，修改的是上一个元素的显示隐藏）（v-if把咱们的dom元素给删除了，导致这个v-permission找不到这个dom元素了），后来的话也是找到了两种解决方式：<br>第一种方式，将v-if 替换为v-show，这样元素一直存在，就不会出现问题，(如果你的自定义指令会动态改变display属性，那就可能和v-show冲突 v-show是通过display：none来控制隐藏，这点需要注意，只是单一的隐藏，就不需要考虑了)<br>第二种方式，将v-if指令合并到自定义中 传入一个对象；改指令实现通过传入的对象来实现是否需要隐藏。</p><p>然后的话还有个小细节就是，当时主要有两个地方的按钮会涉及到权限的设置，分别是html部分的v-permission和在列表中渲染的按钮v-permission，通过一个渲染函数customRender，把节点渲染到html中，在customRender中填写的<code>&lt;Button v-hasPermi=&quot;[&#39;ADRESS:BUILD:EDIT&#39;]&quot;&gt;修改&lt;/Button&gt;</code>是个字符串，而<code>&lt;a-button v-hasPermi=&quot;[&#39;ADRESS:BUILD:ADD&#39;]&quot;&gt;新增&lt;/a-button&gt;</code>是个数组，虽然两种写法是一样的，但vue处理的方式不一样，这时候需要对值做一个判断，如果是字符串就需要将其转换成数组,将其统一之后再做处理</p><h4 id="supermap、leaflat地图功能实现"><a href="#supermap、leaflat地图功能实现" class="headerlink" title="supermap、leaflat地图功能实现"></a>supermap、leaflat地图功能实现</h4><p><a href="https://blog.csdn.net/summer_du/article/details/114363473">supermap、leaflat</a>页面引入、初始化地图、地图上绘制点、线、多边形、弹框、绘制省市区的边界与高亮区域、绘制热力图和风力图</p><p>地图上点击要有反馈，查阅官方文档后给不同图层绑定了一个点击事件，但点击事件无法在其它vue组件里进行触发，这时候我们通过vue的事件总线，把事件传出来，各个vue组件在初始化的时候先注册了一个事件，然后我们在画图的时候，我们绑定了一个点击事件，在点击事件中触发这个事件，进而拿到它的一些参数（key：图层的种类），然后可以进行一些弹窗展示</p><ol><li>先初始化各个图层，包括建筑物、医院、学校图层，每个图层都根据后端传回的经纬度数据各自生成了建筑物、医院、学校的点位，</li><li>在各个图层上面监听onclik事件，当触发该事件时，触发事件总线的“点击图标”事件，并且传递该点击事件的点位信息与key（图层的种类） </li><li>在vue文件中注册事件总线，当“点击图标”事件发生时，需要根据传回来的key与数据触发对应的方法 4.通过key的不同种类，使用<code>swtich case</code>来进行相应地方法。</li></ol><h4 id="print打印"><a href="#print打印" class="headerlink" title="print打印"></a>print打印</h4><p><a href="https://blog.csdn.net/weixin_41897680/article/details/124797673">print打印功能实现</a></p><ol><li>接到一个需求，打印当前页面的内容，一开始考虑的是直接打印当前页面的内容，但是页面上会显示地图，直接打印的话地图是不能打印出来的，所以考虑将地图所在的div转换成图片，通过搜索找到了一个html2canvs插件</li><li>html2canvs的作用就是允许让我们直接在用户浏览器上拍摄网页或其部分的“截图”，它的屏幕截图是基于 DOM 的，因此可能不会 100% 精确到真实的表示，因为它不会生成实际的屏幕截图，而是基于页面上可用的信息构建屏幕截图。所以在页面初始化created时，当地图加载完毕之后，调用html2canvas方法，设置允许跨域图像污染画步，同时设置尝试使用CORS从服务器加载图像，最后生成对应的图片地址，最后利用v-if来显示与隐藏地图和图片</li><li>声明打印区域：可通过设置class 类名或 id 指定打印区域，但由于vue项目涉及到打包部署，推荐使用ref获取DOM节点，如果使用id或class获取，打包部署后打印内容可能显示空白。</li><li>调用打印方法。</li><li>声明不打印区域（ 声明<code>no-print</code>类名 ， 在print方法中通过<code>noPrint</code>属性指定不打印区域（通过class类名指定））</li><li>通过css设置<code>page-break-after</code>来解决数据切割问题， <code>page-break-after：always</code> 属性用于设置在指定元素后面插入分页符。</li><li>@page规则允许你指定页面盒子的许多方面。例如，你想要指定页面尺寸。 除了可以用长度值声明尺寸，你还可以使用纸质尺寸关键字，例如”A4”或<code>legal</code>。 你也可以使用关键字来指定页面方向 portrait（竖向的）或landscape（横向的）。</li></ol><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p><a href="https://blog.csdn.net/qq_35435093/article/details/123902850">文件下载功能实现</a></p><p>图片下载一开始点击因为使用了 window.open 点击图片就直接跳转到预览了，想要点击下载的功能</p><ol><li>使用文件流的方式，在请求的时候，需要预先设置响应的数据格式responseType为bold，提醒后端这个请求需要获取blod(之前的接口被封装好了，另外重写了新的请求接口)，</li><li>再获取到后端的文件流之后，不能用window.open方法打开，而是创建一个新的对象URL，该对象URL可以代表某一个指定的file对象或者bold对象 </li><li>新建一个a标签并为其添加属性，将生成的URL设置为a.href属性，在通过虚拟dom创建a标签，最后调用点击事件，进行下载文件</li></ol><h3 id="小型企业安全生产信息化管理平台"><a href="#小型企业安全生产信息化管理平台" class="headerlink" title="小型企业安全生产信息化管理平台"></a>小型企业安全生产信息化管理平台</h3><p>项目内容：基于JavaWeb的安全生产信息化管理平台，规范企业安全生产规范化建设<br>项目技术：SpringCloud、java、Vue3.0、elementUi<br>负责模块：参与系统管理与业务模块的功能设计以及安全生产目标功能与隐患排查功能前后端的开发。<br>个人收获：对于一个完整的项目流程有了更加深刻的认识和理解，同时参与了业务流程设计与数据库设计，掌握了更多技能，包括用axure绘制原型图，用staruml设计数据库，这让我了解到快速学习新知识并将其运用到业务开发的重要性。在这个开发的过程中，前端代码直观的反馈会带给我成就感，我对前端的兴趣也越来越浓厚，</p><h4 id="批量导入功能"><a href="#批量导入功能" class="headerlink" title="批量导入功能"></a>批量导入功能</h4><p>批量导入功能的实现EasyExcel是阿里巴巴开源的一个excel处理框架，以使用简单、节省内存著称。EasyExcel能很大的减少占用内存的主要原因是在解析文件时没有将数据一次性全部加载到内存中，而是从磁盘上一行行读取数据，逐个解析。 EasyExcel采用一行一行的解析模式，并将一行的解析结果以观察者的模式通知处理（AnalysisEventListener）。（使用EasyExcel进行导入功能：</p><ol><li>引入maven</li><li>编写pojo（ @ExcelProperty(“单据编号”)注解对应的excel的标题，一个字都不能差，他会自动读取）</li><li>编写controller（&#x2F;&#x2F;1.进行读取数据，StorageRetrieval是我的pojo类， &#x2F;&#x2F;2.new SorageListener(storageService)这个是监听器，主要用来读取数据的&#x2F;&#x2F;3. EasyExcel.read（file.getInputStream();, StorageRetrieval.class, new SorageListener; ））</li><li>读取到工作簿内容后，将获取到的数据传到dto：workBook.sheet().doReadSync();））</li></ol><h4 id="工作流功能的实现"><a href="#工作流功能的实现" class="headerlink" title="工作流功能的实现"></a>工作流功能的实现</h4> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Integer</span> companyId<span class="token punctuation">;</span><span class="token comment">//表示是否为通用工作流(0表示通用工作流，1表示自定义工作流)</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> type<span class="token punctuation">;</span><span class="token comment">//当为通用工作流时，需要传下级审批人id,为自定义工作流时无需传该值,其中该值为数组</span><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> checkUserIdList<span class="token punctuation">;</span><span class="token comment">//该业务的唯一标识</span><span class="token keyword">private</span> <span class="token class-name">String</span> identifier<span class="token punctuation">;</span><span class="token comment">//提交人id</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> inputUserId<span class="token punctuation">;</span><span class="token comment">//任务流程实例Id</span><span class="token keyword">private</span> <span class="token class-name">String</span> processId<span class="token punctuation">;</span><span class="token comment">//退回标志(1表示退回，0表示不是退回)</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> returnFlag<span class="token punctuation">;</span><span class="token comment">//退回原因</span><span class="token keyword">private</span> <span class="token class-name">String</span> reason<span class="token punctuation">;</span><span class="token comment">//业务id</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> businessId<span class="token punctuation">;</span><span class="token comment">//业务批注</span><span class="token keyword">private</span> <span class="token class-name">String</span> comment<span class="token punctuation">;</span><span class="token comment">//会签类型,用于表示是否需要所有人审批后会签完成</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> countersignType<span class="token punctuation">;</span><span class="token comment">//当前审批人id</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> checkUserId<span class="token punctuation">;</span>新增文件<span class="token operator">-</span>工作流逻辑<span class="token number">1.</span>如果为提交并且工作流未关闭则启动工作流<span class="token class-name">Object</span> object<span class="token operator">=</span>feignClientServe<span class="token punctuation">.</span><span class="token function">startCounterSign</span><span class="token punctuation">(</span>activitiesCheckDTO<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//开始会签</span>  <span class="token number">1.</span>根据唯一标识来确认对应该流程操作的是哪个数据库表    <span class="token number">2.</span>设置工作流流程变量    <span class="token number">3.</span>判断工作流所属类型（通用还是专有）    <span class="token number">3.1</span><span class="token punctuation">.</span>表示通用工作流    <span class="token number">3.2</span><span class="token punctuation">.</span>更新业务表信息与审批人信息    <span class="token number">3.3</span><span class="token punctuation">.</span>表示专有工作流    <span class="token number">3.4</span><span class="token punctuation">.</span>根据工作流id查询工作流明细    <span class="token number">3.5</span><span class="token punctuation">.</span>根据前端传回的数据，（是否会签）设置流程变量    <span class="token number">3.6</span><span class="token punctuation">.</span>更新审批人信息    <span class="token number">4.</span>修改待处理业务表信息，更新审批人待处理的文件的数量 <span class="token number">2.</span>如果为提交操作但是工作流为关闭状态直接完成流程更改体系文件状态      <span class="token number">3.</span>如果为暂存业务则不走工作流，直接入数据库，但是此时不走工作流审批文件<span class="token operator">-</span>工作流逻辑<span class="token number">1.</span>驳回    <span class="token number">1.1</span><span class="token punctuation">.</span>当退回时直接结束流程，完成当前任务，文件状态更改    <span class="token number">1.2</span><span class="token punctuation">.</span>获取所有审核人员信息，待处理任务减<span class="token number">1</span>    <span class="token number">1.3</span><span class="token punctuation">.</span>删除审批信息<span class="token number">2.</span>通过    <span class="token number">2.1</span><span class="token punctuation">.</span>判断是否是通用、专有    <span class="token number">2.2</span><span class="token punctuation">.</span>通用工作流获取所有下级审批人    <span class="token number">2.3</span><span class="token punctuation">.</span>如果仅剩一个或会签类型为仅需一人审批，且没有下级审批人，流程结束    <span class="token number">2.4</span><span class="token punctuation">.</span>获取当前实例所有需要审核人员信息，将其提示信息减一    <span class="token number">2.5</span><span class="token punctuation">.</span>还有多个活动实例，且有下级审批人，流程继续，    <span class="token number">2.6</span><span class="token punctuation">.</span>判断下一个流程是否会签，同时新增下一个节点的审批人员信息    <span class="token number">2.7</span><span class="token punctuation">.</span>专有工作流从流程变量中获取流程节点id来获取会签类型    <span class="token number">2.8</span><span class="token punctuation">.</span>获取下一节点审批人员信息，并且根据节点id获取下一节点信息，为下级审批人员添加提醒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="文件预览功能"><a href="#文件预览功能" class="headerlink" title="文件预览功能"></a>文件预览功能</h4><p><a href="https://kkfileview.keking.cn/zh-cn/docs/usage.html">kkFileView</a></p><ol><li>将预览接口提供给前端；</li><li>利用 window.open 浏览器打开新窗口预览文件 </li><li>通过iframe，预览文件 结合elementUI的弹窗（可以做其他弹窗效果）很多系统内不是直接暴露文件下载地址，而是请求通过id、code等参数到通过统一的接口，后端通过id或code等参数定位文件，再通过OutputStream输出下载，此时下载url是不带文件后缀名的，预览时需要拿到文件名，传一个参数fullfilename&#x3D;xxx.xxx来指定文件名</li></ol><p><a href="https://blog.csdn.net/MtangEr/article/details/108599708?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-108599708-blog-120524610.pc_relevant_paycolumn_v3&spm=1001.2101.3001.4242.1&utm_relevant_index=3">具体步骤</a></p><h3 id="徐工培训云平台"><a href="#徐工培训云平台" class="headerlink" title="徐工培训云平台"></a>徐工培训云平台</h3><p>项目内容：基于JavaWeb的培训教育管理平台，实现课程学习、参与考试、发布计划等功能<br>项目技术：SpringBoot、java、Vue2.0、elementUi、Mint UI<br>负责模块：PC端课程管理的前后端开发，移动端的课程学习、线下课程签到、课程评价管理的前后端开发<br>个人收获：个人收获：我系统地了解了程序开发的相关知识，对项目的运行流程有了大体上的认知，培养了我良好的编程习惯，包括变量命名规范、格式规范等</p><h4 id="课程视屏播放"><a href="#课程视屏播放" class="headerlink" title="课程视屏播放"></a>课程视屏播放</h4><p><a href="https://blog.csdn.net/weixin_38684316/article/details/88070737?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-88070737-blog-105723063.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-88070737-blog-105723063.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=1">vue-video-player</a></p><ol><li>首先是npm i vue-video-player -D 安装依赖</li><li>在main.js里面引入</li><li>vue组件中引用<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">  <span class="token operator">&lt;</span>video<span class="token operator">-</span>player <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"video-player vjs-custom-skin"</span>                 ref<span class="token operator">=</span><span class="token string">"videoPlayer"</span>                 <span class="token operator">:</span>playsinline<span class="token operator">=</span><span class="token string">"true"</span>                 style<span class="token operator">=</span><span class="token string">"object-fit:fill"</span>                 <span class="token operator">:</span>options<span class="token operator">=</span><span class="token string">"playerOptions"</span>                @play<span class="token operator">=</span><span class="token string">"onPlayerPlay($event)"</span>                @pause<span class="token operator">=</span><span class="token string">"onPlayerPause($event)"</span>                @ended<span class="token operator">=</span><span class="token string">"onPlayerEnded($event)"</span>                @timeupdate<span class="token operator">=</span><span class="token string">"onPlayerTimeupdate($event)"</span>                @ready<span class="token operator">=</span><span class="token string">"playerReadied"</span>   <span class="token operator">></span>   <span class="token operator">&lt;</span><span class="token operator">/</span>video<span class="token operator">-</span>player<span class="token operator">></span><span class="token literal-property property">playerOptions</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token literal-property property">playbackRates</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.7</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//播放速度</span>          <span class="token literal-property property">autoplay</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//如果true,浏览器准备好时开始回放。</span>          <span class="token literal-property property">muted</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 默认情况下将会消除任何音频。</span>          <span class="token literal-property property">loop</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 导致视频一结束就重新开始。</span>          <span class="token literal-property property">preload</span><span class="token operator">:</span> <span class="token string">'auto'</span><span class="token punctuation">,</span> <span class="token comment">// 建议浏览器在&lt;video>加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持）</span>          <span class="token literal-property property">language</span><span class="token operator">:</span> <span class="token string">'zh-CN'</span><span class="token punctuation">,</span>          <span class="token literal-property property">aspectRatio</span><span class="token operator">:</span> <span class="token string">'16:9'</span><span class="token punctuation">,</span> <span class="token comment">// 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如"16:9"或"4:3"）</span>          <span class="token literal-property property">fluid</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 当true时，Video.js player将拥有流体大小。换句话说，它将按比例缩放以适应其容器。</span>          <span class="token literal-property property">sources</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span>            <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">"video/mp4"</span><span class="token punctuation">,</span>            <span class="token literal-property property">src</span><span class="token operator">:</span> <span class="token string">"你的视频地址"</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>          <span class="token literal-property property">poster</span><span class="token operator">:</span> <span class="token string">"你的封面地址"</span><span class="token punctuation">,</span>          <span class="token literal-property property">width</span><span class="token operator">:</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth<span class="token punctuation">,</span>          <span class="token literal-property property">notSupportedMessage</span><span class="token operator">:</span> <span class="token string">'此视频暂无法播放，请稍后再试'</span><span class="token punctuation">,</span> <span class="token comment">//允许覆盖Video.js无法播放媒体源时显示的默认信息。</span>          <span class="token literal-property property">controlBar</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token literal-property property">timeDivider</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            <span class="token literal-property property">durationDisplay</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            <span class="token literal-property property">remainingTimeDisplay</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token literal-property property">fullscreenToggle</span><span class="token operator">:</span> <span class="token boolean">true</span>  <span class="token comment">//全屏按钮</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onPlayerPlay</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>videoPlayer<span class="token punctuation">.</span>player<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function">onPlayerPlay</span><span class="token punctuation">(</span><span class="token parameter">player</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>paused <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">// 暂停回调</span><span class="token function">onPlayerPause</span><span class="token punctuation">(</span><span class="token parameter">player</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>paused <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token function">playerReadied</span> <span class="token punctuation">(</span><span class="token parameter">player</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timelog<span class="token punctuation">)</span><span class="token punctuation">;</span>    player<span class="token punctuation">.</span><span class="token function">currentTime</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timelog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">// 视频播完回调</span><span class="token function">onPlayerEnded</span><span class="token punctuation">(</span><span class="token parameter">player</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span>videoStatus <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//完成课程</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">finishLesson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"已经看过"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="无限滑动功能的实现better-scroll"><a href="#无限滑动功能的实现better-scroll" class="headerlink" title="无限滑动功能的实现better-scroll"></a>无限滑动功能的实现better-scroll</h4><p><a href="https://blog.csdn.net/weixin_44890979/article/details/111400863">better scroll原理</a><br><a href="https://blog.csdn.net/weixin_37719279/article/details/82084342">better scroll教程</a> </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">initScroll</span><span class="token punctuation">(</span><span class="token parameter">dom</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    that<span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> bscrollDom <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">[</span>dom<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> bScroll <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BScroll</span><span class="token punctuation">(</span>bscrollDom<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>            <span class="token literal-property property">click</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            <span class="token literal-property property">probeType</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>            <span class="token literal-property property">bounceTime</span><span class="token operator">:</span> <span class="token number">700</span><span class="token punctuation">,</span> <span class="token comment">//回弹时间</span>            <span class="token literal-property property">pullUpLoad</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token literal-property property">threshold</span><span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token comment">// 当上拉距离超过50px时触发 pullingUp 事件</span>                <span class="token literal-property property">stop</span><span class="token operator">:</span> <span class="token number">50</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token literal-property property">pullDownRefresh</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token literal-property property">threshold</span><span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token comment">// 当下拉距离超过50px时触发 pullingDown 事件</span>                <span class="token literal-property property">stop</span><span class="token operator">:</span> <span class="token number">50</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token literal-property property">useTransition</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">// 防止iphone微信滑动卡顿</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bScroll<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"pullingDown"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>page <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span><span class="token string">"下拉刷新"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//下拉刷新图标显示</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>loadingUp <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token comment">//删除无数据提示的标识位</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>showFlag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>              <span class="token comment">//清空当前课程列表</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>lessonList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">//重新加载课程列表</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCourseData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//完成下拉操作</span>            bScroll<span class="token punctuation">.</span><span class="token function">finishPullDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bScroll<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"pullingUp"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span><span class="token string">"上拉加载"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//上划加载图标显示</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>loadingDown <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token comment">//删除无数据提示的标识位</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>showFlag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            localStorage<span class="token punctuation">.</span>selected<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//叠加</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>page <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>totalPages<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>page<span class="token operator">++</span><span class="token punctuation">;</span>                  <span class="token comment">//继续加载课程列表</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCourseData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>              <span class="token comment">//跳转页码大于总页码，无更多数据</span>              <span class="token comment">//隐藏上划加载图标</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>loadingDown <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>              <span class="token comment">//显示无数据提示的标识位</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>showFlag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token comment">//完成上划操作</span>            bScroll<span class="token punctuation">.</span><span class="token function">finishPullUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//清空bScroll</span>        bScroll<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h4><p> <a href="https://blog.csdn.net/weixin_48115935/article/details/113178939">生成二维码（qrcodesjs2）</a></p><h2 id="什么要学习前端"><a href="#什么要学习前端" class="headerlink" title="什么要学习前端"></a>什么要学习前端</h2><p>前端一开始写html页面，看着自己写出来的一个个页面就很有成就感，然后慢慢的就想写的更漂亮，交互效果越多，就开始努力学习css和js，随着页面越来越复杂，就需要学更多的东西，追求更高的代码质量，就是这样的良性循环促使自己在前端道路上一直走下去。</p><p>就业前景好（互联网应用环境）也觉得这个行业,社区很开放，很有活力。这两年前端技术井喷，感觉自己还是图样，还需要在工作中不断学习，提高知识水平</p><p>前端的技术一直推陈出新(3-6个月)，而且新技术出来后，几乎立马就能使用，不断学习，不断应用，这样的工作不会枯燥乏味。。</p><h2 id="介绍一下前端的学习经历"><a href="#介绍一下前端的学习经历" class="headerlink" title="介绍一下前端的学习经历"></a>介绍一下前端的学习经历</h2><ol><li>购买书籍 js红宝书，html网页开发</li><li>视频网站 b站</li><li>个人博客 阮一峰、等大神的博客</li><li>交流平台 掘金、csdn、w3cschool</li><li>官方文档 github、vue官方文档、supermap（leaflet）官方文档、antd、elui官方文档、</li></ol><h2 id="对未来三年职业的规划"><a href="#对未来三年职业的规划" class="headerlink" title="对未来三年职业的规划"></a>对未来三年职业的规划</h2><p>1 我是想走技术路线，想找个平台稳定地钻研<br>2 同时，我对满帮行业背景的业务很感兴趣，想在这一领域深耕一下，不仅想全面了解这块业务，而且还想全面掌握前端技术在该领域的解决方案。<br>3 为了达到这个目的，我首先会做好本职工作，然后会尽量解决项目中遇到的技术问题，如果项目里用到的技术我不熟，我会第一时间去了解。<br>4 我希望通过自己技术能力的提升，最后能够持续走技术路线，接触公司的架构，往资深研发的方向上走。在未来2-3年内达到技术专家的能力，在业务上和技术上，解决项目上的大多数问题。</p><h2 id="你认为一名前端工程师应该具备什么特点？"><a href="#你认为一名前端工程师应该具备什么特点？" class="headerlink" title="你认为一名前端工程师应该具备什么特点？"></a>你认为一名前端工程师应该具备什么特点？</h2><p>1、沟通的能力2、团队合作的能力3、审美的能力4、技术的能力5、学习的能力6、保持热爱的能</p><p>有的是跟产品开需求会或项目立会的时候，会先就具体需求的功能点先做可行性方案的讨论，如果开发成本过高的话，通常都会说服需求方用一些替代方案。又或者是一些高级的功能模块，我们会把项目拆解，分成几期，首先先出核心功能模块，上线之后再做一些高级需求的模块，实现产品的迭代开发。给ui提意见是这样的，除非你干过设计或者了解设计的创作过程，否则从设计的角度最好不要提不同的意见。可以从交互或功能或体验上给建设性的意见，另外讲的时候是需要技巧的，可以先正面肯定一下他的劳动成果或努力的结果，然后说，我这儿看到几点问题，跟你交流一下，然后布啦布啦，而不是直接上去就说，我感觉这儿怎么怎么的，很主观的，说这样根本没有一个评判的标准或依据。最后一定要说，根据你的行业经验或自我设计标准，你肯定不会允许这样的现象出现吧，然后你看要不要在重新考虑一下。我就是想到了给你提一下。</p><p>B. 要是效果图是客户提供的怎么破？在沟通是有什么经验？设计的质量如果本身就有问题，比方说就没考虑添加数据以后的情况，或者是其它页面在流程上风格上不统一怎么怎么的，客户又不是很懂，初期非要你按照他的想法来。这时候就需要站在一个更高的高度来有技巧的处理这个问题。比如说，你这个页面等上线后，在用户看来2个页面看到的按钮不一样，感觉很外行，从而导致的结果就是下次不在访问，这样用户就会丢失。</p><h2 id="有没有遇到过页面上实现不了的功能？"><a href="#有没有遇到过页面上实现不了的功能？" class="headerlink" title="有没有遇到过页面上实现不了的功能？"></a>有没有遇到过页面上实现不了的功能？</h2><p>遇到这样的问题怎么进行处理？但从ui图上，基本上都能实现，从功能上有很多都出现了问题，有困难的先根据是否有官方文档或者是否有可以参考的地方来判断自己能完成，如果这些都没有，先阅读项目手册来看是否有其他类似的功能，再通过搜索引擎来查询解决方案，如果在尝试一段时间后还是存在问题，就和他人反馈这个问题，寻求解决，<strong>在解决了之后需要反思自己为什么这块地方做不出来，是技术不行，还是文档看的不到位，还是说单纯bug没注意，影响了整体</strong>。</p><h2 id="项目中会遇到困难吗-你是怎么解决的？"><a href="#项目中会遇到困难吗-你是怎么解决的？" class="headerlink" title="项目中会遇到困难吗 你是怎么解决的？"></a>项目中会遇到困难吗 你是怎么解决的？</h2><p>面对遇到困难的需求，我会先根据是否有官方文档或者是否有可以参考的地方来判断自己能完成，如果这些都没有，那么会先分析这个需求的 实现逻辑，需要先完成什么在完成什么，一步一步来，确认当前首先需要解决什么。同时也会阅读项目手册来看是否有其他类似的功能，再通过搜索引擎来查询有没有类似的解决方案，如果在尝试一段时间后还是存在问题，就找师兄、同学去讨论，看看他人的思路是否有值得借鉴的地方，进而去解决这个问题，在解决了之后我还需要反思自己为什么这块地方做不出来，是技术不行，还是文档看的不到位，还是说单纯在写代码的过程中bug没注意，影响了整体。</p><h2 id="这个系统在代码方面有哪些不合理的地方？"><a href="#这个系统在代码方面有哪些不合理的地方？" class="headerlink" title="这个系统在代码方面有哪些不合理的地方？"></a>这个系统在代码方面有哪些不合理的地方？</h2><p>组件抽取做的不好<br>单个文件代码过长各种命名太随意，用中文缩写<br>单个页面不要和其他页面、全局耦合<br>能用组件的坚决不自己写（自己写时间格式化方法）<br>注释写的太少<br>编译问题太多</p><h2 id="前端难点"><a href="#前端难点" class="headerlink" title="前端难点"></a>前端难点</h2><ol><li>平台、浏览器生态复杂，要考虑的场景太多，不同平台上实现同一界面功能的重复劳动严重，这个难点在于如何消除前端开发的重复劳动。</li><li>当需求发生变化的时候，最先往往就是前端，而很多需求变化和后端无关，单纯就是前端的改变。这些需求改变有的是不合理的，但是，客观来说，也有不少是有必要的需求改变，用户的喜好会变化，用户的喜好我们也要反复揣摩，也就是要适应需求变化，所以，难点就成了如何让前端开发适应快速变化的需求。</li><li>前端的学习曲线其实挺陡，技术迭代更新很快，这就需要前端开发者不断学习。</li></ol><h2 id="个人的优缺点"><a href="#个人的优缺点" class="headerlink" title="个人的优缺点"></a>个人的优缺点</h2><p>考虑问题还不够全面，这边改了，对其他组件的影响还没考虑过去，有时间限制的影响，也有自己对整体项目的把握度不够，通过锻炼可以成长克服这个问题</p><p>善于沟通、项目中难免会存在分歧与争执，交流</p><h2 id="你选择公司的标准是什么？"><a href="#你选择公司的标准是什么？" class="headerlink" title="你选择公司的标准是什么？"></a>你选择公司的标准是什么？</h2><ul><li>企业文化</li><li>成长，</li><li>稳定，</li></ul><h2 id="你觉得自己有什么特有的品质吗？"><a href="#你觉得自己有什么特有的品质吗？" class="headerlink" title="你觉得自己有什么特有的品质吗？"></a>你觉得自己有什么特有的品质吗？</h2><p>抗压能力强、沟通能力可、开朗乐观、做事主动认真积极</p><h2 id="你如何看待加班？"><a href="#你如何看待加班？" class="headerlink" title="你如何看待加班？"></a>你如何看待加班？</h2><p>如果是自己负责的内容没有做完的话，我会自己主动加班完成自己的任务，如果领导要求的话，我也愿意配合团队进度，进行加班</p><p>首先去是肯定要去的，既然休息日让回来，说明肯定是重要的事情，项目紧急或者自己负责的地方bug了，大家一起加班，把这关克服就好了，如果是后者的话，就需要反思自己了。</p><h2 id="你希望与怎样的领导共事？"><a href="#你希望与怎样的领导共事？" class="headerlink" title="你希望与怎样的领导共事？"></a>你希望与怎样的领导共事？</h2><p>在员工遇到难题的时候，能够提供指导。<br>踏实认真，做一件事就认真做，好好做，员工朝着一个目标一起努力</p><h2 id="你最近在看什么书？"><a href="#你最近在看什么书？" class="headerlink" title="你最近在看什么书？"></a>你最近在看什么书？</h2><p>技术类书籍：js红宝书<br>娱乐类书籍：随便说一个<br>电影：随便说一个</p>]]></content>
      
      
      <categories>
          
          <category> xwing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vite</title>
      <link href="/zyhxwing/2022/09/05/vite/"/>
      <url>/zyhxwing/2022/09/05/vite/</url>
      
        <content type="html"><![CDATA[<h1 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h1><h2 id="vite是什么"><a href="#vite是什么" class="headerlink" title="vite是什么"></a>vite是什么</h2><p><a href="https://vitejs.cn/">vite</a></p><p>在浏览器支持 ES 模块之前，JavaScript 并没有提供的原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。</p><p>时过境迁，我们见证了诸如 webpack、Rollup 和 Parcel 等工具的变迁，它们极大地改善了前端开发者的开发体验。</p><p>然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。我们开始遇到性能瓶颈 —— 使用 JavaScript 开发的工具通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用 HMR，文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。</p><p>vite面向现代浏览器，所以它利用浏览器去解析imports，在服务器端按需编译返回，<strong>跳过打包过程</strong>。同时支持Vue文件和HMR（热更新），针对生产环境可以使用<strong>rollup</strong>打包。</p><h3 id="vite解决了什么"><a href="#vite解决了什么" class="headerlink" title="vite解决了什么"></a>vite解决了什么</h3><h4 id="缓慢的启动时间"><a href="#缓慢的启动时间" class="headerlink" title="缓慢的启动时间"></a>缓慢的启动时间</h4><p>Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。</p><ul><li>依赖 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。</li></ul><p>Vite 将会使用 <strong>esbuild 预构建依赖</strong>。Esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。</p><ul><li>源码 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue&#x2F;Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。</li></ul><p>Vite 以 <strong>原生 ESM 方式提供源码</strong>。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。</p><h4 id="缓慢的更新"><a href="#缓慢的更新" class="headerlink" title="缓慢的更新"></a>缓慢的更新</h4><p>基于打包器启动时，重建整个包的效率很低。原因显而易见：因为这样更新速度会随着应用体积增长而直线下降。</p><p>一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活，但它也仍需要整个重新构建并重载页面。这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热重载（HMR）：允许一个模块 “热替换” 它自己，而不会影响页面其余部分。这大大改进了开发体验 —— 然而，在实践中我们发现，即使采用了 HMR 模式，其热更新速度也会随着应用规模的增长而显著下降。</p><p>在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。</p><p>Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age&#x3D;31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。</p><h2 id="vite和webpack区别"><a href="#vite和webpack区别" class="headerlink" title="vite和webpack区别"></a>vite和webpack区别</h2><p>webpack是一个JavaScript应用程序的静态模块打包工具，它会对整个应用程序进行依赖关系图构建。<br>vite是构建工具的高阶封装，使用简单，快（开发的时候感觉没有编译过程），便于扩展。而他集成的esbuild(Go 编写) 预构建依赖，比node快 10-100 倍。<br>和webpack的区别：</p><h3 id="关注层级不同"><a href="#关注层级不同" class="headerlink" title="关注层级不同"></a>关注层级不同</h3><p>vite关注的层级更高：vite是 high level api，关注的是如何快速方便的搭建项目，相比webpack，减少了很多配置量。<br>webpack关注的层级更低：webpack是low level api，因为webpack更关注的是各种功能的实现，重点放在构建上。</p><h3 id="vite自己不包含编译能力。"><a href="#vite自己不包含编译能力。" class="headerlink" title="vite自己不包含编译能力。"></a>vite自己不包含编译能力。</h3><p>它本身并不参与编译，它的编译能力只是集成了<strong>rollup</strong>和<strong>ESbuild</strong>的功能.</p><h3 id="启动项目vite更快，可以说是超级快。"><a href="#启动项目vite更快，可以说是超级快。" class="headerlink" title="启动项目vite更快，可以说是超级快。"></a>启动项目vite更快，可以说是超级快。</h3><p>对比webpack在dev-serve的时候，会提交所有编译的文件，而vite在dev-serve的时候利用了浏览器的native ES module功能，在浏览器请求对应的url时才提供文件，实现了根据路由的懒加载，所以启动的时候是超快的。</p><h3 id="vite的热更新更快。"><a href="#vite的热更新更快。" class="headerlink" title="vite的热更新更快。"></a>vite的热更新更快。</h3><p>对比webpack的热更新，热更新时，把改动过模块的相关依赖模块全部编译一次。而vite热更新时，仅让浏览器重新请求改动过的模块。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vite </tag>
            
            <tag> 打包工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/zyhxwing/2022/09/05/webpack/"/>
      <url>/zyhxwing/2022/09/05/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>首先，认为它是一个工具，帮助我们更好的处理事情的。</p><ul><li><p>其次，“打包”，如何理解？ 假设我们需要寄快递。我们将许多的物品都放进了一个纸皮箱，然后进行封箱。 这就是打包。 对应到前端开发来说，就是将很多的的 css文件，js文件，图片等“物品”，全都写进一个js文件，而不是在一个html页面通过script,link标签去引入多个静态资源。</p></li><li><p>模块化，其实不同的css，不同的js就是一个模块。比如说，一个index.html,通常会有一个index.css, 一个index.js，还有其他的css，js。这些不同的文件都可以看做不同的模块。不同的模块有各自的作用。</p></li></ul><p>总结来说：用这个工具，帮助我们将不同的资源和文件，进行打包，也就是合并在一个文件里面。 但是不仅仅如此，它还附加了一些更好用的功能。</p><p>附加功能：<br>1.CSS 预处理。将 Less, Sass 编译成css<br>2.ES6 语法 转成 ES5 …（等待学习后补充）</p><p>2.作用<br>将浏览器不认识的语法编译成浏览器认识的语法。比如less编译成css，ES6 语法 转成 ES5等等，同时能够减少io请求。</p><p><strong>为什么说能减少io请求：通常我们在请求后，会返回一个html到浏览器。这时，我们如果打开控制台，就会发现在html页面通过script,link等标签引用的静态资源， 浏览器会再次发出请求去获取这些资源。但是通过webpack的打包，将所有的静态资源都合并好了，减少了io请求。</strong></p><h2 id="为什么使用了VueCli后就用不到WebPack了？"><a href="#为什么使用了VueCli后就用不到WebPack了？" class="headerlink" title="为什么使用了VueCli后就用不到WebPack了？"></a>为什么使用了VueCli后就用不到WebPack了？</h2><p>vuecli会配置好webpack，所以再进行打包等操作时无需再自行配置webpack</p><h2 id="WebPack中loader和plugin的区别？"><a href="#WebPack中loader和plugin的区别？" class="headerlink" title="WebPack中loader和plugin的区别？"></a>WebPack中loader和plugin的区别？</h2><p>loader本质是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识JavaScript，<strong>所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。主要功能是转换器，转换某些模板的语言</strong>，例如es6转化为es5，转换less。<br>loader在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p><p>plugin作用是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，<strong>在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</strong>对webpack本身功能的拓展，例如压缩js文件、webpack-bundle-analyzer可视化 Webpack 输出文件的体积。Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p><h2 id="WebPack构建过程"><a href="#WebPack构建过程" class="headerlink" title="WebPack构建过程"></a>WebPack构建过程</h2><ul><li>初始化：启动构建，从配置文件和 Shell 语句中读取与合并配置参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数，加载 Plugin，实例化 Compiler</li><li>编译：调用Compiler的run来真正启动webpack编译构建过程，从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li><li>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</li></ul><h2 id="常见的loader"><a href="#常见的loader" class="headerlink" title="常见的loader"></a>常见的loader</h2><ul><li>raw-loader：加载文件原始内容（utf-8）</li><li><strong>image-loader：加载并且压缩图片文件</strong></li><li><strong>babel-loader：把 ES6 转换成 ES5</strong></li><li>sass-loader：将SCSS&#x2F;SASS代码转换成CSS</li><li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li><li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li><li>vue-loader：加载 Vue.js 单文件组件i18n-loader: 国际化</li></ul><h2 id="常见的plugin"><a href="#常见的plugin" class="headerlink" title="常见的plugin"></a>常见的plugin</h2><ul><li>define-plugin：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</li><li>ignore-plugin：忽略部分文件</li><li>html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)</li><li><strong>webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积</strong></li><li>mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载</li><li>serviceworker-webpack-plugin：为网页应用增加离线缓存功能</li><li>clean-webpack-plugin: 目录清理</li><li>size-plugin：监控资源体积变化，尽早发现问题</li></ul><h2 id="source-map是什么？生产环境怎么用？"><a href="#source-map是什么？生产环境怎么用？" class="headerlink" title="source map是什么？生产环境怎么用？"></a>source map是什么？生产环境怎么用？</h2><p>线上的代码多是压缩后的，如果线上有报错却只能调试那个代码多半是个噩梦，不具备良好的可读性。因此我们需要有一个桥梁帮助我们搭建起源代码及压缩后代码的联系，source map 就是起了这个作用。</p><p>线上环境一般有三种处理方案：</p><p>hidden-source-map：借助第三方错误监控平台 Sentry 使用<br>nosources-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高<br>sourcemap：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)</p><p>注意：避免在生产中使用 inline- 和 eval-，因为它们会增加 bundle 体积大小，并降低整体性能。</p><h3 id="source-map-是如何对应到源代码的？"><a href="#source-map-是如何对应到源代码的？" class="headerlink" title="source map 是如何对应到源代码的？"></a>source map 是如何对应到源代码的？</h3><p>我们还是以刚才打包的文件为例，来看看产出的 source map 长啥样</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>  <span class="token literal-property property">sources</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"webpack://webpack-source-demo/./src/index.js"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">names</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'console'</span><span class="token punctuation">,</span> <span class="token string">'log'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">mappings</span><span class="token operator">:</span> <span class="token string">'AACAA,QAAQC,IADE'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>英文，表示源码及压缩代码的位置关联;逗号，分隔一行代码中的内容。比如说 console.log(a) 就由 console 、log 及 a 三部分组成，所以存在两个逗号;分号，代表换行</p><p>英文从左到右分别表示：</p><ul><li>压缩代码的第几列</li><li>哪个源代码文件，毕竟可以多个文件打包成一个，对应 sources 字段</li><li>源代码第几行</li><li>源代码第几列</li><li>names 字段里的索引</li></ul><p>AACAA就代表了</p><ul><li>压缩代码的第一列</li><li>第一个源代码文件，也就是 index.js 文件了</li><li>源代码第二行</li><li>源代码的第一列</li><li>names 数组中的第一个索引，也就是 console</li></ul><h2 id="Webpack-文件监听原理呢"><a href="#Webpack-文件监听原理呢" class="headerlink" title="Webpack 文件监听原理呢"></a>Webpack 文件监听原理呢</h2><p>在发现源码发生变化时，自动重新构建出新的输出文件。<br>Webpack开启监听模式，有两种方式：</p><ul><li>启动 webpack 命令时，带上 –watch 参数在</li><li>配置 webpack.config.js 中设置 watch:true<br>缺点：每次需要手动刷新浏览器，可以通过<strong>热更新</strong>解决</li></ul><p><strong>原理：</strong>轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 aggregateTimeout 后再执行</p><h2 id="Webpack-的热更新原理"><a href="#Webpack-的热更新原理" class="headerlink" title="Webpack 的热更新原理"></a>Webpack 的热更新原理</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eb4ebd032164e6bb14ed2154b5cd76a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="热更新原理"><br>Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><ul><li>bundle.js： 构建输出的文件。</li><li>Webapck Compiler： webpack 的编辑器，将 JS 源代码编译为 bundle.js。</li><li>HMR Server： 将热更新的文件传输给 HMT Runtime。</li><li>Bundle Server： 在浏览器中，可以以服务器的形式访问文件</li><li>HMR Runtime： 在打包阶段被注入浏览器的 bundle.js 中，使 bundle.js 和 Server 建起链接（Web Socket），在文件发生变化时，自动更新 bundle.js 中的 Code。</li></ul><p>启动阶段：</p><ol><li>在文件系统中进行编译</li><li>通过 Webpack Compiler 进行打包</li><li>将打包好的文件传输给 Bundle Server</li><li>启动服务，使浏览器以 Server 的形式访问 bundle.js</li></ol><p>文件更新阶段：</p><ol><li>文件系统中的内容发生变化</li><li>通过 Webpack Compiler 进行打包，生成新的hash<strong>（文件指纹）</strong></li><li>将打包好的文件传输给 HMR Server，并带上构建时的 hash，让HMR Server与上一次资源进行对比，分析哪些代码发生了改变</li><li>HMR Server（服务端）将改变通知到 HMR Runtime（客户端）</li><li>HMR Runtime 向Bundle Server发起请求，更新 bundle.js 中的代码</li></ol><h2 id="文件指纹是什么？怎么用？"><a href="#文件指纹是什么？怎么用？" class="headerlink" title="文件指纹是什么？怎么用？"></a>文件指纹是什么？怎么用？</h2><p>文件指纹是打包后输出的文件名的后缀<br>文件指纹通常有两个用途：</p><p><strong>版本管理：</strong> 在发布版本时，通过文件指纹来区分 修改的文件 和 未修改的文件。<br><strong>使用缓存：</strong> 未修改的文件，文件指纹保持不变，浏览器继续使用缓存访问。</p><p>Hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改<br>Chunkhash：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash<br>Contenthash：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变</p><p><strong>Compiler 模块是 webpack 的主要引擎，在 webpack 首次启动时会返回一个 Compiler 实例，而 Compiler 通过 Compilation 模块可以创建新的 compilation 实例，这个 compilation 实例能够访问依赖图中所有模块，也就是说项目中的任一文件的变化都会引起 compilation 实例的变化</strong>。</p><p>JS的文件指纹设置<br>设置 output 的 filename，用 chunkhash。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">app</span><span class="token operator">:</span> <span class="token string">'./scr/app.js'</span><span class="token punctuation">,</span>        <span class="token literal-property property">search</span><span class="token operator">:</span> <span class="token string">'./src/search.js'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'[name][chunkhash:8].js'</span><span class="token punctuation">,</span>        <span class="token literal-property property">path</span><span class="token operator">:</span>__dirname <span class="token operator">+</span> <span class="token string">'/dist'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CSS的文件指纹设置<br>设置 MiniCssExtractPlugin 的 filename，使用 contenthash。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">app</span><span class="token operator">:</span> <span class="token string">'./scr/app.js'</span><span class="token punctuation">,</span>        <span class="token literal-property property">search</span><span class="token operator">:</span> <span class="token string">'./src/search.js'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'[name][chunkhash:8].js'</span><span class="token punctuation">,</span>        <span class="token literal-property property">path</span><span class="token operator">:</span>__dirname <span class="token operator">+</span> <span class="token string">'/dist'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">plugins</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[name][contenthash:8].css</span><span class="token template-punctuation string">`</span></span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图片的文件指纹设置<br>设置file-loader的name，使用hash。</p><p>占位符名称及含义</p><p>ext    资源后缀名<br>name   文件名称<br>path   文件的相对路径<br>folder 文件所在的文件夹<br>contenthash  文件的内容hash，默认是md5生成<br>hash  文件内容的hash，默认是md5生成<br>emoji  一个随机的指代文件内容的emoj</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>    <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">filename</span><span class="token operator">:</span><span class="token string">'bundle.js'</span><span class="token punctuation">,</span>        <span class="token literal-property property">path</span><span class="token operator">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">module</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">rules</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span>            <span class="token literal-property property">test</span><span class="token operator">:</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(png|svg|jpg|gif)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>            <span class="token literal-property property">use</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">loader</span><span class="token operator">:</span><span class="token string">'file-loader'</span><span class="token punctuation">,</span>                <span class="token literal-property property">options</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>                    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'img/[name][hash:8].[ext]'</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如何对bundle体积进行监控和分析？"><a href="#如何对bundle体积进行监控和分析？" class="headerlink" title="如何对bundle体积进行监控和分析？"></a>如何对bundle体积进行监控和分析？</h2><p>VSCode 中有一个插件 <strong>Import Cost</strong> 可以帮助我们对引入模块的大小进行实时监测，还可以使用 <strong>webpack-bundle-analyzer</strong> 生成 bundle 的模块组成图，显示所占体积。<br><strong>bundlesize</strong> 工具包可以进行自动化资源体积监控。</p><h2 id="如何保证各个loader按照预想方式工作"><a href="#如何保证各个loader按照预想方式工作" class="headerlink" title="如何保证各个loader按照预想方式工作"></a>如何保证各个loader按照预想方式工作</h2><p>可以使用 <strong>enforce</strong> 强制执行 loader 的作用顺序，<strong>pre</strong> 代表在所有正常 loader 之前执行，<strong>post</strong> 是所有 loader 之后执行。(inline 官方不推荐使用)</p><h2 id="如何优化-Webpack-的构建速度？"><a href="#如何优化-Webpack-的构建速度？" class="headerlink" title="如何优化 Webpack 的构建速度？"></a>如何优化 Webpack 的构建速度？</h2><p>使用高版本的 Webpack 和 Node.js<br>多进程&#x2F;多实例构建：thread-loader<br>压缩代码<br>多进程并行压缩<br>webpack-paralle-uglify-pluginuglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)terser-webpack-plugin 开启 parallel 参数<br>通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。<br>图片压缩</p><p>使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)配置 image-webpack-loader<br>缩小打包作用域：</p><p>exclude&#x2F;include (确定 loader 规则范围)resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)resolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)resolve.extensions 尽可能减少后缀尝试的可能性noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)IgnorePlugin (完全排除模块)合理使用alias<br>提取页面公共资源：</p><p>基础包分离：</p><p>使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件</p><p>DLL：</p><p>使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。HashedModuleIdsPlugin 可以解决模块数字id问题<br>充分利用缓存提升二次构建速度：</p><p>babel-loader 开启缓存terser-webpack-plugin 开启缓存使用 cache-loader 或者 hard-source-webpack-plugin<br>Tree shaking</p><p>打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码</p><p>purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)</p><p>Scope hoisting</p><p>构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法<br>动态Polyfill</p><p>建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护。 (部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)</p><h2 id="代码分割的本质"><a href="#代码分割的本质" class="headerlink" title="代码分割的本质"></a>代码分割的本质</h2><p>某个模块被多个入口模块引用时，它就会被打包多次（在最终打包出来的某几个文件里，它们都会有一份相同的代码）。当项目业务越来越复杂，打包出来的代码会非常冗余，文件体积会非常庞大。大体积文件会增加编译时间，影响开发效率；如果直接上线，还会拉长请求和加载时长，影响网站体验。作为一个追求极致体验的攻城狮，是不能忍的。所以在多页应用中优化打包尤为必要。那么如何优化webpack打包呢</p><p>代码分割的本质其实就是在源代码直接上线和打包成唯一脚本main.bundle.js这两种极端方案之间的一种更适合实际场景的中间状态。</p><p>「用可接受的服务器性能压力增加来换取更好的用户体验。」<br>源代码直接上线：虽然过程可控，但是http请求多，性能开销大。<br>打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。</p><h2 id="编写loader的思路"><a href="#编写loader的思路" class="headerlink" title="编写loader的思路"></a>编写loader的思路</h2><p>Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。</p><ul><li>Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用</li><li>Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw &#x3D; true 告诉 Webpack 该 Loader 是否需要二进制数据</li><li>尽可能的异步化 Loader，如果计算量很小，同步也可以</li><li>Loader 是无状态的，我们不应该在 Loader 中保留状态</li><li>使用 loader-utils 和 schema-utils 为我们提供的实用工具</li><li>加载本地 Loader 方法：Npm link、ResolveLoader</li></ul><ol><li>创建一个js 文件，在文件中写function，并用module.exports暴露，同时return值</li><li>配置webpack， 在module. rules中设置test（待处理文件），use（处理的方式，即步骤1js文件），可以写多个use，先写的user会被后面执行</li><li>在入口文件导入这个脚本，如果不引用该文件的话，webpack是不会对该文件进行打包处理的，那么你的loader也不会执行</li></ol><h2 id="编写Plugin的思路"><a href="#编写Plugin的思路" class="headerlink" title="编写Plugin的思路"></a>编写Plugin的思路</h2><p>webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。Webpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。</p><ul><li>compiler 暴露了和 Webpack 整个生命周期相关的钩子</li><li>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子</li><li>插件需要在其原型上<strong>绑定apply方法</strong>，才能访问 compiler 实例传给每个插件的 compiler 和 compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件</li><li><strong>找出合适的事件点去完成想要的功能</strong>：1.emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机）2.watch-run 当依赖的文件发生变化时会触发</li><li><strong>异步的事件需要在插件处理完任务时调用回调函数通知</strong> Webpack 进入下一个流程，不然会卡住</li></ul><ol><li>创建一个js 文件，在文件中写class，并用module.exports暴露</li><li>配置webpack， 在plugins 设置new class（类名，即步骤1的js文件里的class）</li><li>执行编译命令</li></ol><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;遍历compilation.assets模块。对符合要求的文件进行正则替换class CssPathTransfor &#123;  apply (compiler) &#123;    compiler.plugin(&#39;emit&#39;, (compilation, callback) &#x3D;&gt; &#123;      console.log(&#39;--CssPathTransfor emit&#39;)      &#x2F;&#x2F; 遍历所有资源文件      for (var filePathName in compilation.assets) &#123;        &#x2F;&#x2F; 查看对应的文件是否符合指定目录下的文件        if (&#x2F;static\&#x2F;css\&#x2F;pages&#x2F;i.test(filePathName)) &#123;          &#x2F;&#x2F; 引入路径正则          const reg &#x3D; &#x2F;\&#x2F;static\&#x2F;css\&#x2F;vendor\.wxss&#x2F;i          &#x2F;&#x2F; 需要替换的最终字符串          const finalStr &#x3D; &#39;&#x2F;subPages&#x2F;enjoy_given&#x2F;static&#x2F;css&#x2F;vendor.wxss&#39;          &#x2F;&#x2F; 获取文件内容          let content &#x3D; compilation.assets[filePathName].source() || &#39;&#39;                    content &#x3D; content.replace(reg, finalStr)          &#x2F;&#x2F; 重写指定输出模块内容          compilation.assets[filePathName] &#x3D; &#123;            source () &#123;              return content;            &#125;,            size () &#123;              return content.length;            &#125;          &#125;        &#125;      &#125;      callback()    &#125;)  &#125;&#125;module.exports &#x3D; CssPathTransfor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Babel原理吧"><a href="#Babel原理吧" class="headerlink" title="Babel原理吧"></a>Babel原理吧</h2><p>大多数JavaScript Parser遵循 estree 规范，Babel 最初基于 acorn 项目(轻量级现代 JavaScript 解析器)<br>Babel大概分为三大部分：</p><ol><li>解析：将代码转换成 AST抽象语法树</li></ol><ul><li>词法分析：将代码(字符串)分割为token流，即语法单元成的数组</li><li>语法分析：分析token流(上面生成的数组)并生成 AST</li></ul><ol start="2"><li><p>转换：访问 AST 的节点进行变换操作生产新的 AST<br>Taro就是利用 babel 完成的小程序语法转换</p></li><li><p>生成：以新的 AST 为基础生成代码</p></li></ol><h2 id="常见的其他构建工具"><a href="#常见的其他构建工具" class="headerlink" title="常见的其他构建工具"></a>常见的其他构建工具</h2><h3 id="1-Npm-Script"><a href="#1-Npm-Script" class="headerlink" title="1. Npm Script"></a>1. Npm Script</h3><p>Npm Script是一个任务执行者。Npm 是在安装 Node.js 时附带的包管理器，Npm Script 则是 Npm 内置的一个功能，允许在<code>package.json</code>文件里面使用<code>scripts</code>字段定义任务：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;node dev.js&quot;,    &quot;pub&quot;: &quot;node build.js&quot;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里面的<code>scripts</code>字段是一个对象，每个属性对应一段 Shell 脚本，以上代码定义了两个任务<code>dev</code>和<code>pub</code>。 其底层实现原理是通过调用 Shell 去运行脚本命令，例如执行<code>npm run pub</code>命令等同于执行命令<code>node build.js</code>。<br><strong>Npm Script的优点</strong>是内置，无须安装其他依赖。<br><strong>Npm Script的缺点</strong>是功能太简单，虽然提供了<code>pre</code>和<code>post</code>两个钩子，但不能方便地管理多个任务之间的依赖。</p><h3 id="2-Grunt"><a href="#2-Grunt" class="headerlink" title="2. Grunt"></a>2. Grunt</h3><p>Grunt和 Npm Script 类似，也是一个任务执行者。Grunt 有大量现成的插件封装了常见的任务，也能管理任务之间的依赖关系，自动化执行依赖的任务，每个任务的具体执行代码和依赖关系写在配置文件<code>Gruntfile.js</code>里，例如：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">module.exports &#x3D; function(grunt) &#123;  &#x2F;&#x2F; 所有插件的配置信息  grunt.initConfig(&#123;    &#x2F;&#x2F; uglify 插件的配置信息    uglify: &#123;      app_task: &#123;        files: &#123;          &#39;build&#x2F;app.min.js&#39;: [&#39;lib&#x2F;index.js&#39;, &#39;lib&#x2F;test.js&#39;]        &#125;      &#125;    &#125;,    &#x2F;&#x2F; watch 插件的配置信息    watch: &#123;      another: &#123;          files: [&#39;lib&#x2F;*.js&#39;],      &#125;    &#125;  &#125;);  &#x2F;&#x2F; 告诉 grunt 我们将使用这些插件  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);  &#x2F;&#x2F; 告诉grunt当我们在终端中启动 grunt 时需要执行哪些任务  grunt.registerTask(&#39;dev&#39;, [&#39;uglify&#39;,&#39;watch&#39;]);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在项目根目录下执行命令<code>grunt dev</code>就会启动 JavaScript 文件压缩和自动刷新功能。<br><strong>Grunt的优点是：</strong></p><ul><li>灵活，它只负责执行你定义的任务；</li><li>大量的可复用插件封装好了常见的构建任务。</li></ul><p><strong>Grunt的缺点</strong>是集成度不高，要写很多配置后才可以用，无法做到开箱即用。<br>Grunt 相当于进化版的 Npm Script，它的诞生其实是为了弥补 Npm Script 的不足。</p><h3 id="3-Gulp"><a href="#3-Gulp" class="headerlink" title="3. Gulp"></a>3. Gulp</h3><p>Gulp是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件。Gulp 被设计得非常简单，只通过下面5个方法就可以胜任几乎所有构建场景</p><ul><li>通过<code>gulp.task</code>注册一个任务；</li><li>通过<code>gulp.run</code>执行任务；</li><li>通过<code>gulp.watch</code>监听文件变化；</li><li>通过<code>gulp.src</code>读取文件；</li><li>通过<code>gulp.dest</code>写文件。</li></ul><p>Gulp 的最大特点是引入了<strong>流</strong>的概念，同时提供了一系列常用的插件去处理流，流可以在插件之间传递，大致使用如下：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 引入 Gulpvar gulp &#x3D; require(&#39;gulp&#39;); &#x2F;&#x2F; 引入插件var jshint &#x3D; require(&#39;gulp-jshint&#39;);var sass &#x3D; require(&#39;gulp-sass&#39;);var concat &#x3D; require(&#39;gulp-concat&#39;);var uglify &#x3D; require(&#39;gulp-uglify&#39;);&#x2F;&#x2F; 编译 SCSS 任务gulp.task(&#39;sass&#39;, function() &#123;  &#x2F;&#x2F; 读取文件通过管道喂给插件  gulp.src(&#39;.&#x2F;scss&#x2F;*.scss&#39;)    &#x2F;&#x2F; SCSS 插件把 scss 文件编译成 CSS 文件    .pipe(sass())    &#x2F;&#x2F; 输出文件    .pipe(gulp.dest(&#39;.&#x2F;css&#39;));&#125;);&#x2F;&#x2F; 合并压缩 JSgulp.task(&#39;scripts&#39;, function() &#123;  gulp.src(&#39;.&#x2F;js&#x2F;*.js&#39;)    .pipe(concat(&#39;all.js&#39;))    .pipe(uglify())    .pipe(gulp.dest(&#39;.&#x2F;dist&#39;));&#125;);&#x2F;&#x2F; 监听文件变化gulp.task(&#39;watch&#39;, function()&#123;  &#x2F;&#x2F; 当 scss 文件被编辑时执行 SCSS 任务  gulp.watch(&#39;.&#x2F;scss&#x2F;*.scss&#39;, [&#39;sass&#39;]);  gulp.watch(&#39;.&#x2F;js&#x2F;*.js&#39;, [&#39;scripts&#39;]);    &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Gulp 的优点</strong>是好用又不失灵活，既可以单独完成构建也可以和其它工具搭配使用。<br><strong>Gulp 的缺点</strong>是和 Grunt 类似，集成度不高，要写很多配置后才可以用，无法做到开箱即用。<br>可以将Gulp 看作 Grunt 的加强版。相对于 Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。</p><h3 id="4-Fis3"><a href="#4-Fis3" class="headerlink" title="4. Fis3"></a>4. Fis3</h3><p><a href="http://fis.baidu.com/">Fis3</a>是一个来自百度的优秀国产构建工具。相对于 Grunt、Gulp 这些只提供基本功能的工具，Fis3 集成了 Web 开发中的常用构建功能，如下所述</p><ul><li>读写文件：通过<code>fis.match</code>读文件，<code>release</code>配置文件输出路径。</li><li>资源定位：解析文件之间的依赖关系和文件位置。</li><li>文件指纹：通过<code>useHash</code>配置输出文件时给文件 URL 加上 md5 戳来优化浏览器缓存。</li><li>文件编译：通过<code>parser</code>配置文件解析器做文件转换，例如把 ES6 编译成 ES5。</li><li>压缩资源：通过<code>optimizer</code>配置代码压缩方法。</li><li>图片合并：通过<code>spriter</code>配置合并 CSS 里导入的图片到一个文件来减少 HTTP 请求数。</li></ul><p>大致使用如下：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 加 md5fis.match(&#39;*.&#123;js,css,png&#125;&#39;, &#123;  useHash: true&#125;);&#x2F;&#x2F; fis3-parser-typescript 插件把 TypeScript 文件转换成 JavaScript 文件fis.match(&#39;*.ts&#39;, &#123;  parser: fis.plugin(&#39;typescript&#39;)&#125;);&#x2F;&#x2F; 对 CSS 进行雪碧图合并fis.match(&#39;*.css&#39;, &#123;  &#x2F;&#x2F; 给匹配到的文件分配属性 &#96;useSprite&#96;  useSprite: true&#125;);&#x2F;&#x2F; 压缩 JavaScriptfis.match(&#39;*.js&#39;, &#123;  optimizer: fis.plugin(&#39;uglify-js&#39;)&#125;);&#x2F;&#x2F; 压缩 CSSfis.match(&#39;*.css&#39;, &#123;  optimizer: fis.plugin(&#39;clean-css&#39;)&#125;);&#x2F;&#x2F; 压缩图片fis.match(&#39;*.png&#39;, &#123;  optimizer: fis.plugin(&#39;png-compressor&#39;)&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出 Fis3 很强大，内置了许多功能，无须做太多配置就能完成大量工作。<br><strong>Fis3的优点</strong>是集成了各种 Web 开发所需的构建功能，配置简单开箱即用。<br><strong>Fis3的缺点</strong>是目前官方已经不再更新和维护，不支持最新版本的 Node.js。<br>Fis3 是一种专注于 Web 开发的完整解决方案，如果将 Grunt、Gulp 比作汽车的发动机，则可以将Fis3 比作一辆完整的汽车。</p><h3 id="5-Webpack"><a href="#5-Webpack" class="headerlink" title="5. Webpack"></a>5. Webpack</h3><p><a href="https://webpack.js.org/">Webpack</a>是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。Webpack 专注于构建模块化项目。<br>其官网的首页图很形象的画出了 Webpack 是什么，如下：<br><img src="http://webpack.wuhaolin.cn/1%E5%85%A5%E9%97%A8/img/1-2webpack.png" alt="webpack"><br>一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打包。 经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。<br>Webpack 具有很大的灵活性，能配置如何处理文件，大致使用如下：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">module.exports &#x3D; &#123;  &#x2F;&#x2F; 所有模块的入口，Webpack 从入口开始递归解析出所有依赖的模块  entry: &#39;.&#x2F;app.js&#39;,  output: &#123;    &#x2F;&#x2F; 把入口所依赖的所有模块打包成一个文件 bundle.js 输出     filename: &#39;bundle.js&#39;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Webpack的优点是：</strong></p><ul><li>专注于处理模块化的项目，能做到开箱即用一步到位；</li><li>通过 Plugin 扩展，完整好用又不失灵活；</li><li>使用场景不仅限于 Web 开发；</li><li>社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；</li><li>良好的开发体验。</li></ul><p><strong>Webpack的缺点</strong>是只能用于采用模块化开发的项目。</p><h3 id="6-Rollup"><a href="#6-Rollup" class="headerlink" title="6. Rollup"></a>6. Rollup</h3><p><a href="https://rollupjs.org/guide/en/">Rollup</a>是一个和 Webpack 很类似但专注于 ES6 的模块打包工具。 Rollup 的亮点在于能针对 ES6 源码进行 Tree Shaking 以去除那些已被定义但没被使用的代码，以及 Scope Hoisting 以减小输出文件大小提升运行性能。 然而 Rollup 的这些亮点随后就被 Webpack 模仿和实现。 由于 Rollup 的使用和 Webpack 差不多，这里就不详细介绍如何使用了，而是详细说明它们的差别：</p><ul><li>Rollup 是在 Webpack 流行后出现的替代品；</li><li>Rollup 生态链还不完善，体验不如 Webpack；</li><li>Rollup 功能不如 Webpack 完善，但其配置和使用更加简单；</li><li>Rollup 不支持 Code Spliting，但好处是打包出来的代码中没有 Webpack 那段模块的加载、执行和缓存的代码。</li></ul><p>Rollup 在用于打包 JavaScript 库时比 Webpack 更加有优势，因为其打包出来的代码更小更快。 但功能不够完善，很多场景都找不到现成的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包工具 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="/zyhxwing/2022/09/05/css/"/>
      <url>/zyhxwing/2022/09/05/css/</url>
      
        <content type="html"><![CDATA[<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h2><ol><li>圆角border-radius</li><li>阴影之box-shadow</li><li>阴影之text-shadow</li><li>背景渐变linear-gradient</li><li>转换transform</li><li>translate()移动</li><li>rotate()旋转</li><li>scale()缩放</li><li>skew()倾斜</li><li>3D转换之rotateX()</li><li>3D转换之rotateY()</li><li>translate3d()</li></ol><ul><li>过渡transition</li></ul><ol start="13"><li>动画animation</li></ol><ul><li>@keyframes创建动画</li><li>animation执行动画</li></ul><ol start="14"><li>媒体查询 自动获取当前设备的屏幕信息. 以便于采用渲染方式. 使同一种样式在不同设备上显示出不同的效果。</li></ol><ul><li>设置meta标签</li><li>媒体查询语句</li></ul><ol start="15"><li>响应式布局 响应式局部就是让一套代码能够在不同设备上显示. 通过隐藏或者缩小相关元素来实现整个网页的功能完整性和美观性</li><li>栅格系统 col&#x2F;row栅格系统是媒体查询的具体实现. 是一种规定的写法. 能够最小限度保证在各个设备上的显示美观性。</li></ol><h2 id="css选择器优先级"><a href="#css选择器优先级" class="headerlink" title="css选择器优先级"></a>css选择器优先级</h2><p>css选择器优先级最高到最低顺序为：</p><ol><li>id选择器(#myid)</li><li>类选择器(.myclassname)、伪类选择器（li：last-child）、属性选择器</li><li>标签选择器(div,h1,p)、伪元素选择器（li：after）</li><li>子选择器(ul &lt; li)、相邻兄弟选择器、后代选择器(li a)、通配符选择器</li></ol><p><img src="https://i0.hdslb.com/bfs/article/8893357747d83ffb476629f3bd8e5bd25e202cdd.jpg@942w_423h_progressive.webp" alt="css选择器优先级"></p><p>当两个规则都作用到了同一个html元素上时，如果定义的属性有冲突，那么应该用谁的值的，用到谁的值谁的优先级就高。<br>我们来看一下css选择器优先级的算法：</p><ul><li>每个规则对应一个初始”四位数”：0、0、0、0</li><li>若是 行内选择符，则加1、0、0、0</li><li>若是 ID选择符，则加0、1、0、0</li><li>若是 类选择符&#x2F;伪类选择符，则分别加0、0、1、0</li><li>若是 元素选择符，则分别加0、0、0、1</li></ul><ol><li>!important 声明的样式的优先级最高；</li><li>如果优先级相同，则最后出现的样式生效；</li><li>继承得到的样式的优先级最低；</li><li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li><li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li></ol><h2 id="选择器详解"><a href="#选择器详解" class="headerlink" title="选择器详解"></a>选择器详解</h2><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><ol><li><p>动态伪类选择器</p><ul><li>:link选择地址没有被访问过的超链接元素</li><li>:visited选择地址被访问过的超链接元素</li><li>:hover选择鼠标悬停在上面的元素。</li><li>:active选择鼠标在上面并且按键按下不松手的元素</li><li>:focus选择获取焦点的元素。</li></ul></li><li><p>目标伪类选择器  </p><ul><li>:target选择当前锚点指向的元素。</li></ul></li><li><p>语言伪类选择</p><ul><li>lang()根据语言选择元素（lang 属性的值）</li></ul></li><li><p>UI元素伪类选择器</p><ul><li>:enabled选择可以使用的表单控件（没有设置disabled 属性）</li><li>:disabled选择不可以使用的表单控件（设置了disabled属性）</li><li>:checked选择到被选中的单选按钮、复选框、下拉选项（option）</li></ul></li><li><p>结构伪类选择器</p><ul><li>:root选择到根元素</li><li>:empty选择到既不能有文本内容也没有后代元素的元素</li><li>:first-child所有兄弟元素中的第一个</li><li>:last-child所有兄弟元素中的最后一个</li><li>:nth-child(n)所有兄弟元素中的第n个，n是个数字</li><li>:nth-last-child(n)所有兄弟元素中的倒数第n个，n是个数字</li><li>:only-child没有兄弟元素的元素</li><li>:first-of-type所有兄弟元素中同类型的第一个</li><li>:last-of-type所有兄弟元素中同类型的最后一个</li><li>:nth-of-type(n)所有兄弟元素中同类型的第n个,n是个数字</li><li>:nth-last-of-type(n)所有兄弟元素中同类型的倒数第n个，n是数字</li><li>:only-of-type没有同类型兄弟元素</li></ul></li><li><p>否定伪类选择器</p><ul><li>:not(选择器)  排除满足小括号中选择器的元素</li></ul></li></ol><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><ul><li>::first-letter选择元素中第一字母</li><li>::first-line选择元素中第一行</li><li>::after给元素动态创建最后一个子元素</li><li>::before给元素动态创建第一个子元素</li><li>::placeholder用于设置输入框或文本域中placeholder属性设置的文字的样式</li><li>::selection用于设置被鼠标选中的文字的样式</li></ul><h3 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h3><p>  div span得到的是div下所有的span元素，而div &gt;span (div &amp;gt span)则是取得的div下第一级的span元素，div a span 不会被改变，div span 则会被改变</p><h2 id="transition和animation的区别"><a href="#transition和animation的区别" class="headerlink" title="transition和animation的区别:"></a>transition和animation的区别:</h2><ol><li><p>Transition 强调过渡; Animation 强调流程与控制 。</p></li><li><p>两者的控制粒度不一样</p><ol><li>某种程度上, transition 更加粗一点, 比如过渡的速度进行了封装, 可以控制是匀速改变还是贝塞尔曲线之类的。</li><li>animation 提供的 keyframe 方法, 可以让你手动去指定每个阶段的属性; 此外 animation 还封装了循环次数, 动画延迟等功能, 更加自由和强大。</li></ol></li><li><p>动画状态: </p><ol><li>CSS的 transition 只有两个状态:开始状态 和 结束状态 。</li><li>animation 可能是多个状态, 有帧的概念 。</li></ol></li><li><p>动画触发方式:</p><ol><li>CSS的transition需要借助别的方式来触发, 比如CSS的状态选择器（如:hover）或 借助JavaScript来触发 。</li><li>animation 不但可以使用上面的方式触发, 更重要的是可以自动触发 。</li></ol></li><li><p>动画实现的范围:</p><ol><li>transition 是有一定限制的, 并不是所有 CSS 的属性都具有过渡效果 。</li><li>另外相比而言, CSS 的 animation 要比 transition 强大的多, 几乎所有的 css 属性都可以实现动画效果。</li><li>这也是为什么使用 animation 制作 Web 动画的场景更多 。</li></ol></li><li><p>动画实现方式</p><ol><li>CSS 的 animation 是离不开 @keyframes 的，换句话说，我们需要先使用 @keyframes 来注册一个动画效果，即帧来描述动画效果。当然，只注册也不见得有效果，还是需要使用 animation-name 属性引用 @keyframes 注册好的动画效果。</li></ol></li><li><p>animation 控制动效上要比 transition 强，因为它具备一些控制动效的属性，比如“播放次数”、“播放方向”、“播放状态”等。</p></li></ol><p>“注意”: CSS transform 也是用来制作动效的，这个说法有点偏颇，CSS transform 只不过提供了一些函数，可以做不同的变换，这些函数运用于 CSS 的 transition 或 @keyframes 中能得到一些不同的效果，特别是配上时间，缓动函数之类的，效果会更佳。因此也被识认为是动效中不可或缺。其实在 animation 中，可以发挥你的想象，使用 CSS 中任意属性，实现一些有创意的动效。</p><h3 id="transition和animation的共同点"><a href="#transition和animation的共同点" class="headerlink" title="transition和animation的共同点:"></a>transition和animation的共同点:</h3><ol><li>从整体来看，animation 和 transition 想做的事情都是一样, 通过控制属性变化的过程也, 实现动画; 都是立足于控制本身 dom 的 css 属性变化过程, 来实现动画的视觉效果。而你看 transform 就不同, 本身一个 css 属性 。</li><li>他们都有“持续时间”、“延迟时间” 和“时间缓动函数”等概念，这些都是用来控制动效的效果。</li></ol><h2 id="animation常用属性"><a href="#animation常用属性" class="headerlink" title="animation常用属性"></a>animation常用属性</h2><ol><li><p>animation-name(动画名称)<br>animation-name属性是必须存在的，因为animation-name的值默认是none，没有动画。</p></li><li><p>animation-duration(动画执行一次所需时间)<br>animation-duration属性也是必须存在的，因为animation-duration的值默认是0，没有动画。</p></li><li><p>animation-delay(动画在开始前的延迟时间)<br>animation-delay的值可以是秒（s）或者是毫秒（ms）,默认值是0，没有延迟。</p></li><li><p>animation-timing-function(动画以何种运行轨迹完成一个周期)<br>animation-timing-function的值是贝塞尔曲线，默认值是ease,表示动画以低速开始，然后加速，最后在结束前变慢。 最常用的值有以下几个：</p></li></ol><p>  （1）linear:表示动画从头到尾的速度都是相同的。</p><p>  （2）ease-in:表示动画以低速开始。</p><p>  （3）ease-out:表示动画以低速结束。</p><p>  （4）ease-in-out:表示动画以低速开始和结束。</p><p>  如果没有想用的值，也可以直接使用三次贝塞尔函数，使用网站是<a href="http://cubic-bezier.com,可直接调试出自己想要的值;也可以在浏览器中直接调试,现在浏览器调试工具中都支持贝塞尔函数可视化调试./">http://cubic-bezier.com，可直接调试出自己想要的值；也可以在浏览器中直接调试，现在浏览器调试工具中都支持贝塞尔函数可视化调试。</a></p><ol start="5"><li>animation-iteration-count(动画播放次数)<br>animation-iteration-count属性值有两种：</li></ol><p>  （1）直接写数字，自定义想要播放动画的次数。</p><p>  （2）infinite：设置动画无线循环播放。</p><ol start="6"><li>animation-fill-mode(定义元素动画结束以后或者未开始的元素样式)<br>默认值为none，标示，不会在动画结束或者未开始时给元素 添加样式</li></ol><p>  常用属性值为：</p><p>  （1）forwards:表示动画结束后，元素直接接使用当前样式。</p><p>  （2）backwards:表示在动画延迟时间元素使用关键帧中from的属性值或者to属性值（当animation-direction为reverse或者alternate-reverse时）</p><ol start="7"><li>animation-direction(是否轮流反向播放动画)<br>默认值是normal，动画正常播放。如果动画只播放一次，则该属性无效。</li></ol><p>  常用的属性值为：</p><p>  （1）reverse:表示动画反向播放。</p><p>  （2）alternate:表示动画在奇数次播放时为正向播放，为偶数次播放时为反向播放。</p><p>  （3）alternate-reverse: :表示动画在奇数次播放时为反向播放，为偶数次播放时为正向播放。</p><p>animation属性在书写通常合并在一起，除非需要单独设置的属性值，animation属性的简写形式为：animation:code 2s 2s linear infinite alternate forwards;</p><h3 id="CSS3-animation实现走马灯效果"><a href="#CSS3-animation实现走马灯效果" class="headerlink" title="CSS3-animation实现走马灯效果"></a>CSS3-animation实现走马灯效果</h3><p>动画animation</p><p>1.先定义动画：</p><p>@keyframes 动画名称(</p><p>from{}</p><p>to{}</p><p>)</p><p>或者</p><p>@keyframes 动画名称(</p><p>0%{}</p><p>50%{}</p><p>100%{}</p><p>)</p><p>百分号指的是动画时长的占比。</p><p>2.使用动画</p><p>在需要使用动画的元素中添加  </p><p>animation：动画名称 动画时长 速度曲线 延迟时间 重复次数 动画方向 完毕时状态。  其中前两个动画名称和动画时长是必须的，其余的属性选填，且没有顺序要求</p><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="元素知道宽高"><a href="#元素知道宽高" class="headerlink" title="元素知道宽高"></a>元素知道宽高</h3><ul><li>绝对定位、相对定位、calc计算偏移距离</li><li>绝对定位、相对定位、margin计算偏移距离</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">.outer</span> <span class="token punctuation">&#123;</span>        <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token selector">//calc    .inner</span> <span class="token punctuation">&#123;</span>        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>        <span class="token property">top</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>50% - 50px<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token property">left</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>50% - 50px<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token selector">//margin   .inner</span> <span class="token punctuation">&#123;</span>        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>        <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>        <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>        <span class="token property">margin-left</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span>        <span class="token property">margin-top</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>outer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="元素不知道宽高"><a href="#元素不知道宽高" class="headerlink" title="元素不知道宽高"></a>元素不知道宽高</h3><ul><li>绝对定位、相对定位、calc计算偏移距离</li><li>绝对定位、相对定位、margin计算偏移距离</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">.outer</span> <span class="token punctuation">&#123;</span>        <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token selector">//margin:0    .inner</span> <span class="token punctuation">&#123;</span>        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>        <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token selector">//transform    .inner</span> <span class="token punctuation">&#123;</span>        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>        <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>        <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>        <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>outer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>//flex 布局<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">.outer</span> <span class="token punctuation">&#123;</span>        <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>        <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>        <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">.inner</span> <span class="token punctuation">&#123;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>outer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>//grid布局<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">.outer</span> <span class="token punctuation">&#123;</span>        <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>        <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>        <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>                <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">.inner</span> <span class="token punctuation">&#123;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>outer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>//table布局<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">.outer</span> <span class="token punctuation">&#123;</span>        <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>        <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>        <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>                <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">.inner</span> <span class="token punctuation">&#123;</span>        <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>outer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vertical-align 只对 table-cell起作用，vertical-align 的值是相对于其父元素的，父元素必须是行内元素。<br>对于一行文字来讲，该属性的值是相对于行高（line-height）的。<br>对于 table-cell，该属性的值是相对于表格的行高的。</p><h2 id="行内元素垂直居中、水平居中"><a href="#行内元素垂直居中、水平居中" class="headerlink" title="行内元素垂直居中、水平居中"></a>行内元素垂直居中、水平居中</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ul><li>在行内元素的父元素设置：text-align: center;</li><li>flex布局：在行内元素的父元素设置：display: flex;justify-content: center;</li></ul><h3 id="垂直居中-1"><a href="#垂直居中-1" class="headerlink" title="垂直居中"></a>垂直居中</h3><p><strong>单行文本</strong></p><ul><li>把 line-height 设置为父元素的高度</li><li>flex布局：在行内元素的父元素设置：display: flex;align-items: center;<br><strong>多行文本</strong></li><li>在父元素设置： disaply: table-cell; vertical-align: middle; （多行文本垂直居中也适合单行文本的垂直居中）</li></ul><h2 id="实现单行／多行文本溢出的省略样式"><a href="#实现单行／多行文本溢出的省略样式" class="headerlink" title="实现单行／多行文本溢出的省略样式"></a>实现单行／多行文本溢出的省略样式</h2><h3 id="单行文本溢出省略"><a href="#单行文本溢出省略" class="headerlink" title="单行文本溢出省略"></a>单行文本溢出省略</h3><p>实现方式也很简单，涉及的css属性有：</p><pre class="line-numbers language-none"><code class="language-none">text-overflow：ellipsis;white-space：nowrap;overflow：hidden;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>overflow设为hidden，普通情况用在块级元素的外层隐藏内部溢出元素，或者配合下面两个属性实现文本溢出省略<br>white-space:nowrap，作用是设置文本不换行，是overflow:hidden和text-overflow：ellipsis生效的基础<br>text-overflow属性值有如下：clip：当对象内文本溢出部分裁切掉,ellipsis：当对象内文本溢出时显示省略标记（…）</p><h3 id="多行文本溢出省略"><a href="#多行文本溢出省略" class="headerlink" title="多行文本溢出省略"></a>多行文本溢出省略</h3><p>多行文本溢出的时候，我们可以分为两种情况：基于高度截断、基于行数截断</p><h4 id="基于高度截断"><a href="#基于高度截断" class="headerlink" title="基于高度截断"></a>基于高度截断</h4><ul><li>伪元素 + 定位<br>代码结构如下</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;    .demo &#123;        position: relative;        line-height: 20px;        height: 40px;        overflow: hidden;    &#125;    .demo::after &#123;        content: &quot;...&quot;;        position: absolute;        bottom: 0;        right: 0;        padding: 0 20px 0 10px;    &#125;&lt;&#x2F;style&gt;&lt;body&gt;    &lt;div class&#x3D;&#39;demo&#39;&gt;这是一段很长的文本&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="基于行数截断"><a href="#基于行数截断" class="headerlink" title="基于行数截断"></a>基于行数截断</h4><ul><li>css</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">p</span> <span class="token punctuation">&#123;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>        <span class="token property">border-radius</span><span class="token punctuation">:</span> 1px solid red<span class="token punctuation">;</span>        <span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span> 2<span class="token punctuation">;</span>        //用来限制在一个块元素显示的文本的行数，为了实现该效果，它需要组合其他的WebKit属性）        <span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span>        //将对象作为弹性伸缩盒子模型显示        <span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span> vertical<span class="token punctuation">;</span>        //设置或检索伸缩盒对象的子元素的排列方式        <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>//文本溢出限定的宽度就隐藏内容        <span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>        //多行文本的情况下，用省略号“…”隐藏溢出范围的文本    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>    这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本    这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span> <span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><h3 id="媒体查询作用"><a href="#媒体查询作用" class="headerlink" title="媒体查询作用"></a>媒体查询作用</h3><ul><li>使用 @media查询,可以针对不同的媒体类型定义不同的样式;</li><li>@media 可以针对不同的屏幕尺寸设置不同的样式;</li><li>当重置浏览器大小的过程中,页面也会根据浏览器的宽度和高度重新渲染页面;</li><li>目前针对很多苹果手机、 Android手机 ,平板等设备都用得到多媒体查询。</li></ul><h3 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h3><pre class="line-numbers language-none"><code class="language-none">@media mediatype and|not|only (media feature) &#123;CSS-Code;&#125;&#x2F;&#x2F; 1.用@media开头；&#x2F;&#x2F; 2.mediatype媒体类型；&#x2F;&#x2F; 3.关键字and not only&#x2F;&#x2F; 4.media feature媒体特性，必须有小括号包含<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="mediatype查询类型"><a href="#mediatype查询类型" class="headerlink" title="mediatype查询类型"></a>mediatype查询类型</h3><p>将不同的终端设备分为不同的类型</p><p><img src="https://img-blog.csdnimg.cn/62e73f971dcd40738f521e5ab64c4efd.png#pic_center" alt="mediatype查询类型"></p><h3 id="and-not-only"><a href="#and-not-only" class="headerlink" title="and|not|only"></a>and|not|only</h3><p>关键字将媒体类型或多个特性连接到一起做为媒体查询的条件</p><ul><li>and：可以将多个媒体特性连接到一起，相当”且”于的意思</li><li>not：排除某个媒体类型，相当于”非”的意思，可以省略</li><li>only：指定某个特定的媒体类型，可省略</li></ul><h3 id="media-feature"><a href="#media-feature" class="headerlink" title="media feature"></a>media feature</h3><p><img src="https://img-blog.csdnimg.cn/3ea213eb798242c2b3eb8351696ac21e.png#pic_center" alt="media feature"></p><p><img src="https://img-blog.csdnimg.cn/c897e47cefce4cb0ba1d2b7501097435.png#pic_center" alt="示例"></p><h2 id="rem、em、px、vh、vw-的区别"><a href="#rem、em、px、vh、vw-的区别" class="headerlink" title="rem、em、px、vh、vw 的区别"></a>rem、em、px、vh、vw 的区别</h2><ul><li><p>px相对长度单位。像素px是<strong>相对于显示器屏幕分辨率</strong>而言的。</p></li><li><p>%相对长度单位。相对于自己的父级。</p></li><li><p>em相对长度单位。基准点为<strong>父节点字体</strong>的大小，即相对于当前对象内文本的字体尺寸（继承父节点字体大小）。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸( 16px )。</p></li><li><p>rem相对长度单位。r’是“root”的缩写，相对于<strong>根元素html</strong>的字体大小。</p></li><li><p>vh and vw：<strong>相对于视口的高度和宽度</strong>，而不是父元素的（CSS百分比是相对于包含它的最近的父元素的高度和宽度）。</p></li><li><p>vmin and vmax：取视口高度和宽度两者的最小值或者最大值，以最小或大进行百分比的计算。</p></li><li><p>pt 设备像素（物理像素）</p></li><li><p>dpr  &#x3D; 设备像素 &#x2F; 设备独立像素</p></li><li><p>ppi 每英寸像素，值越大，图像越清晰</p></li></ul><h2 id="canvas与svg的区别"><a href="#canvas与svg的区别" class="headerlink" title="canvas与svg的区别"></a>canvas与svg的区别</h2><h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h3><p>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)。<br>SVG 用来定义用于网络的基于矢量的图形。<br>SVG 使用 XML 格式定义图形。<br>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失。<br>SVG 是万维网联盟的标准。<br>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体。</p><h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p>HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。<br>知道了svg和canvas是什么之后，我们就来比较一下canvas和svg。</p><h3 id="canvas和svg的区别比较"><a href="#canvas和svg的区别比较" class="headerlink" title="canvas和svg的区别比较"></a>canvas和svg的区别比较</h3><p><strong>首先我们从时间上看canvas与svg的区别：</strong><br>canvas是html5提供的新元素<code>&lt;canvas&gt;</code>，而svg存在的历史要比canvas久远，已经有十几年了。<br>svg并不是html5专有的标签，最初svg是用xml技术（超文本扩展语言，可以自定义标签或属性）描述二维图形的语言。</p><p><strong>其次我们从功能上看canvas与svg的区别：</strong><br>SVG 是一种使用 <strong>XML</strong> 描述 2D 图形的语言。<br>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。<br>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>Canvas 通过 <strong>JavaScript</strong> 来绘制 2D 图形。<br>Canvas 是逐像素进行渲染的。<br>在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p><p><strong>最后我们来看canvas与svg技术应用上的比较：</strong></p><ul><li>canvas不依赖分辨率, svg依赖分辨率。。</li><li>canvas支持事件处理器, svg支持。</li><li>canvas最适合带有大型渲染区域的应用程序（比如谷歌地图），svg弱的文本渲染能力。</li><li>canvas复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）。</li><li>canvas不适合游戏应用，svg最适合图像密集型的游戏，其中的许多对象会被频繁重绘。</li></ul><h2 id="继承相关"><a href="#继承相关" class="headerlink" title="继承相关"></a>继承相关</h2><p>css的继承：就是给父级设置一些属性，子级继承了父级的该属性，这就是我们的css中的继承。 官方解<br>释，继承是一种规则，它允许样式不仅应用于特定的html标签元素，而且应用于其后代元素。</p><h3 id="无继承性的属性"><a href="#无继承性的属性" class="headerlink" title="无继承性的属性"></a>无继承性的属性</h3><ol><li>display：规定元素应该生成的框的类型</li><li>文本属性：<br>vertical-align：垂直文本对齐<br>text-decoration：规定添加到文本的装饰<br>text-shadow：文本阴影效果<br>white-space：空白符的处理<br>unicode-bidi：设置文本的方向</li><li>盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、 border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left</li><li>背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment</li><li>定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li><li>生成内容属性：content、counter-reset、counter-increment</li><li>轮廓样式属性：outline-style、outline-width、outline-color、outline</li><li>页面样式属性：size、page-break-before、page-break-after</li><li>声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li></ol><h3 id="有继承性的属性"><a href="#有继承性的属性" class="headerlink" title="有继承性的属性"></a>有继承性的属性</h3><ol><li><p>字体系列属性<br>font：组合字体<br>font-family：规定元素的字体系列<br>font-weight：设置字体的粗细<br>font-size：设置字体的尺寸<br>font-style：定义字体的风格<br>font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写 字体的字母与其余文本相比，其字体尺寸更小。<br>font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。<br>font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。</p></li><li><p>文本系列属性<br>text-indent：文本缩进<br>text-align：文本水平对齐<br>line-height：行高<br>word-spacing：增加或减少单词间的空白（即字间隔）<br>letter-spacing：增加或减少字符间的空白（字符间距）<br>text-transform：控制文本大小写<br>direction：规定文本的书写方向<br>color：文本颜色 a元素除外</p></li><li><p>元素可见性：visibility</p></li><li><p>表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout</p></li><li><p>列表布局属性：list-style-type、list-style-image、list-style-position、list-style</p></li><li><p>生成内容属性：quotes</p></li><li><p>光标属性：cursor</p></li><li><p>页面样式属性：page、page-break-inside、windows、orphans</p></li><li><p>声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、 pitch、pitch-range、stress、richness、、azimuth、elevation</p></li></ol><h3 id="所有元素可以继承的属性"><a href="#所有元素可以继承的属性" class="headerlink" title="所有元素可以继承的属性"></a>所有元素可以继承的属性</h3><ol><li>元素可见性：visibility</li><li>光标属性：cursor</li></ol><h3 id="内联元素可以继承的属性"><a href="#内联元素可以继承的属性" class="headerlink" title="内联元素可以继承的属性"></a>内联元素可以继承的属性</h3><ol><li>字体系列属性</li><li>除text-indent、text-align之外的文本系列属性</li></ol><h3 id="块级元素可以继承的属性"><a href="#块级元素可以继承的属性" class="headerlink" title="块级元素可以继承的属性"></a>块级元素可以继承的属性</h3><ol><li>text-indent、text-align</li></ol><h2 id="css预处理工具"><a href="#css预处理工具" class="headerlink" title="css预处理工具"></a>css预处理工具</h2><p>CSS 预处理器是一个能让你通过预处理器自己独有的语法来生成CSS的程序。<br>css预处理器种类繁多，三种主流css预处理器是Less、Sass（Scss）及Stylus；它们各自的背景如下:<br><strong>Sass：</strong><br>2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS（SCSS 需要使用分号和花括号而不是换行和缩进）。<br><strong>Less：</strong><br>2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS。其缺点是比起SASS来，可编程功能不够。优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。<br><strong>Stylus：</strong><br>2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS。</p><h3 id="less-和scss区别"><a href="#less-和scss区别" class="headerlink" title="less 和scss区别"></a>less 和scss区别</h3><p>相同点：</p><ul><li>LESS和SCSS都是css的预处理器，可以拥有变量，运算，继承，嵌套的功能，使用两者可以使代码更加的便于阅读和维护。</li><li>都可以通过自带的插件，转成相对应的css文件。</li><li>都可以参数混入，可以传递参数的class，就像函数一样</li><li>嵌套的规则相同，都是class嵌套class</li></ul><p>不同点：</p><ul><li>声明和使用变量LESS用@符号，SCSS用$符号表示</li><li>变量插值LESS采用@{XXXX}的形式，SCSS采用${XXXX}的形式</li><li>less不支持条件语句，scss支持条件语句</li><li>引用外部css文件方式不同 scss引用的css文件名必须以‘_’开头（下划线），文件名如果以下划线开头的话，sass会认为改文件是一个应用文件，不会将它转成css文件</li><li>调整色相的函数不一样，LESS使用spin（）的函数；SCSS使用名为adjust_hue()的函数</li><li>LESS和SCSS都可以使用&amp;符号表示父选择器，但是SCSS的&amp;符号只能出现在一个组合选择器的开始位置，LESS则没有这个限制</li></ul><p>总结：<br>SCSS和LESS都是一种基于css之上的高级语言，两者之间各有优点，sass在功能上面比LESS更强大，LESS比较的清晰明了，容易上手，主要是看大家的工作中，更倾向于使用那个进行开发，两者都能够大大提高书写代码的效率</p><h2 id="行内元素和块级元素的区别"><a href="#行内元素和块级元素的区别" class="headerlink" title="行内元素和块级元素的区别"></a>行内元素和块级元素的区别</h2><p><strong>块级元素</strong></p><ol><li>总是从新的一行开始，即各个块级元素独占一行，默认垂直向下排列；</li><li>高度、宽度、margin及padding都是可控的，设置有效，有边距效果；</li><li>宽度没有设置时，默认为100%；</li><li>块级元素中可以包含块级元素和行内元素。</li></ol><p><strong>行内元素</strong></p><ol><li>和其他元素都在一行，即行内元素和其他行内元素都会在一条水平线上排列；</li><li>高度、宽度是不可控的，设置无效，由内容决定。</li><li>根据标签语义化的理念，行内元素最好只包含行内元素，不包含块级元素。<br>转换</li></ol><p>当然块级元素与行内元素之间的特性是可以相互转换的。HTML可以将元素分为行内元素、块状元素和行内块状元素三种。<br>使用display属性能够将三者任意转换：<br>(1)display:inline;转换为行内元素；<br>(2)display:block;转换为块状元素；<br>(3)display:inline-block;转换为行内块状元素。</p><h2 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h2><p><strong>重绘</strong>: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。</p><p><strong>回流</strong>：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。</p><p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p><ul><li>添加或者删除可见的 DOM 元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度</li><li>内容变化，比如用户在 input 框中输入文字</li><li>浏览器窗口尺寸改变——resize事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值</li><li>当你修改网页的默认字体时。</li></ul><h3 id="为什么有时候用translate而不是用绝对定位来改变位置"><a href="#为什么有时候用translate而不是用绝对定位来改变位置" class="headerlink" title="为什么有时候用translate而不是用绝对定位来改变位置"></a>为什么有时候用translate而不是用绝对定位来改变位置</h3><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重排（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重排，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p><h2 id="隐藏一个元素的几种方法"><a href="#隐藏一个元素的几种方法" class="headerlink" title="隐藏一个元素的几种方法"></a>隐藏一个元素的几种方法</h2><ol><li><p>display:none  隐藏后不占据空间 会产生回流和重绘 不会被子元素继承，同时在渲染树中消失，但在dom树依然存在</p></li><li><p>visibility:hidden  隐藏后依旧占据空间 所以只会产生重绘 会被子元素继承，在渲染树、dom树都存在</p></li><li><p>opacity:0 隐藏后依旧占据空间 所以只会产生重绘 会被子元素继承</p></li><li><p>width:0 height:0</p></li></ol><h2 id="一个按钮，一直固定在在窗口的右边"><a href="#一个按钮，一直固定在在窗口的右边" class="headerlink" title="一个按钮，一直固定在在窗口的右边"></a>一个按钮，一直固定在在窗口的右边</h2><ol><li><p>float:left </p></li><li><p>display:flex;justify-content:flex-start</p></li><li><p>position:fixed</p></li></ol><h2 id="使用flex-布局让子元素-左右间距相等"><a href="#使用flex-布局让子元素-左右间距相等" class="headerlink" title="使用flex 布局让子元素 左右间距相等"></a>使用flex 布局让子元素 左右间距相等</h2><ol><li>justify-content: space-evenly;</li><li>justify-content: space-between; 和伪类</li><li>子元素 margin: 0 auto; margin-left: 0; 第一个子元素margin-left: auto;</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>flex center<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">*</span><span class="token punctuation">&#123;</span><span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.divtext</span><span class="token punctuation">&#123;</span><span class="token property">margin</span><span class="token punctuation">:</span> 100px auto -100px<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 40px<span class="token punctuation">;</span><span class="token property">line-height</span><span class="token punctuation">:</span> 40px<span class="token punctuation">;</span><span class="token property">font-weight</span><span class="token punctuation">:</span> 700<span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span> 22px<span class="token punctuation">;</span><span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- space-evenly 使子元素左右间距相等布局--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.div1</span><span class="token punctuation">&#123;</span><span class="token property">width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span><span class="token property">border</span><span class="token punctuation">:</span> 1px solid<span class="token punctuation">;</span><span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token property">justify-content</span><span class="token punctuation">:</span> space-evenly<span class="token punctuation">;</span><span class="token property">margin</span><span class="token punctuation">:</span> 100px auto<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.div1 div</span><span class="token punctuation">&#123;</span><span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token property">border</span><span class="token punctuation">:</span> 1px solid<span class="token punctuation">;</span><span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token property">line-height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>divtext<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>space-evenly 使子元素左右间距相等布局<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>div1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- space-between 和伪类使子元素左右间距相等布局--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.div2</span><span class="token punctuation">&#123;</span><span class="token property">width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span><span class="token property">border</span><span class="token punctuation">:</span> 1px solid<span class="token punctuation">;</span><span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token property">justify-content</span><span class="token punctuation">:</span> space-between<span class="token punctuation">;</span><span class="token property">margin</span><span class="token punctuation">:</span> 100px auto<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.div2::before,.div2::after</span><span class="token punctuation">&#123;</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.div2 div</span><span class="token punctuation">&#123;</span><span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token property">border</span><span class="token punctuation">:</span> 1px solid<span class="token punctuation">;</span><span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token property">line-height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>divtext<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>space-between 和伪类使子元素左右间距相等布局<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>div2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- display:flex和子元素 margin 使子元素左右间距相等布局 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">.div3</span><span class="token punctuation">&#123;</span><span class="token property">width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span><span class="token property">border</span><span class="token punctuation">:</span> 1px solid<span class="token punctuation">;</span><span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token property">margin</span><span class="token punctuation">:</span> 100px auto<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.div3 div</span><span class="token punctuation">&#123;</span><span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token property">border</span><span class="token punctuation">:</span> 1px solid<span class="token punctuation">;</span><span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token property">line-height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span><span class="token property">margin-left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.div3 div:first-child</span><span class="token punctuation">&#123;</span><span class="token property">margin-left</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>divtext<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>display:flex和子元素 margin 使子元素左右间距相等布局<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>div3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>CSS3中的盒模型有以下两种:标准盒模型、IE盒模型<br>盒模型都是由四个部分组成的,分别是margin、border、padding和content<br>标准盒模型和IE盒模型的区别在于设置width和height时, 所对应的范围不同</p><ol><li>标准盒模型的width和height属性的范围只包含了content</li><li>IE盒模型的width和height属性的范围包含了border、padding和content<br>可以通过修改元素的box-sizing属性来改变元素的盒模型；</li><li>box-sizing：content-box表示标准盒模型（默认值）</li><li>box-sizing：border-box表示IE盒模型（怪异盒模型）</li></ol><h2 id="block、inline-block、inline"><a href="#block、inline-block、inline" class="headerlink" title="block、inline-block、inline"></a>block、inline-block、inline</h2><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>块级元素：元素呈现“块”状，有自己的宽度和高度，也就是<strong>可以设置宽(width)和高(height)，除此之外，独自占据一行高度</strong>（float浮动除外），一般可以作为其他容器使用，可容纳块级元素和行内元素。块级元素有以下特点：</p><p>每个块级元素都是独自占一行。<br>元素的高度(height)、宽度(width)、行高(line-height)和边距(margin、padding)都是可以设置的。　　<br>元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%）。<br>常见块级元素：</p><p><code>&lt;body&gt;、&lt;address&gt;、 &lt;caption&gt;、&lt;dd&gt;、&lt;div&gt;、&lt;dl&gt;、&lt;dt&gt;、&lt;fieldset&gt;、&lt;form&gt;、&lt;h1&gt;～&lt;h6&gt;、&lt;hr&gt;、 &lt;legend&gt;、&lt;li&gt;、&lt;noframes&gt;、&lt;noscript&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;p&gt;、&lt;pre&gt;、&lt;table&gt;、&lt;tbody&gt;、&lt;td&gt;、&lt;tfoot&gt;、&lt;th&gt;、&lt;thead&gt;、&lt;tr&gt;</code></p><p>注意：块级元素内能嵌套块级元素、行内元素。但是h1-h6、p、dt这几个块级元素不能嵌套块级元素。</p><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>​行内元素<strong>不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行</strong>,行内元素内一般不可以包含块级元素。行内元素的高度一般由元素内部的字体大小决定，宽度由内容的长度控制。行内元素有以下特点： ​</p><p>每一个行内元素可以和别的行内元素共享一行，相邻的行内元素会排列在同一行里，直到一行排不下了，才会换行。<br>行内元素的高度(height)、宽度(width)、行高(line-height)及内、外边距的底和顶边距(margin-top、padding-top、margin-bottom、padding-bottom)不可设置。<br>元素的宽度就是它包含的文字或图片的宽度，不可改变。</p><h2 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h2><p>行内块级元素，它既具有块级元素的特点，也有行内元素的特点，<strong>它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。</strong>比如input、img就是行内块级元素，它可以设置高宽以及一行多个。具体特点如下：</p><p>和其他行内或行内块级元素元素放置在同一行上；<br>元素的高度、宽度、行高以及顶和底边距都可设置。<br>注意：img和input元素虽然属于行内元素，但是又可以细分为行内替换元素。所以它表现的像行内块级元素一样。</p><h2 id="浮动模型及清除浮动的方法"><a href="#浮动模型及清除浮动的方法" class="headerlink" title="浮动模型及清除浮动的方法"></a>浮动模型及清除浮动的方法</h2><p>浮动元素会脱离文档流并向左&#x2F;向右浮动，直到碰到父元素或者另一个浮动元素。<br>float：none&#x2F;left&#x2F;right<br>浮动会脱离文档流（文字流不会脱离），所以浮动会导致父元素高度坍塌</p><p>如何清除浮动</p><ol><li><p>固定宽高<br>给浮动的元素添加父级div盒子,再给父级盒子设置高度<br>缺点:高度固定死了,无法做到自适应,不宜维护,不灵活<br>应用:万年不变导航栏,固定栏;</p></li><li><p>一起浮动<br>父元素也添加浮动,这样父元素也脱离文档流<br>缺点:这是一种将错就错的办法,后面的DIV盒子依然会塌陷到浮动元素下面</p></li><li><p>额外标签法<br>在浮动的元素最后添加一个空div标签,里面设置style&#x3D;’clear:both’;触发bfc机制<br>优点： 通俗易懂，书写方便<br>缺点： 添加许多无意义的标签，结构化较差<br>注意： 要求这个新的空标签必须是块级元素。</p></li><li><p>父级添加伪元素</p></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 全浏览器通用的clearfix方案</span><span class="token comment">// 引入了zoom以支持IE6/7</span><span class="token punctuation">.</span>clearfix<span class="token operator">:</span>after <span class="token punctuation">&#123;</span>    <span class="token literal-property property">display</span><span class="token operator">:</span> table<span class="token punctuation">;</span>    <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token literal-property property">clear</span><span class="token operator">:</span> both<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span>clearfix<span class="token punctuation">&#123;</span>    <span class="token operator">*</span>zoom<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：没有增加标签，结构更简单<br>代表网站： 百度、淘宝网、网易等</p><ol start="5"><li>父级添加双伪元素</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 全浏览器通用的clearfix方案【推荐】</span><span class="token comment">// 引入了zoom以支持IE6/7</span><span class="token comment">// 同时加入:before以解决现代浏览器上边距折叠的问题</span><span class="token punctuation">.</span>clearfix<span class="token operator">:</span>before<span class="token punctuation">,</span><span class="token punctuation">.</span>clearfix<span class="token operator">:</span>after <span class="token punctuation">&#123;</span>    <span class="token literal-property property">display</span><span class="token operator">:</span> table<span class="token punctuation">;</span>    <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span>clearfix<span class="token operator">:</span>after <span class="token punctuation">&#123;</span>    <span class="token literal-property property">clear</span><span class="token operator">:</span> both<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span>clearfix<span class="token punctuation">&#123;</span>    <span class="token operator">*</span>zoom<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>父盒子添加overflow: hidden;触发BFC</li><li>父盒子添加position:absolute;触发BFC，但同时父盒子也会脱离文档流</li></ol><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC 全称：Block Formatting Context， 名为 “块级格式化上下文”。</p><p>W3C官方解释为：BFC它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，Block Formatting Context提供了一个环境，HTML在这个环境中按照一定的规则进行布局。<br>简单来说就是，BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。</p><p><strong>怎样触发BFC</strong></p><ul><li>overflow: hidden</li><li>display: inline-block</li><li>position: absolute</li><li>position: fixed</li><li>display: table-cell</li><li>display: flex</li></ul><p>BFC就是一个块级元素，块级元素会在垂直方向一个接一个的排列<br>BFC就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签。垂直方向的距离由margin决定， 属于同一个BFC的两个相邻的标签外边距会发生重叠。计算BFC的高度时，浮动元素也参与计算</p><p><strong>BFC解决了什么问题</strong></p><ol><li>使用float脱离文档流，高度塌陷</li><li>margin边距重叠</li><li>两栏布局</li></ol><h2 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h2><p>IFC（Inline Formatting Contexts）直译为”行级格式化上下文”，不受到竖直方向的 padding&#x2F;margin 影响。</p><p><strong>如何触发IFC？</strong><br>块级元素中仅包含内联级别元素<br>形成条件非常简单，需要注意的是当IFC中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个IFC。</p><p><strong>IFC布局规则</strong></p><ul><li>在一个IFC内，子元素是水平方向横向排列的，并且垂直方向起点为元素顶部。</li><li>子元素只会计算横向样式空间，【padding、border、margin】，垂直方向样式空间不会被计算，【padding、border、margin】。</li><li>在垂直方向上，子元素会以不同形式来对齐（vertical-align）</li><li>能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框（line box）。行框的宽度是包含块（containing box）和与其中的浮动来决定。</li><li>IFC中的line box一般左右边贴紧其包含块，但float元素会优先排列。</li><li>IFC中的line box高度由 CSS 行高计算规则来确定，同个IFC下的多个line box高度可能会不同。</li><li>当 inline boxes的总宽度少于包含它们的line box时，其水平渲染规则由 text-align 属性值来决定。</li><li>当一个inline box超过父元素的宽度时，它会被分割成多个boxes，这些boxes分布在多个line box中。如果子元素未设置强制换行的情况下，inline box将不可被分割，将会溢出父元素。</li></ul><p><strong>IFC应用场景</strong></p><ul><li>元素水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。</li><li>多行文本水平垂直居中：创建一个IFC，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li></ul><h2 id="让整个页面变成灰色"><a href="#让整个页面变成灰色" class="headerlink" title="让整个页面变成灰色"></a>让整个页面变成灰色</h2><p>filter: grayscale(100%)  滤镜属性：100%的灰色</p><h2 id="让整个页面禁止点击事件"><a href="#让整个页面禁止点击事件" class="headerlink" title="让整个页面禁止点击事件"></a>让整个页面禁止点击事件</h2><p>pointer-events:none<br>让元素永远无法成为鼠标事件的target，进而禁止鼠标事件即可。</p><h2 id="margin坍塌"><a href="#margin坍塌" class="headerlink" title="margin坍塌"></a>margin坍塌</h2><p><strong>margin塌陷现象：</strong>在垂直方向如果有两个元素的外边距有相遇，在浏览器中加载的真正的外边距不是两个间距的加和，而是两个边距中值比较大的，边距小的塌陷到了边距值大的值内部。</p><ol><li><p>同级元素塌陷：上面的元素有下边距，下面的元素有上边距，两个边距相遇，真正盒子间距离是较大的那个值。<br>盒子box1的下边距依然存在，只是不显示了，由此可见边距小的塌陷到了边距值大的值内部，所以间距为box2的边距100px。</p></li><li><p>父子元素塌陷：父子元素之间也会出现margin塌陷，（1）父元素和子元素都设置了同方向的margin-top值，两个属性之间没有其他内容进行隔离，导致两个属性相遇，发生margin塌陷。（2）本身父元素与上一个元素的距离是0，子元素如果设置了垂直方向的上边距，会带着父级元素一起掉下来（父元素的上边距0塌陷到了子元素的上边距50里面）。</p></li></ol><p><strong>解决方法：</strong></p><ol><li>同级元素：如果两个元素垂直方向有间距，只需要设置给一个元素，不要进行拆分。</li><li>父子元素：让两个边距不要相遇，中间可以使用父元素border或padding将边距分隔开；更加常用的方法，父子盒模型之间的距离就不要用子元素的margin去设置，而是用父元素的padding挤出来。</li></ol><h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>布局实现的目的<br>1.三列布局，两端固定宽度(其实可以不用固定宽度），中间栏自适应。<br>2.中间栏优先渲染。<br>3.任意栏高度自由不限制。</p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><p>三栏全部float:left浮动，区别在于解决中间栏div的内容不被遮挡上，圣杯布局是中间栏在添加相对定位，并配合left和right属性，效果上表现为三栏是单独分开的（如果可以看到空隙的话）</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>header<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>middle<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>column<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>middle<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>column<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>column<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>footer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">body</span><span class="token punctuation">&#123;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>    <span class="token property">padding</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>    <span class="token property">min-width</span><span class="token punctuation">:</span> 550px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#header</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span>100%<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span>darkgrey<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#container</span> <span class="token punctuation">&#123;</span>    <span class="token property">padding-left</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">padding-right</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">//为了让中间的子盒子的内容不被遮挡住，设置了padding-left与padding-rigth，//配合设置左右子盒子的margin-left（左盒子百分比 -100% ）与margin-right（右盒子数值 -150px），//同时还需要设置position: relative与right: -150px#middle</span> <span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#left</span> <span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#right</span> <span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>    <span class="token property">margin-right</span><span class="token punctuation">:</span> -150px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span> -150px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#footer</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span>100%<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span>darkgrey<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.column</span> <span class="token punctuation">&#123;</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><p>双飞翼布局是在中间栏的div中嵌套一个div，内容写在嵌套的div里，然后对嵌套的div设置margin-left和margin-right，效果上表现为左右两栏在中间栏的上面，中间栏还是100%宽度，只不过中间栏的内容通过margin的值显示在中间。大概可以用下面这张图表示：</p><p><img src="https://img-blog.csdnimg.cn/20190307213240959.png" alt="区别"></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>header<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>middle<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>column<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>middle<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>column<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>column<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>footer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">body</span><span class="token punctuation">&#123;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>    <span class="token property">padding</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>    <span class="token property">min-width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#header</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span>100%<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span>darkgrey<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#container</span> <span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#middle</span> <span class="token punctuation">&#123;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">margin-right</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">//为了中间盒子的内容不被遮挡，给中间盒子设置margin-left与margin-right，为左右盒子流出位置#left</span> <span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#right</span> <span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -150px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">#footer</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span>100%<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span>darkgrey<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>    <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.column</span> <span class="token punctuation">&#123;</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="css引入"><a href="#css引入" class="headerlink" title="css引入"></a>css引入</h2><ol><li>行内样式、内联样式 在网页元素上通过style&#x3D;””属性</li><li>内部样式表 在网页创建嵌入的样式表，写在里面</li><li>链入外部样式表 网页引入外部样式表，外部创建一个css文件，在html中通过连接这个css文件，一般写在css前面</li><li>导入外部样式表 通过@import 引入，不建议开发使用</li></ol><p><strong>css引用的优先级</strong><br>记住就近原则<br>内部样式、@import都出现在HTML的里面，就近原则，距离修改元素近的优先级高<br><strong>行内样式&gt;内部样式&gt;link&gt;@import</strong><br>建议开发中链入外部样式，无需改动HTML结构，有利于代码的维护，开发效率高</p><p><strong>link和@import的区别</strong></p><ol><li><p>引入的内容不同<br>link引入样式文件、图片资源等，而@import只引入样式文件</p></li><li><p>加载的顺序不同<br>link在页面加载的同时加载，@import在页面加载以后加载</p></li><li><p>兼容性不同<br>link是XHTML标签，没有兼容性问题，@import在css2.1提出，低版本的浏览器不支持</p></li><li><p>对js的支持不同<br>link支持js控制dom去改变样式，@import则不能支持</p></li></ol><h2 id="img标签alt和title的区别"><a href="#img标签alt和title的区别" class="headerlink" title="img标签alt和title的区别"></a>img标签alt和title的区别</h2><ol><li>title：通常当鼠标滑动到元素上的时候显示</li><li>alt：alt是img标签的特有属性，是图片内容的等价描述，用于图片无法正常加载时显示；搜索引擎可以通过这个属性的文字描述获取图片</li></ol><h2 id="css-z-index优先级"><a href="#css-z-index优先级" class="headerlink" title="css z-index优先级"></a>css z-index优先级</h2><p><a href="https://blog.csdn.net/weixin_42878211/article/details/114934078">z-index优先级</a></p><p>z-index的基础概念<br>x 轴代表水平方向，y 轴代表垂直方向，z 轴则代表我们的目光向页面（屏幕）看进去的时候，各元素的布局情况。</p><p>屏幕是一个二维平面，所以完美实际上是看不到z轴的，z轴实际上是通过透视的形式展示的。也就是说，多个元素共享同一块二维平民啊时，友得元素在顶部，有的元素在底部，因此而感受到z轴的存在。</p><p>css允许我们给z-index设置三种值来决定某个元素在z轴方向上的位置。</p><p>auto（默认值） 堆叠顺序与父元素相等<br>number 元素的堆叠顺序<br>inherit 规定应该从父元素继承z-index属性的值<br>主要来看一下它的number值，number可以为正整数，负整数或者0，值越大的话，元素就会距离我们的眼睛越近，值越小就会距离我们的眼睛越远。</p><p>如果两个元素在定位之后共享同一块二维空间，那么在这块空间中，z-index越大的元素将会覆盖z-index较小的元素。</p><p>层叠顺序<br>我们可以通过一个非常简单的例子来理解层叠顺序，这个例子甚至还不需要涉及到 定位元素 。</p><p>想象一下，现在有一个非常简单的网页，不考虑默认等元素，就只需要考虑每个网页至少都会有的一个 div。在 CSS 文件中设置 html 的背景颜色为蓝色，设置 div 的背景颜色为红色，并设置宽高。</p><p>当加载页面的时候，你觉得会看到什么？</p><p>这个自然不用多想，引入眼帘的肯定是一大片的蓝色，同时还有一个此前设置好尺寸的红色块级元素。除非你做了额外的设置，否则这个元素将正常地出现在左上角。</p><p>为什么红色的块级元素就一定会位于蓝色背景的上层呢？为什么我们看到的就是 div 位于 html 的上层呢？原因是，它们都遵循了层叠顺序的规则。</p><p>在这个简单的例子中，根据规则，正常文档流的子块（div）的层级将会高于根元素（html）的背景和边框。我们看到div 位于顶层，这是因为它的层叠等级更高。</p><p><img src="https://img-blog.csdnimg.cn/20201114203435700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU1NTc3NA==,size_16,color_FFFFFF,t_70#pic_center" alt="层叠上下文"></p><p>虽然上面这个例子只涉及到了两个层叠等级，但实际上，在一个层叠上下文中，一共可能出现七个层叠等级，从最低到最高排列，依次是：</p><ol><li>背景和边框 ：形成层叠上下文的元素的背景和边框，它是整个上下文中层叠等级最低的</li><li>Z-index 为负数 ：设置了 z-index 为负数的子元素以及由它所产生的层叠上下文</li><li>块级盒模型：位于正常文档流中的、块级的、非定位的子元素</li><li>浮动盒模型 ：浮动的、非定位的子元素</li><li>内联盒模型 ：位于正常文档流中的、内联的、非定位的子元素</li><li>Z-index 为 0：设置了 z-index 为 0 与auto 的、定位的子元素以及由它所产生的层叠上下文</li><li>Z-Index 为正数 ：设置了 z-index 为正数的、定位的子元素以及由它所产生的层叠上下文，它是整个上下文中层叠等级最高的</li></ol><h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h2><p><strong>伪元素</strong>本身不存在在DOM文档中，它需要人为的去创建它。且就算你创建了伪元素，它也只是逻辑上存在，实际上也并不存在DOM文档中，也就是说你无法使用JS去获取改变它。</p><p><strong>伪类</strong>它存在于DOM文档中，但如果你没有特别的去声明它，你就看不到它。</p><ol><li>伪元素是创建了一个新元素，而伪类本身就存在只不过不用特别声明</li><li>伪元素使用<code>:</code>或者<code>::</code>声明(前者是css2的声明方式，后者是css3)，而伪类只能使用<code>：</code> (建议在H5中伪元素统一用<code>::</code> 以便区分伪元素和伪类)</li><li>伪元素只能同时使用一个，伪类可以同时使用多个</li></ol><h2 id="使用-CSS-自定义属性（变量）"><a href="#使用-CSS-自定义属性（变量）" class="headerlink" title="使用 CSS 自定义属性（变量）"></a>使用 CSS 自定义属性（变量）</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html</title>
      <link href="/zyhxwing/2022/09/05/html/"/>
      <url>/zyhxwing/2022/09/05/html/</url>
      
        <content type="html"><![CDATA[<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h2 id="h5新特性"><a href="#h5新特性" class="headerlink" title="h5新特性"></a>h5新特性</h2><h3 id="H5新特性："><a href="#H5新特性：" class="headerlink" title="H5新特性："></a>H5新特性：</h3><ol><li>拖拽释放（drag and drop）API</li><li>语义化更好的内容标签（header footer nav aside article section）</li><li>音频. 视频（audio video）API</li><li>画布（Canvas）API</li><li>地理（Geolocation）API</li><li>localstorage 和 sessionstorage 缓存方式</li><li>表单控件（calendar date time email ul search）</li><li>新技术（webworker websocket Geolocation）</li></ol><h3 id="H5移除的元素"><a href="#H5移除的元素" class="headerlink" title="H5移除的元素"></a>H5移除的元素</h3><ol><li>纯表现元素：basefont font big center s tt u strike</li><li>对可用性有负面影响的元素：frame frameset noframes</li></ol><h2 id="script标签中的defer和async的区别"><a href="#script标签中的defer和async的区别" class="headerlink" title="script标签中的defer和async的区别"></a>script标签中的defer和async的区别</h2><ul><li>script ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。</li><li>async script ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。</li><li>defer script：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</li></ul><p><img src="/zyhxwing/../images/html/1399.png" alt="区别"></p><h2 id="html语义化"><a href="#html语义化" class="headerlink" title="html语义化"></a>html语义化</h2><p>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好的解析。<br><strong>为了在没有CSS的情况下，页面也能呈现出很好的内容结构和代码结构。</strong></p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用</li><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息（爬虫依赖于标签来确定上下文和各个关键字饿权重）</li><li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页</li><li>便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化</li></ul><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><ol><li>尽可能少的使用无语义的标签div和span</li><li>在语义不明显时，既可以使用div或者p时，尽量用p，因为p在默认情况下有上下间距，对兼容特殊终端有利</li><li>不要使用纯样式标签，如：b、font、u等，改用CSS设置</li><li>需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用css指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）</li><li>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和单元格要区分开，表头用th，单元格用td</li><li>表单域要用fieldset标签抱起来，并用legend标签说明表单的用途</li><li>每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在label标签中设置for&#x3D;someId来让说明文本和相对应的input关联起来</li></ol><p><strong>常见的语义化标签：</strong>article（定义文章）、aside（定义文章的侧边栏）、figure（一组媒体对象以及文字）、figurecaption（定义figure的标题）、footer（定义页脚）、header（定义页眉）、nav（定义导航栏）、section（定义文档中的区段）、time（定义日期和时间）、dialog（定义一个对话框）</p><h2 id="浏览器渲染页面的一般过程："><a href="#浏览器渲染页面的一般过程：" class="headerlink" title="浏览器渲染页面的一般过程："></a>浏览器渲染页面的一般过程：</h2><ol><li><p>浏览器解析html源码，然后创建一个 DOM树。并行请求 css&#x2F;image&#x2F;js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。</p></li><li><p>浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。</p></li><li><p>DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。</p></li></ol><p>DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。</p><ol start="4"><li>一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。</li></ol><p>以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。</p><h2 id="获取dom元素的方法"><a href="#获取dom元素的方法" class="headerlink" title="获取dom元素的方法"></a>获取dom元素的方法</h2><ol><li>querySelector</li></ol><p><code>document.querySelector(‘选择器’)</code><br>在指定上下文中通过选择器获取第一个元素（只能获取一个），获取不到就是null</p><ol start="2"><li>querySelectorAll</li></ol><p><code>document.querySelectorAll(‘选择器’)</code><br>在指定上下文中通过选择器获取一组元素集合，获取不到就是空元（通过数组方法取元素）</p><ol start="3"><li>getElementById</li></ol><p><code>document.getElementByid(&#39;id名&#39;)</code><br>在document上下文下获取元素(通过Id获取的元素是一个元素对象，获取不到就是null)</p><ol start="4"><li>getElementByTagName</li></ol><p><code>document.getElementByTagName(‘标签名’)</code><br>通过指定的上下文获取指定的标签，获取的是一个元素集合，如果没有获取到元素，那就是空元素集合  (通过数组方法取元素）<br>5. getElementByName</p><p><code>document.getElementByName(‘标签名’)</code><br>在整个文档中，通过标签的NAME属性值获取一组节点集合（在IE中只有表单元素的NAME才能识别，所以我们一般应用于表单元素的处理）<br>6. getElementClassName</p><p><code>document.getElementClassName(‘类名’)</code><br>在整个文档中，通过标签的NAME属性值获取一组节点集合（在IE中只有表单元素的NAME才能识别，所以我们一般应用于表单元素的处理）<br>7. document.body</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> body<span class="token operator">=</span>document<span class="token punctuation">.</span>body<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>body 属性用于设置或返回文档体。<br>如果是返回, 该属性返回当前文档的 body 元素。<br>如果是设置, 该属性会覆盖所有在 body 元素中的子元素, 并用新的内容来替换它<br>8. document.documentElement</p><pre class="line-numbers language-document" data-language="document"><code class="language-document">var html&#x3D;document.documentElement;console.log(html);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>documentElement 属性以一个元素对象返回一个文档的文档元素。<br>HTML 文档返回对象为HTML元素。<br>注意： 如果 HTML 元素缺失，返回值为 null。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/zyhxwing/2022/09/04/vue/"/>
      <url>/zyhxwing/2022/09/04/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><h2 id="MVVM框架与其他框架的区别"><a href="#MVVM框架与其他框架的区别" class="headerlink" title="MVVM框架与其他框架的区别"></a>MVVM框架与其他框架的区别</h2><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><code>MVC</code>是应用最广泛的软件架构之一，一般<code>MVC</code>分为：<br><code>Model（ 模型 ）</code>、<code>Controller（ 控制器 ）</code>、<code>View（ 视图 ）</code>。<br>这主要是基于分层的目的，让彼此的职责分开。<code>View</code>一般通过<code>Controller</code>来和<code>Model</code>进行联系。<code>Controller</code>是<code>Model</code>和<code>View</code>的协调者，<code>View</code>和<code>Model</code>不直接联系。基本联系都是单向的。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png" alt="MVC"></p><ol><li>View 传送指令到 Controller</li><li>Controller 完成业务逻辑后，要求 Model 改变状态</li><li>Model 将新的数据发送到 View，用户得到反馈</li></ol><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p><code>MVP</code> 模式将 <code>Controller</code> 改名为<code>Presenter</code>，同时改变了通信方向。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020109.png" alt="MVP"></p><ol><li>各部分之间的通信，都是双向的。</li><li>View 与 Model 不发生联系，都通过 Presenter 传递。</li><li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li></ol><h3 id="MVVM模式的优点以及与MVC模式的区别"><a href="#MVVM模式的优点以及与MVC模式的区别" class="headerlink" title="MVVM模式的优点以及与MVC模式的区别"></a>MVVM模式的优点以及与MVC模式的区别</h3><p><strong>MVVM模式的优点：</strong></p><ol><li><strong>低耦合：</strong>视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li><li><strong>可重用性：</strong>你可以把一些视图逻辑放在一个ViewModel里面，让很多 view 重用这段视图逻辑。</li><li><strong>独立开发：</strong>开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li><strong>可测试：</strong>界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</li></ol><p><strong>MVVM 和 MVC 的区别：</strong></p><ol><li>MVC 中 Controller演变成 MVVM 中的 ViewModel，</li><li>MVVM 通过数据来显示视图层而不是节点操作。</li><li>MVC中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li></ol><h2 id="Vue响应式数据原理"><a href="#Vue响应式数据原理" class="headerlink" title="Vue响应式数据原理"></a>Vue响应式数据原理</h2><p>首先需要解释的是 什么是响应式：数据发生改变的时候，视图会重新渲染，匹配更新为最新的值。</p><h3 id="Vue2-x响应式数据原理"><a href="#Vue2-x响应式数据原理" class="headerlink" title="Vue2.x响应式数据原理"></a>Vue2.x响应式数据原理</h3><p>Vue2.x采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，在初始化的时候，通过Object.defineProperty 为对象中的每一个属性，设置 get 和 set 方法，每个声明的属性，都会有一个 专属的依赖收集器 subs，当页面使用到 某个属性时，触发 ObjectdefineProperty - get函数，页面的 watcher 就会被 放到 属性的依赖收集器 subs 中，在 数据变化时，通知更新；当数据改变的时候，会触发Object.defineProperty - set函数，数据会遍历自己的依赖收集器 subs，逐个通知 watcher，视图开始更新。</p><p><img src="/zyhxwing/../images/Vue/1371_1.png" alt="Vue2.x响应式数据原理"></p><h3 id="Vue2-x如何监听数组变化"><a href="#Vue2-x如何监听数组变化" class="headerlink" title="Vue2.x如何监听数组变化"></a>Vue2.x如何监听数组变化</h3><p>使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p><h3 id="Vue3-x响应式数据原理"><a href="#Vue3-x响应式数据原理" class="headerlink" title="Vue3.x响应式数据原理"></a>Vue3.x响应式数据原理</h3><p>Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法，包括不限于 apply、ownKeys、deleteProperty、has 等等。并且作为新标准将受到浏览器厂商重点持续的性能优化。</p><p>但是Proxy只会代理对象的第一层，Vue3会判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。</p><p>监测数组的时候可能触发多次get&#x2F;set，那么如何防止触发多次呢？</p><p>我们可以判断当前检测的属性是否为当前被代理对象的自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才会触发。</p><h3 id="Vue3-0-里为什么要用-Proxy-API替代-defineProperty-API？"><a href="#Vue3-0-里为什么要用-Proxy-API替代-defineProperty-API？" class="headerlink" title="Vue3.0 里为什么要用 Proxy API替代 defineProperty API？"></a>Vue3.0 里为什么要用 Proxy API替代 defineProperty API？</h3><p>1.defineProperty API 的局限性最大原因是它只能针对单例属性做监听。<br>Vue2.x中的响应式实现正是基于defineProperty中的descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因。</p><p>2.Proxy API的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><p>3.响应式是惰性的。<br>在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。<br>在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。</p><h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><ul><li>beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的<strong>数据和方法都不能被访问</strong>。</li><li>created在实例创建完成后发生，当前阶段已经完成了数据观测，也就是<strong>可以使用数据，更改数据</strong>，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段<strong>Dom还没有创建</strong>，无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</li><li>beforeMount发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段<strong>虚拟Dom已经创建完成，即将开始渲染</strong>。在此时也可以对数据进行更改，不会触发updated。</li><li>mounted在挂载完成后发生，在当前阶段，<strong>真实的Dom挂载完毕</strong>，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。<br><strong>接口请求一般放在mounted中，但需要注意的是服务端渲染时不支持mounted，需要放到created中。</strong></li><li>beforeUpdate发生在更新之前，也就是<strong>响应式数据发生更新，虚拟dom重新渲染之前被触发</strong>，你可以在当前阶段进行更改数据，不会造成重渲染。</li><li>updated发生在更新完成之后，当前阶段组件<strong>Dom已完成更新</strong>。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</li><li>beforeDestroy发生<strong>在实例销毁之前，在当前阶段实例完全可以被使用</strong>，我们可以在这时进行善后收尾工作，比如清除计时器。</li><li>destroyed发生在<strong>实例销毁之后，这个时候只剩下了dom空壳</strong>。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</li></ul><h3 id="不常用的钩子"><a href="#不常用的钩子" class="headerlink" title="不常用的钩子"></a>不常用的钩子</h3><p>activated</p><ul><li>keep-alive 组件激活时调用，该钩子在服务器端渲染期间不被调用。</li></ul><p>deactivated</p><ul><li>keep-alive 组件停用时调用，该钩子在服务器端渲染期间不被调用。</li></ul><p>errorCaptured</p><ul><li>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播你可以在此钩子中修改组件的状态。因此在模板或渲染函数中设置其它内容的短路条件非常重要，它可以防止当一个错误被捕获时该组件进入一个无限的渲染循环。</li></ul><h3 id="父子组件的生命周期"><a href="#父子组件的生命周期" class="headerlink" title="父子组件的生命周期"></a>父子组件的生命周期</h3><p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</p><p>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p><p>执行的先后顺序为<br>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p><p>父c-&gt;子c-&gt;子m-&gt;父m</p><p>子组件更新过程 父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><p>销毁过程 父beforeDestory-&gt;子beforeDestory-&gt;子destoryed-&gt;父destoryed</p><h2 id="Vue里Computed和Watch的区别"><a href="#Vue里Computed和Watch的区别" class="headerlink" title="Vue里Computed和Watch的区别"></a>Vue里Computed和Watch的区别</h2><p><strong>Computed</strong>本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。</p><p><strong>Watch</strong>没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用unWatch手动注销哦。</p><h2 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h2><p>相同点：<br>v-show和v-if都能控制元素的显示和隐藏。</p><p>不同点：<br>1.实现本质方法不同:v-show本质就是通过设置css中的display设置为none;控制隐藏v-if是动态的向DOM树内添加或者删除DOM元素;<br>2.v-show都会编译，初始值为false，只是将display设为none，但它也编译了;v-if初始值为false，就不会编译了<br>总结：v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，如果要频繁切换某节点时，故v-show性能更好一点。</p><h2 id="为什么要避免v-if和v-for一起使用"><a href="#为什么要避免v-if和v-for一起使用" class="headerlink" title="为什么要避免v-if和v-for一起使用"></a>为什么要避免v-if和v-for一起使用</h2><p>vue2.x版本中，当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级；<br>vue3.x版本中，当 v-if 与 v-for 一起使用时，v-if 具有比 v-for 更高的优先级。<br>官网明确指出：避免 v-if 和 v-for 一起使用，永远不要在一个元素上同时使用 v-if 和 v-for。</p><p>可以先对数据在计算数据中进行过滤，然后再进行遍历渲染；<br>操作和实现起来都没有什么问题，页面也会正常展示。但是会带来不必要的性能消耗；</p><h2 id="组件中的data为什么是一个函数？"><a href="#组件中的data为什么是一个函数？" class="headerlink" title="组件中的data为什么是一个函数？"></a>组件中的data为什么是一个函数？</h2><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。而在Vue中，我们更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当我们每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p><h2 id="v-model的原理"><a href="#v-model的原理" class="headerlink" title="v-model的原理"></a>v-model的原理</h2><p>v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。</p><p>v-model 在内部为不同的输入元素使用不同的property并抛出不同的事件</p><ul><li>text和textarea 元素使用value property 和 input事件 </li><li>checkbox 和radio使用checked property 和 change事件</li><li>select 字段将value 作为prop 并将change 作为事件</li></ul><h2 id="VUE中的事件绑定原理"><a href="#VUE中的事件绑定原理" class="headerlink" title="VUE中的事件绑定原理"></a>VUE中的事件绑定原理</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 原生事件绑定</span><span class="token operator">&lt;</span>div @click<span class="token operator">=</span><span class="token string">"fn()"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token comment">// 组件绑定</span><span class="token operator">&lt;</span>my<span class="token operator">-</span>component @click<span class="token punctuation">.</span>native<span class="token operator">=</span><span class="token string">"fn"</span> @click<span class="token operator">=</span><span class="token string">"fn1"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>my<span class="token operator">-</span> component<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原生事件绑定"><a href="#原生事件绑定" class="headerlink" title="原生事件绑定"></a>原生事件绑定</h3><p>原生事件绑定是通过addEventListener绑定给真实元素的，</p><p>源码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">updateDOMListeners</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">oldVnode</span><span class="token operator">:</span> VNodeWithData<span class="token punctuation">,</span> <span class="token literal-property property">vnode</span><span class="token operator">:</span> VNodeWithData</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>on<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isUndef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>on<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token punctuation">&#125;</span><span class="token keyword">const</span> on <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>on <span class="token operator">||</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">const</span> oldOn <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>on <span class="token operator">||</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> target <span class="token operator">=</span> vnode<span class="token punctuation">.</span>elm <span class="token function">normalizeEvents</span><span class="token punctuation">(</span>on<span class="token punctuation">)</span> <span class="token function">updateListeners</span><span class="token punctuation">(</span>on<span class="token punctuation">,</span> oldOn<span class="token punctuation">,</span> add<span class="token punctuation">,</span> remove<span class="token punctuation">,</span> createOnceHandler<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>context<span class="token punctuation">)</span> target <span class="token operator">=</span> <span class="token keyword">undefined</span> <span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">add</span> <span class="token punctuation">(</span> <span class="token parameter"><span class="token literal-property property">name</span><span class="token operator">:</span> string<span class="token punctuation">,</span> <span class="token literal-property property">handler</span><span class="token operator">:</span> Function<span class="token punctuation">,</span> <span class="token literal-property property">capture</span><span class="token operator">:</span> boolean<span class="token punctuation">,</span> <span class="token literal-property property">passive</span><span class="token operator">:</span> boolean</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>target<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span> <span class="token comment">// 给当前的dom添加事件 </span>name<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> supportsPassive <span class="token operator">?</span> <span class="token punctuation">&#123;</span>  capture<span class="token punctuation">,</span> passive  <span class="token punctuation">&#125;</span> <span class="token operator">:</span> capture <span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="组件的事件绑定"><a href="#组件的事件绑定" class="headerlink" title="组件的事件绑定"></a>组件的事件绑定</h3><p>组件事件绑定是通过Vue自定义的$on实现的，（可用event触发）。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">updateComponentListeners</span> <span class="token punctuation">(</span> <span class="token parameter"><span class="token literal-property property">vm</span><span class="token operator">:</span> Component<span class="token punctuation">,</span> <span class="token literal-property property">listeners</span><span class="token operator">:</span> Object<span class="token punctuation">,</span> <span class="token literal-property property">oldListeners</span><span class="token operator">:</span> <span class="token operator">?</span>Object</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>target <span class="token operator">=</span> vm <span class="token function">updateListeners</span><span class="token punctuation">(</span>listeners<span class="token punctuation">,</span> oldListeners <span class="token operator">||</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> add<span class="token punctuation">,</span> remove<span class="token punctuation">,</span>createOnceHandler<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>target <span class="token operator">=</span> <span class="token keyword">undefined</span> <span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">add</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> target<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Vue模版编译原理"><a href="#Vue模版编译原理" class="headerlink" title="Vue模版编译原理"></a>Vue模版编译原理</h2><p>Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段：<br>首先解析模版，<strong>生成AST语法树</strong>(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。</p><p><strong>优化</strong>过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p><p>编译的最后一步是将优化后的AST树<strong>转换为可执行的代码</strong>。</p><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>虚拟DOM（Virtual Dom）即虚拟节点。虚拟DOM在Vue.js里做了两件事：</p><ul><li>创建JS对象（虚拟节点），用来模拟真实DOM节点，该对象包含了真实DOM的结构及其属性</li><li>将虚拟节点与旧虚拟节点进行对比，然后更新视图（渲染）</li></ul><h3 id="操作真实-DOM-的代价"><a href="#操作真实-DOM-的代价" class="headerlink" title="操作真实 DOM 的代价"></a>操作真实 DOM 的代价</h3><p>原生 JS 或 JQuery 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍渲染流程。</p><p>比如：在一次操作中，我要更新 10 个 DOM 节点，浏览器收到第一个 DOM 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次。第一次计算完时，紧接着下一个 DOM 更新请求，这个节点的坐标值就变了，前一次计算为无用功。</p><p>计算 DOM 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 DOM 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验。</p><p>真实的DOM节点，哪怕一个最简单的div也包含着很多属性。</p><h3 id="虚拟-DOM-的好处"><a href="#虚拟-DOM-的好处" class="headerlink" title="虚拟 DOM 的好处"></a>虚拟 DOM 的好处</h3><p>虚拟DOM就是为了解决直接操作DOM导致的性能问题而被设计出来的。</p><p>使用了虚拟DOM之后，假如一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无用的计算量。</p><p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个内存。既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个虚拟DOM。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。</p><p>Virtual DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。</p><h3 id="虚拟-DOM作用总结"><a href="#虚拟-DOM作用总结" class="headerlink" title="虚拟 DOM作用总结"></a>虚拟 DOM作用总结</h3><ul><li>提升渲染性能<br>操作 DOM 会导致渲染很慢（每次操作DOM都会触发回流和重绘）。<br>操作虚拟DOM实际是操作JS对象，可以将多次操作整合后再统一操作DOM。操作虚拟DOM时不会引起回流和重绘（即：不会引起渲染）</li><li>具备跨平台的优势<br>Virtual DOM 基于JavaScript 对象而不依赖真实平台环境，所以它有跨平台的能力，比如：浏览器平台、Weex、Node 等。</li><li>提高开发速度<br>无需手动操作DOM：只需要写好View-Model的代码逻辑，框架会根据虚拟DOM和数据双向绑定，帮我们更新视图；</li></ul><h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>简单来说，diff算法有以下过程</p><ul><li>同级比较，再比较子节点</li><li>先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li><li>比较都有子节点的情况(核心diff)</li><li>递归比较子节点</li></ul><p>正常Diff两个树的时间复杂度是O(n^3)，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -&gt; O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p><h3 id="Vue2的核心Diff算法"><a href="#Vue2的核心Diff算法" class="headerlink" title="Vue2的核心Diff算法"></a>Vue2的核心Diff算法</h3><p>Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作，直到某一个列表的节点全部遍历过，对比停止。但这比较的过程是全量diff，也就是每个节点都会彼此比较。当数据发生变化，它就会新生成一个DOM树，并和之前的DOM树进行比较，找到不同的节点然后更新。但其中很显然的是，有些节点中的内容是不会发生改变的，那我们对其进行比较就肯定消耗了时间。</p><h3 id="Vue3的核心Diff算法"><a href="#Vue3的核心Diff算法" class="headerlink" title="Vue3的核心Diff算法"></a>Vue3的核心Diff算法</h3><p>Vue3.x的核心Diff算法采用了静态标记 + 非全量 Diff的方法，在创建虚拟DOM树的时候，会根据DOM中的内容会不会发生变化，添加一个静态标记。那么之后在与上次虚拟节点进行对比的时候，就只会对比这些带有静态标记的节点。同时使用最长递增子序列优化对比流程，可以最大程度的减少 DOM 的移动，达到最少的 DOM 操作</p><p><img src="/zyhxwing/../images/Vue/1373_0.png" alt="Vue3的Diff算法"></p><p>基于最长递增子序列进行移动&#x2F;添加&#x2F;删除</p><h3 id="虚拟DOM中key的作用"><a href="#虚拟DOM中key的作用" class="headerlink" title="虚拟DOM中key的作用"></a>虚拟DOM中key的作用</h3><p>简单的说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用。<br><strong>「key的作用是尽可能的复用 DOM 元素」</strong><br>复杂的说：当状态中的数据发生了变化时，vue根据【新数据】生成【新的虚拟DOM】，随后vue进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：</p><p>旧虚拟DOM中找到了与新虚拟DOM相同的key<br>1.若虚拟DOM中的内容没有变，直接使用之前的真实DOM<br>2.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM</p><p>旧虚拟DOM中未找到与新虚拟DOM相同的key<br>1.根据数据创建新的真实DOM，随后渲染到页面</p><h3 id="用index作为key可能会引发的问题"><a href="#用index作为key可能会引发的问题" class="headerlink" title="用index作为key可能会引发的问题"></a>用index作为key可能会引发的问题</h3><p>若对数据进行：逆序添加&#x2F;逆序删除等破坏顺序的操作，会产生没有必要的真实DOM更新，界面效果虽然没有问题，但是数据过多的话，会效率过低；<br>如果结构中还包含输入类的DOM，会产生错误DOM更新，界面有问题；<br>注意！如果不存在对数据的逆序操作，仅用于渲染表用于展示，使用index作为key是没有问题的。</p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。<br>常用的两个属性include&#x2F;exclude，允许组件有条件的进行缓存。<br>两个生命周期activated&#x2F;deactivated，用来得知当前组件是否处于活跃状态。<br>keep-alive的中还运用了LRU(Least Recently Used)算法。</p><h2 id="Vue组件通信方式"><a href="#Vue组件通信方式" class="headerlink" title="Vue组件通信方式"></a>Vue组件通信方式</h2><p>父子组件通信<br>父-&gt;子props，<br>子-&gt;父 $on、$emit<br>获取父子组件实例 $parent、$children<br>Ref 获取实例的方式调用组件的属性或者方法<br>Provide、inject 官方不推荐使用，但是写组件库时很常用</p><p>兄弟组件通信<br>Event Bus 实现跨组件通信 Vue.prototype.$bus &#x3D; new Vue<br>Vuex</p><p>跨级组件通信<br>Vuex<br>localstorage、sessionstorage<br>$attrs、$listeners<br>Provide、inject</p><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="7种路由的钩子函数"><a href="#7种路由的钩子函数" class="headerlink" title="7种路由的钩子函数"></a>7种路由的钩子函数</h3><ul><li>全局前置&#x2F;钩子：beforeEach、beforeResolve、afterEach</li><li>路由独享的守卫：beforeEnter</li><li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。</li></ul><h3 id="active-class与exact-active-class"><a href="#active-class与exact-active-class" class="headerlink" title="active-class与exact-active-class"></a>active-class与exact-active-class</h3><ul><li>active-class<br>active-class 是 vue-router 模块的 router-link 组件的属性，当 router-link 标签被点击时将会应用这个样式。</li></ul><p>有两种使用方式：</p><p>直接在路由 Router 构造函数中配置 linkActiveClass 属性<br>export default new Router({<br>  linkActiveClass: ‘active’,<br>})<br>使用这种方式，会在每个 router-link 标签上引用这个样式(当被点击后)，如果您只想在某部分 router-link 上使用，则可以选择第二种。</p><p>单独在 router-link 标签上使用 active-class 属性<br><code>&lt;router-link to=&quot;/about&quot; active-class=&quot;active&quot;&gt;about&lt;/router-link&gt;</code><br>最后，为您选中的链接设置样式：</p><ul><li>exact-active-class<br>配置当链接<strong>被精确匹配</strong>的时候应该激活的 class。可以通过以下代码来替代。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>p<span class="token operator">></span>   <span class="token operator">&lt;</span>router<span class="token operator">-</span>link v<span class="token operator">-</span>bind<span class="token operator">:</span>to <span class="token operator">=</span> <span class="token string">"&#123; path: '/route1'&#125;"</span> exact<span class="token operator">-</span>active<span class="token operator">-</span><span class="token keyword">class</span> <span class="token operator">=</span> <span class="token string">"_active"</span><span class="token operator">></span>Router Link <span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">></span>   <span class="token operator">&lt;</span>router<span class="token operator">-</span>link v<span class="token operator">-</span>bind<span class="token operator">:</span>to <span class="token operator">=</span> <span class="token string">"&#123; path: '/route2'&#125;"</span> tag <span class="token operator">=</span> <span class="token string">"span"</span><span class="token operator">></span>Router Link <span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>router-link 默认情况下的路由是模糊匹配，例如当前路径是 &#x2F;article&#x2F;1 那么也会激活 ，所以当设置 exact-active-class 以后，这个 router-link 只有在当前路由被全包含匹配时才会被激活 exact-active-class 中的 class</li></ul><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>路由懒加载的主要原理就是原本的Vue模块是全部导入在一起的打包文件，运行后用户查看相关模块显示的内容时<br>会将整个打包的文件引入而后在其中查找对应的模块然后才将其呈现给用户。这样会使得在打包文件中查找对应模块时<br>在浏览器中可能会出现短暂的空白页，从而降低用户体验。<br>而路由懒加载是将各个模块分开打包，在用户查看下相关模块内容时就直接引入相关模块的打包文件然后进行显示，从而有效的解决了浏览器可能出现短暂时间空白页的情况。</p><p>原先的加载方式是先加载子组件，然后将子组件命名为Home，最后再将Home赋给Vue的component。这样就导致子组件的提前加载。 接下来，实现子组件懒加载，则通过将子组件加载语句封装到一个function中，将function赋给component，这种实现了路由懒加载</p><h3 id="路由跳转传值"><a href="#路由跳转传值" class="headerlink" title="路由跳转传值"></a>路由跳转传值</h3><p> 1.query  跳转路由可以用name和path来指定路径 ，不需要配置 ， 地址栏显示参数 <br> 2.params 跳转路由只能用name，需要提前配置动态路由 ：ids ，地址栏不显示参数</p><h3 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和 $router 的区别"></a>$route 和 $router 的区别</h3><p> <code>$router</code>为VueRouter实例，想要导航到不同URL，则使用<code>$router.push</code>方法<br> <code>$route</code>为当前router跳转对象，里面可以获取name、path、query、params等</p><h3 id="vue中的路由模式-hash和history"><a href="#vue中的路由模式-hash和history" class="headerlink" title="vue中的路由模式 hash和history"></a>vue中的路由模式 hash和history</h3><p>1.hash带#，history没有，更美观点<br>2.history相对比较新，只能兼容ie10，hash能兼容ie8<br>3.两个原理差不多都是通过事件监听，一个是onhashchange（）查找对应的路由规则，另一个onpopstate（）监听URL变化<br>4.hash值在改变的时候，会增加访问历史的记录，可以通过浏览器的操作控制hash的切换；而history里面的pushState（）和replaceState（）会直接替换历史记录，此时需要开发者手动触发页面跳转<br>5.通过URL向后端发起HTTP请求时<br>        1：hash 模式下，仅hash符号之前的内容会被包含在请求中，如 <a href="http://www.abc.com/">http://www.abc.com</a> , 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误。<br>        2：history模式下，前端的URL必须和实际向后端发起请求的URL一致。如htttp:&#x2F;&#x2F;<a href="http://www.abc.com/book/id">www.abc.com/book/id</a> 。如果后端缺少对&#x2F;book&#x2F;id 的路由处理，将返回404错误</p><h2 id="vue自定义指令"><a href="#vue自定义指令" class="headerlink" title="vue自定义指令"></a>vue自定义指令</h2><p>Vue除了核心功能默认内置的指令 ，Vue 也允许注册自定义指令。<br>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</p><p><a href="https://blog.csdn.net/qq_44182284/article/details/111309028">添加自定义指令的两种方式</a></p><p>全局指令： 通过 Vue.directive() 函数注册一个全局的指令。<br>局部指令：通过组件的 directives 属性，对该组件添加一个局部的指令。</p><h2 id="Vue-set-改变数组和对象中的属性"><a href="#Vue-set-改变数组和对象中的属性" class="headerlink" title="Vue.set 改变数组和对象中的属性"></a>Vue.set 改变数组和对象中的属性</h2><p>在一个组件实例中，只有在data里初始化的数据才是响应的，Vue不能检测到对象属性的添加或删除，没有在data里声明的属性不是响应的,所以数据改变了但是不会在页面渲染；<br>解决办法：<br>使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上</p><p>vm.$set(obj, key, val) 做了什么？<br>由于 Vue 无法探测对象新增属性或者通过索引为数组新增一个元素，所以这才有了vm.set，它是Vue.set的别名。vm.set 用于向响应式对象添加一个新的 property，并确保这个新的 property 同样是响应式的，并触发视图更新。</p><p>为对象添加一个新的响应式数据：调用 defineReactive 方法为对象增加响应式数据，然后执行 dep.notify 进行依赖通知，更新视图<br>为数组添加一个新的响应式数据：通过 splice 方法实现</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex是实现组件全局状态（数据）管理的一种机制，可以方便实现组件数据之间的共享；Vuex集中管理共享的数据，易于开发和后期维护；能够高效的实现组件之间的数据共享，提高开发效率；存储在Vuex的数据是响应式的，能够实时保持页面和数据的同步；<br>Vuex重要核心属性包括：state,mutations,action,getters,modules.</p><ul><li><p>state<br>Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</p></li><li><p>mutations<br>mutations定义的方法动态修改Vuex 的 store 中的状态或数据。</p></li><li><p>action<br>actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。</p></li><li><p>getters<br>类似vue的计算属性，主要用来过滤一些数据。</p></li><li><p>modules<br>项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。</p></li></ul><h3 id="Vux刷新会消失吗"><a href="#Vux刷新会消失吗" class="headerlink" title="Vux刷新会消失吗"></a>Vux刷新会消失吗</h3><p><strong>会。</strong>vue项目中使用vuex仓储管理保存一些信息的时候，当刷新页面，这些保存在store中的信息就会丢失。</p><p>因为js被加载后是在内存中执行的，js被加载后，其实就是将js代码执行了一遍，在内存中创建了所有js文件中的变量。当需要执行某个方法时其实是在内存中执行该函数。</p><p>当页面进行刷新的时候，之前创建的所有变量内存都会被释放，重新加载js代码，变量重新赋值。所以有些通过用户操作后保存在vuex中的信息就会丢失。</p><ol><li><p>可以采用其他的存储方法，例如：sessionStorage、localStorage、cookies等。</p></li><li><p>也可以采用vuex和sessionStorage 结合的方式</p></li></ol><pre class="line-numbers language-none"><code class="language-none">const state &#x3D; &#123;  token:sessionStorage.getItem(&#96;token&#96;)||&#96;&#96;,&#125;; const mutations &#x3D; &#123;  &#x2F;&#x2F;保存token  setToken(state,token)&#123;    sessionStorage.setItem(&#96;token&#96;,token)    state.token&#x3D;token;  &#125;, &#125; const actions &#x3D; &#123;  updateToken(context,value)&#123;    context.commit(&#39;setToken&#39;,value)  &#125;,&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="为什么 Vuex 的 mutation 中不能做异步操作？"></a>为什么 Vuex 的 mutation 中不能做异步操作？</h3><p>1、Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。<br>2、每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p><h2 id="Vue前端权限管理"><a href="#Vue前端权限管理" class="headerlink" title="Vue前端权限管理"></a>Vue前端权限管理</h2><p> <a href="https://cloud.tencent.com/developer/article/1794300">前端权限管理</a></p><p>vue前端登录流程</p><ol><li>用户输入账号密码进行登录，登录完拿到token，将token存到cookie和localstorage，之后每次往后端发送请求都通过axios请求拦截器进行拦截，每次请求的时候头部携带token</li><li>在页面初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制。</li><li>在用户登录完之后，在beforeeach 路由钩子函数中设置，每次进行跳转时都先判断缓存内是否有用户的路由表信息，以及跳转的路由是否存在在用户的路由表信息中</li><li>如果没有的话，需要先去获取用户的权限信息，然后筛选有权限访问的路由，最后根据roles权限利用addRoutes方法动态添加该用户可访问的路由表</li></ol><h2 id="Vue3与Vue2的区别"><a href="#Vue3与Vue2的区别" class="headerlink" title="Vue3与Vue2的区别"></a>Vue3与Vue2的区别</h2><p> <a href="https://cloud.tencent.com/developer/article/1794328">区别</a></p><h2 id="Vue前端登录流程"><a href="#Vue前端登录流程" class="headerlink" title="Vue前端登录流程"></a>Vue前端登录流程</h2><p>初次登录的时候，前端调后调的登录接口，发送用户名和密码，后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token，和一个用户信息的值，前端拿到token，将token储存到Vuex中，然后从Vuex中把token的值存入浏览器Cookies中。把用户信息存到Vuex然后再存储到LocalStroage中,然后跳转到下一个页面，根据后端接口的要求，只要不登录就不能访问的页面需要在前端每次跳转页面师判断Cookies中是否有token，没有就跳转到登录页，有就跳转到相应的页面，我们应该再每次发送post&#x2F;get请求的时候应该加入token，常用方法再项目utils&#x2F;service.js中添加全局拦截器，将token的值放入请求头中 后端判断请求头中有无token，有token，就拿到token并验证token是否过期，在这里过期会返回无效的token然后有个跳回登录页面重新登录并且清除本地用户的信息</p><h2 id="搭建一个vue项目"><a href="#搭建一个vue项目" class="headerlink" title="搭建一个vue项目"></a>搭建一个vue项目</h2><ol><li>环境准备nodejs</li><li>全局安装vue-cli脚手架</li><li>用cmd命令创建项目，包括创建文件、选择配置信息、版本</li><li>npm run serve运行项目</li><li>点击项目运行网址就启动了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端安全、网络传输、浏览器相关</title>
      <link href="/zyhxwing/2022/09/04/browser/"/>
      <url>/zyhxwing/2022/09/04/browser/</url>
      
        <content type="html"><![CDATA[<h1 id="前端安全、网络传输、浏览器相关"><a href="#前端安全、网络传输、浏览器相关" class="headerlink" title="前端安全、网络传输、浏览器相关"></a>前端安全、网络传输、浏览器相关</h1><h2 id="vue实现seo"><a href="#vue实现seo" class="headerlink" title="vue实现seo"></a>vue实现seo</h2><p>vue默认是单页面（spa），npm run build打包后，只会生成一个index.html文件。默认是先有dom结构（dom里面是没有数据内容的），再加载数据；所以搜索引擎抓取dom结构，而里面没有数据内容，就无法抓取内容、关键词等就会直接返回，所以seo不友好</p><h3 id="预渲染prerender-spa-plugin"><a href="#预渲染prerender-spa-plugin" class="headerlink" title="预渲染prerender-spa-plugin"></a>预渲染prerender-spa-plugin</h3><p>指的是在页面dom加载前，先调用接口渲染页面</p><p>优点：设置预渲染更简单，改动小，并可以将你的前端作为一个完全静态的站点。<br>缺点：没有动态路由，比如商品详情、文章详情页，一般是动态设置后面的id。但是预渲染不能使用动态路由，只适用少量页面的项目</p><h3 id="服务端渲染ssr"><a href="#服务端渲染ssr" class="headerlink" title="服务端渲染ssr"></a>服务端渲染ssr</h3><p>将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。<br>服务端渲染：nuxt.js<br>优势：可以完美解决seo各种问题（解决了预渲染不支持动态路由，title闪烁），同时seo可直接查看完全渲染的页面，同时客户端体验更好<br>缺点：服务器压力大</p><p>如何实现：</p><ul><li>一套代码两套执行环境，服务端没有window、document对象，需要就加判断</li><li>使用npm包，带有dom才做的，不能用import的方式，改用require方式</li><li>nuxt asyncData方式，并发加载多个接口来获取数据。在初始化页面前先得到数据，但仅限于页面组件调用</li><li>服务器端渲染只支持beforeCreate和created两个钩子，</li><li>部分v-if要改成v-show</li></ul><h3 id="nuxt静态应用部署"><a href="#nuxt静态应用部署" class="headerlink" title="nuxt静态应用部署"></a>nuxt静态应用部署</h3><p>Nuxt.js 可依据路由配置将应用静态化，使得我们可以将应用部署至任何一个静态站点主机服务商。</p><p>优势：纯静态文件，访问速度超快； 对比SSR，不涉及到服务器负载方面问题； 静态网页不宜遭到黑客攻击，安全性更高。</p><p>不足：<br>如果动态路由参数多的话不适用。如果你的动态路由的参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有id，然后打包时遍历id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。</p><h2 id="前端跨域html"><a href="#前端跨域html" class="headerlink" title="前端跨域html"></a>前端跨域html</h2><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+<br>端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p><img src="/zyhxwing/../images/browser/1343_1.png" alt="浏览器同源协议"></p><p>同源策略限制内容有：</p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX 请求发送后，结果被浏览器拦截了</li></ul><p>但是有三个标签是允许跨域加载资源：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">'xxx'</span><span class="token operator">></span><span class="token operator">&lt;</span>link href<span class="token operator">=</span><span class="token string">'xxx'</span><span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">'xxx'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</p><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><ol><li>JSONP原理<ol><li>利用script标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定 需要对方的服务器做支持才可以。</li></ol></li><li>JSONP优缺点<ol><li>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</li><li>缺点是仅支持get方法具有局限性, 不安全可能会遭受XSS攻击。</li></ol></li><li>JSONP的实现流程<ol><li>声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目 标数据(服务器返回的data)。</li><li>创建一个标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback&#x3D;show）。</li><li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是show(‘我不爱你’)。</li><li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li></ol></li></ol><h3 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h3><p>cors 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。</p><p>首先浏览器会判断该请求是简单请求还是非简单请求</p><ul><li><p>简单请求则会自动在请求头上加上origin（值为请求地址，浏览器url），后端再收到请求后打开cors接口，设置accsee-control-allow-orgin，值为origin</p></li><li><p>非简单请求则会先进性一次预检option请求，预检请求会询问服务器是否支持当前域名的请求，是否支持修改的头信息字段，收到肯定的回复之后，才会发送http请求</p></li><li><p>对于需要携带cookie的cors请求<br>则需要后端设置access-control-allow-credential为true，前端设置xhr.withcredential为true。当携带cookie的时候，orgin不能设置为*</p></li></ul><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p>websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。<br>WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>需要你搭建一个中转nginx服务器，用于转发请求。使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。<br>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>反向代理是工作中最常用的服务器功能，经常被用来解决跨域问题，下面我们来简单介绍一下如何实现反向代理。</p><p>首先进入 Nginx 的主配置文件：vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><p>然后我们去 http 模块的 server 块中的 location &#x2F;，增加一行将默认网址重定向到最大学习网站 Bilibili 的 proxy_pass 配置：</p><p><img src="http://ypimg.muzhuangnet.com/Collect/nginx/upload/image/725/644/355/1592555055376693.png" alt="4f1f3ca89b3bd13e948d7a06b3d3ec7.png"></p><p>改完保存退出，<code>nginx -s reload</code> 重新加载，进入默认网址，那么现在就直接跳转到 B 站了，实现了一个简单的代理。</p><p>实际使用中，可以将请求转发到本机另一个服务器上，也可以根据访问的路径跳转到不同端口的服务中。</p><p>比如我们监听 9001 端口，然后把访问不同路径的请求进行反向代理：<br>把访问 <a href="http://127.0.0.1:9001/edu">http://127.0.0.1:9001/edu</a> 的请求转发到 <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a><br>把访问 <a href="http://127.0.0.1:9001/vod">http://127.0.0.1:9001/vod</a> 的请求转发到 <a href="http://127.0.0.1:8081/">http://127.0.0.1:8081</a><br>这种要怎么配置呢，首先同样打开主配置文件，然后在 http 模块下增加一个 server 块：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">server <span class="token punctuation">&#123;</span>  listen <span class="token number">9001</span><span class="token punctuation">;</span>  server_name <span class="token operator">*</span><span class="token punctuation">.</span>sherlocked93<span class="token punctuation">.</span>club<span class="token punctuation">;</span>  location <span class="token operator">~</span> <span class="token operator">/</span>edu<span class="token operator">/</span> <span class="token punctuation">&#123;</span>    proxy_pass http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">8080</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  location <span class="token operator">~</span> <span class="token operator">/</span>vod<span class="token operator">/</span> <span class="token punctuation">&#123;</span>    proxy_pass http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">8081</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反向代理还有一些其他的指令，可以了解一下：</p><ol><li>proxy_set_header：在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。</li><li>proxy_connect_timeout：配置Nginx与后端代理服务器尝试建立连接的超时时间。</li><li>proxy_read_timeout：配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。</li><li>proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。</li><li>proxy_redirect：用于修改后端服务器返回的响应头中的Location和Refresh。</li></ol><h3 id="postmessage"><a href="#postmessage" class="headerlink" title="postmessage"></a>postmessage</h3><p>iframe 和 父窗口 跨域（一般是调用别人的HTML ）必须使用安全的 postMessage方式来进行通信</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 向父窗口传值</span>window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">code</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token string">'向父窗口传值'</span><span class="token punctuation">&#125;</span>，<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 向iframe传值</span>document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"iframe"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">code</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token string">'向iframe传值'</span><span class="token punctuation">&#125;</span>，<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 接收传值</span>window<span class="token punctuation">.</span><span class="token function">addEventList</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>data type e<span class="token punctuation">.</span>data <span class="token operator">===</span><span class="token string">'string'</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>event.source：发送消息的窗口，可以通过区分网址来接收消息<br>event.origin: 消息发向的网址，同上<br>event.data: 消息内容</p><h2 id="前后端实时通信方法"><a href="#前后端实时通信方法" class="headerlink" title="前后端实时通信方法"></a>前后端实时通信方法</h2><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>优点：WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，可从HTTP升级而来，浏览器和服务器只需要一次握手，就可以进行持续的，双向的数据传输，因此能显著节约资源和带宽</p><p>缺点：</p><ol><li>兼容性问题:不支持较低版本的IE浏览器（IE9及以下）</li><li>不支持断线重连，需要手写心跳连接的逻辑 </li><li>通信机制相对复杂</li></ol><h3 id="server-sent-events-SSE"><a href="#server-sent-events-SSE" class="headerlink" title="server-sent -events SSE"></a>server-sent -events SSE</h3><p>服务器向客户端声明，接下来要发送的是流信息，也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。本质上，这种通信就是以流信息的方式，完成一次用时很长的下载</p><p>优点：（1）只需一次请求，便可以stream的方式多次传送数据，节约资源和带宽 （2）相对WebSocket来说简单易用 （3）内置断线重连功能(retry)</p><p>缺点： （1）是单向的，只支持服务端-&gt;客户端的数据传送，客户端到服务端的通信仍然依靠AJAX，（2）兼容性令人担忧，IE浏览器完全不支持</p><h3 id="ajax轮询"><a href="#ajax轮询" class="headerlink" title="ajax轮询"></a>ajax轮询</h3><p>优点：兼容性良好，对标低版本IE<br>缺点：请求中有大半是无用的请求，浪费资源</p><h3 id="永久帧"><a href="#永久帧" class="headerlink" title="永久帧"></a>永久帧</h3><p>缺点： iframe会产生进度条一直存在的问题，用户体验差<br>优点：兼容低版本IE浏览器</p><h3 id="flash-socket"><a href="#flash-socket" class="headerlink" title="flash socket"></a>flash socket</h3><p>缺点：（1）浏览器开启时flash需要用户确认，（2）加载时间长，用户体验较差 （3）大多数移动端浏览器不支持flash，为重灾区优点： 兼容低版本浏览器</p><h2 id="前端反爬虫"><a href="#前端反爬虫" class="headerlink" title="前端反爬虫"></a>前端反爬虫</h2><p>一些网站的敏感数据为了防止被爬虫抓取，同时也为了不影响seo，会采用反爬虫的策略。</p><h3 id="常见的反爬虫策略"><a href="#常见的反爬虫策略" class="headerlink" title="常见的反爬虫策略"></a>常见的反爬虫策略</h3><ul><li>后端<ul><li>1.验证码</li><li>2.cookie验证</li><li>3.user-agent验证</li></ul></li><li>前端<ul><li>1.伪元素隐藏<br>   把关键词写在伪元素里面，当爬取数据时，需要解析css</li><li>2.元素定位覆盖式<br>   按照一定的规则重新定位、排序元素</li><li>3.font-face<br>   改变源代码所使用的的字符集，通过unicode去映射来展示到页面上</li><li>4.图片剪切<br>   页面显示图片的一部分，通过background-position来定位显示</li><li>5.字符串分割</li></ul></li></ul><h2 id="前端安全问题"><a href="#前端安全问题" class="headerlink" title="前端安全问题"></a>前端安全问题</h2><p>前端常见安全问题有8个方面</p><p><img src="/zyhxwing/../images/browser/1345_1.png" alt="前端常见安全问题"></p><h3 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h3><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。</p><h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><p>又叫持久型 XSS，顾名思义，黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。</p><p>存储型 XSS 的攻击步骤：</p><ul><li>攻击者将恶意代码提交到目标网站的数据库中。</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul><h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><p>顾名思义，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。</p><p>反射型 XSS 的攻击步骤：</p><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ul><h4 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h4><p>目前更流行前后端分离的项目，反射型 XSS 无用武之地。 但这种攻击不需要经过服务器，我们知道，网页本身的 JavaScript 也是可以改变 HTML 的，黑客正是利用这一点来实现插入恶意脚本。</p><p>基于DOM 的 XSS 攻击步骤：</p><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL。</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>反射型的 XSS 的恶意脚本存在 URL 里，存储型 XSS 的恶意代码存在数据库里。反射型 XSS 攻击常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</li><li>存储型XSS攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</li><li>基于DOM的XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，其他两种 XSS 都属于服务端的安全漏洞。</li></ul><h4 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h4><ul><li>前端输入过滤</li><li>对html做充分转移</li><li>纯前端渲染，把代码和数据分割开</li><li>在使用innerhtml时不能把不可信的数据作为html插入到网页上，避免把用户输入的数据拼接到字符串中，再将该字符串传递给能运行字符串代码的api</li><li>CSP内容安全策略，定义域名白名单</li><li>设置cookie的httponly，禁止js读取cookie</li><li>使用验证码来防止脚本冒充用户</li></ul><h3 id="CSRF跨站请求伪造"><a href="#CSRF跨站请求伪造" class="headerlink" title="CSRF跨站请求伪造"></a>CSRF跨站请求伪造</h3><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h4 id="CSRF攻击流程"><a href="#CSRF攻击流程" class="headerlink" title="CSRF攻击流程"></a>CSRF攻击流程</h4><ul><li>受害者登录A网站，并且保留了登录凭证（Cookie）</li><li>攻击者引诱受害者访问B网站</li><li>B网站向A网站发送了一个请求（这个就是下面将介绍的几种伪造请求的方式），浏览器请求头中会默认携带 A 网站的 CookieA 网站</li><li>服务器收到请求后，经过验证发现用户是登录了的，所以会处理请求</li></ul><h4 id="CSRF攻击类型"><a href="#CSRF攻击类型" class="headerlink" title="CSRF攻击类型"></a>CSRF攻击类型</h4><ul><li>get类型</li><li>post类型</li><li>链接类型</li></ul><h4 id="CSRF特点"><a href="#CSRF特点" class="headerlink" title="CSRF特点"></a>CSRF特点</h4><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><h4 id="CSRF防范措施"><a href="#CSRF防范措施" class="headerlink" title="CSRF防范措施"></a>CSRF防范措施</h4><ul><li>浏览器同源检测</li><li>CSRF Token，服务器生一个随机字符串提供给浏览器，当浏览器再次请求时，需要携带该字符串，如果两次不一致则拒绝</li><li>Cookie设置合适的SameSite，禁止第三方请求头携带cookie（strict），默认是lax模式，打开了新的页面且是get请求可以携带cookie，none代表可以携带</li></ul><h3 id="CDN劫持"><a href="#CDN劫持" class="headerlink" title="CDN劫持"></a>CDN劫持</h3><p>它的名字就叫做CDN——Content Delivery Network，内容分发网络。具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓吧？）CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速。</p><p>网络上有很多黑客为了让用户能够登录自己开发的钓鱼网站，都会通过对CDN进行劫持的方法，让用户自动转入自己开发的网站。而很多用户却往往无法察觉到自己已经被劫持。其实验证被劫持的方法，就是输入任何网址看看所打开的网页是否和自己输入的网址一致，</p><h4 id="解决措施"><a href="#解决措施" class="headerlink" title="解决措施"></a>解决措施</h4><ul><li>使用SRI 子资源完整性来判断是否被篡改，通过给 link 标签或者 script 标签增加 integrity 属性即可开启 SRI 功能</li></ul><p>当浏览器在 script 或者 link 标签中遇到 integrity 属性之后，会在执行脚本或者应用样式表之前对比所加载文件的哈希值和期望的哈希值。当脚本或者样式表的哈希值和期望的不一致时，浏览器必须拒绝执行脚本或者应用样式表，并且必须返回一个网络错误说明获得脚本或样式表失败。</p><h3 id="CSP内容安全策略"><a href="#CSP内容安全策略" class="headerlink" title="CSP内容安全策略"></a>CSP内容安全策略</h3><p>内容安全策略（Content Security Policy）简称 CSP，通过它可以明确的告诉客户端浏览器当前页面的哪些外部资源可以被加载执行，而哪些又是不可以的。</p><h4 id="CSP的意义"><a href="#CSP的意义" class="headerlink" title="CSP的意义"></a>CSP的意义</h4><p>防XSS等攻击的利器。CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。<br>CSP的分类</p><p>Content-Security-Policy 配置好并启用后，不符合 CSP 的外部资源就会被阻止加载。<br>Content-Security-Policy-Report-Only 表示不执行限制选项，只是记录违反限制的行为。它必须与report-uri选项配合使用。</p><h4 id="CSP的使用"><a href="#CSP的使用" class="headerlink" title="CSP的使用"></a>CSP的使用</h4><ul><li>通过 HTTP 头配置 Content-Security-Policy，以下配置说明该页面只允许当前源和 <a href="https://apis.google.com/">https://apis.google.com</a> 这 2 个源的脚本加载和执行：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Content<span class="token operator">-</span>Security<span class="token operator">-</span>Policy<span class="token operator">:</span> script<span class="token operator">-</span>src <span class="token string">'self'</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>apis<span class="token punctuation">.</span>google<span class="token punctuation">.</span>com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>通过页面meta标签配置</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"Content-Security-Policy"</span> content<span class="token operator">=</span><span class="token string">"script-src 'self' https://apis.google.com"</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h3><p>iframe在给我们的页面带来更多丰富的内容和能力的同时，也带来了不少的安全隐患。因为iframe中的内容是由第三方来提供的，默认情况下他们不受我们的控制，他们可以在iframe中运行JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端用户体验。</p><h4 id="如何让自己的网站不被其他网站的iframe引用？"><a href="#如何让自己的网站不被其他网站的iframe引用？" class="headerlink" title="如何让自己的网站不被其他网站的iframe引用？"></a>如何让自己的网站不被其他网站的iframe引用？</h4><p>js的防御方案：</p><ul><li>将下面这段代码放到网站页面的body标签前，这样别人在通过iframe框架引用你的网站网页时，浏览器会自动跳转到你的网站所引用的页面上。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">if</span> <span class="token punctuation">(</span>self <span class="token operator">==</span> top<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> theBody <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    theBody<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"block"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    top<span class="token punctuation">.</span>location <span class="token operator">=</span> self<span class="token punctuation">.</span>location<span class="token punctuation">;</span>    <span class="token comment">//判断当前窗体的url和父窗体的url是不是相同，如果不相同，则把窗体的url设成和本窗体一样。</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用<strong>X-Frame-Options</strong>防止网页被iframe：X-FRAME-OPTIONS是微软提出的一个http头，专门用来防御利用iframe嵌套的点击劫持攻击。</li></ul><pre class="line-numbers language-none"><code class="language-none">DENY               &#x2F;&#x2F; 拒绝任何域加载SAMEORIGIN         &#x2F;&#x2F; 允许同源域下加载ALLOW-FROM         &#x2F;&#x2F; 可以定义允许frame加载的页面地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="如何禁止被使用的-iframe-对当前网站某些操作？"><a href="#如何禁止被使用的-iframe-对当前网站某些操作？" class="headerlink" title="如何禁止被使用的 iframe 对当前网站某些操作？"></a>如何禁止被使用的 iframe 对当前网站某些操作？</h4><p>sandbox是html5的新属性，主要是提高iframe安全系数。iframe因安全问题而臭名昭著，这主要是因为iframe常被用于嵌入到第三方中，然后执行某些恶意操作。现在有一场景：我的网站需要 iframe 引用某网站，但是不想被该网站操作DOM、不想加载某些js（广告、弹框等）、当前窗口被强行跳转链接等，我们可以设置 sandbox 属性:</p><ul><li>allow-same-origin：允许被视为同源，即可操作父级DOM或cookie等</li><li>allow-top-navigation：允许当前iframe的引用网页通过url跳转链接或加载</li><li>allow-forms：允许表单提交</li><li>allow-scripts：允许执行脚本文件</li><li>allow-popups：允许浏览器打开新窗口进行跳转</li><li>“”：设置为空时上面所有允许全部禁止</li></ul><h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><h3 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h3><ol><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连用如果需要使用v-for给每项元素绑定事件时使用事件代理</li><li>SPA 页面采用keep-alive缓存组件</li><li>在更多的情况下，使用v-if替代v-show</li><li>key保证唯一使用</li><li>路由懒加载、</li><li>异步组件防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li><strong>图片懒加载</strong></li><li>用css去代替图片</li><li><strong>减少http请求</strong>(图片采用css sprite的方式来减少请求，用background-image和background-position属性来定位)</li><li>使用http2</li><li>将 CSS 放在文件头部，javascript 文件放在底部</li><li>选择link而舍弃@import引入</li><li><strong>将多个JS、CSS文件合并到一个文件里面去</strong></li><li><strong>建立独立图片服务器</strong>，把前端静态文件中的js、css、图片等资源都放到另一个服务器上</li><li>使用梯子图标代替图片图标</li><li>减少重绘和回流</li><li>合理使用事件委托，即事件冒泡，通过给父组件增加方法以避免给子组件增加方法</li><li>当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else</li><li>计算的时候尽量使用位操作</li><li>使用 flexbox 而不是较早的布局模型</li><li>使用 transform 和 opacity 属性更改来实现动画 </li><li>使用 requestAnimationFrame 来实现视觉变化</li><li>使用<strong>防抖节流</strong>来控制流量</li></ol><h3 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h3><ol><li>预渲染</li><li>服务端渲染SSR</li></ol><h3 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h3><ol><li>压缩代码</li><li>Tree Shaking&#x2F;Scope Hoisting</li><li><strong>使用cdn加载第三方模块</strong></li><li>多线程打包happypack</li><li>splitChunks抽离公共文件</li><li>sourceMap优化</li><li>webpack降低图片质量</li></ol><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><ol><li>骨架屏（使用vue-content-loader可自定义的SVG组件，用于创建占位符加载，在需要使用骨架屏的页面引入组件，使用标签Suspense包裹骨架屏占位组件，当真实dom渲染完毕的时候，隐藏占位组件  ）</li><li>PWA（渐进式网络应用基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。)</li><li><strong>使用缓存(客户端缓存、服务端缓存)</strong></li><li><strong>服务端开启gzip压缩</strong>，客户端请求头加上Accept-Encoding: gzip, deflate，同时服务器将响应头设置上 Content-encoding: gzip，表示当前资源会使用 gzip 压缩，提示客户端解压使用（只对文本进行压缩，图片因为体积大，本身就压缩过，效果差时间长），或者nginx上来开启gzip。</li><li><strong>部分请求延迟执行</strong>，比如获取淘宝天猫的评论，是在用户访问该商品5s之后才执行的；</li></ol><h2 id="前端模块化CommonJS及ES6模块化"><a href="#前端模块化CommonJS及ES6模块化" class="headerlink" title="前端模块化CommonJS及ES6模块化"></a>前端模块化CommonJS及ES6模块化</h2><p><strong>什么是模块化？</strong><br>模块化开发是一种管理方式，是一种生产方式，一种解决问题的方案，一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块，但是模块开发需要遵循一定的规范，否则就都乱套了，因此，才有了后来大家熟悉的AMD规范，CMD规范，以及ES6自带的模块化规范</p><p><strong>模块化带来的好处</strong><br>解决命名冲突、代码复用、代码可读性、依赖管理等</p><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>(1)简介<br>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。在服务器端，模块的加载<strong>是运行时同步加载</strong>的，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题；在浏览器端，基于网络原因，模块需要提前编译打包处理。</p><p>(2)特点<br>所有代码都运行在模块作用域，不会污染全局作用域。<br>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。模块加载的顺序，按照其在代码中出现的顺序。</p><p>(3)基本语法<br>暴露模块：module.exports &#x3D; value或exports.xxx &#x3D; value<br>引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</p><p>require命令用于加载模块文件。require命令的基本功能是，读入并执行一个javascript文件，然后返回该模块的exports对象。如果没有发现<br>指定模块，会报错。</p><p>(4)模块的加载机制<br>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。这点与ES6模块化有重大差异（ES6输入的是值的引用）</p><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>AMD规范采用<strong>异步</strong>方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p><h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p><h3 id="ES6-与-CommonJS-模块的差异"><a href="#ES6-与-CommonJS-模块的差异" class="headerlink" title="ES6 与 CommonJS 模块的差异"></a>ES6 与 CommonJS 模块的差异</h3><ol><li><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul></li><li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul></li><li><p>CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p></li></ol><h2 id="前端单元测试"><a href="#前端单元测试" class="headerlink" title="前端单元测试"></a>前端单元测试</h2><ol><li><p>UI测试<br>验证所有页面字体的风格是否一致<br>背景颜色应该与字体颜色和前景颜色相搭配<br>图片的大小和质量是否正常</p></li><li><p>功能测试（也称为e2e测试）<br>基本的功能是否符合预期<br>模拟用户操作，交互流程是否正确</p></li><li><p>兼容性测试<br>平台兼容性，使用用不同的 操作系统平台对网站进行测试。最常见的有 Windows、macOS、 Linux 等。<br>浏览器兼容性， 查看不同浏览器中的兼容性问题。<br>分辨率测试，在不同分辨率下的显示效果，避免分辨率低时界面文字显示太大，而分辨率高时又有些文字显示时太小。</p></li><li><p>性能测试<br>页面首次打开的耗时<br>页面加载时间<br>频繁操作是否奔溃</p></li><li><p>稳定性测试<br>页面是否白屏<br>掉电重启,断网重连后是否正常<br>长时间运行是否会奔溃</p></li><li><p>易用性测试<br>常用快捷键 （刷新，关闭等）<br>常用习惯性操作（回车搜索）<br>便捷性功能（记住密码等）</p></li></ol><h2 id="前端工程化、模块化、组件化"><a href="#前端工程化、模块化、组件化" class="headerlink" title="前端工程化、模块化、组件化"></a>前端工程化、模块化、组件化</h2><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><ol><li><p>为什么要以工程化的思想来看待前端项目？<br>目前，web业务日益复杂化和多元化，单页面应用和webApp风靡。而且前端的生态圈繁荣，各种框架，组件出现，使得前端发展迅速，快速开发已经成为了前端的一个标准。靠传统的前端三剑客 javascript、HTML、 CSS 以及传统的项目结构已经不能满足日益壮大的大型应用的需求，会带来开发效率、维护成本、代码可读性差等问题。这就要求我们以工程化的思想去看待一个前端项目而不再是直接撸起袖子开写页面，将前端项目当成一项系统工程去进行分析、组织和构建从而达到项目结构清晰、分工明确、团队配合默契、开发效率和开发质量提高以及降低项目生产风险的目的。</p></li><li><p>那我们又该怎样去做到前端的工程化呢？<br>页面组件化<br>代码模块化<br>代码质量管理 (QA)： ESLint<br>代码编译: babel、less、sass、scss等<br>代码构建：webpack<br>项目国际化<br>代码版本管理：Git、SVN</p></li></ol><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>当应用的JS都以模块来编写时, 这个应用就是一个模块化的应用</p><ol><li><p>模块<br>向外提供特定功能的文件， 可以做到按需引入</p></li><li><p>为什么要模块化？<br>随着业务逻辑增加，代码越来越多且复杂</p></li><li><p>作用<br>复用代码, 简化代码的编写, 提高代码运行效率</p></li></ol><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>当应用是以多组件的方式实现, 这个应用就是一个组件化的应用</p><ol><li><p>组件<br>从UI上拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，是一个用来实现局部功能效果的代码和资源的集合</p></li><li><p>为什么要组件化？<br>一个界面的功能更复杂</p></li><li><p>作用<br>复用编码, 简化项目编码, 提高运行效率</p></li></ol><h2 id="前端常用设计模式"><a href="#前端常用设计模式" class="headerlink" title="前端常用设计模式"></a>前端常用设计模式</h2><ol><li>命令模式 该模式旨在将函数的调用、请求和操作封装成一个单一的对象，然后对这个对象进行一系列的处理。此外，可以通过调用实现具体函数的对象来解耦命令对象与接收对象。</li><li>单例模式 一个构造函数有且只有一个实例对象，并且提供方法给全局使用（惰性单例：使用时才创建）</li></ol><ul><li>登录框</li><li>vuex 和 redux中的store</li></ul><ol start="3"><li>发布订阅模式 订阅一个动作，当发布者将这个动作触发，则订阅者也随之做出动作</li></ol><ul><li>vue2响应式原理，发布订阅+数据劫持</li><li>事件总线</li></ul><ol start="4"><li>策略模式 模块化取代if else 每个逻辑分开写</li><li>代理模式  代理模式更侧重于对类的控制 相当于限制器、阀口，vue3proxy</li><li>装饰器模式  装饰器模式更侧重于提升类的能力，拓展器</li><li>工厂模式 定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。</li><li>迭代器模式 访问一个聚合对象的内容而无需暴露它的内部表示。为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作</li><li>状态模式 通过定义不同的状态类，根据状态的改变而改变对象的行为，也不必把大量的逻辑都写在被操作对象的类中，而且容易增加新的状态</li></ol><h2 id="SPA单页面"><a href="#SPA单页面" class="headerlink" title="SPA单页面"></a>SPA单页面</h2><p><strong>概念：</strong><br>SPA（ single page application ）仅在 Web 页面初始化时加载相应的 HTML、javascript 和 CSS。<br>一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转<br>而页面的变化是利用路由机制实现 HTML 内容的变换，避免页面的重新加载。</p><p><strong>优点：</strong></p><ol><li>加载速度快，内容的改变不需要重新加载整个页面</li><li>用户体验好，减少了重复渲染与不必要的跳转</li><li>前后端逻辑能够更加清晰</li></ol><p><strong>缺点:</strong></p><ol><li>初次加载速度慢</li><li>不能利用搜索引擎搜索到</li><li>在一个页面实现的功能 没有地址的跳转，不能前进后退</li></ol><p><strong>如何优化：</strong></p><ol><li>静态资源本地缓存，强缓存</li><li>UI框架按需加载</li><li>图片资源压缩，webpack配置帮助压缩</li><li>开启Gzip压缩前端工程</li><li>使用SSR服务器渲染</li></ol><h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><ol><li>管道</li><li>消息队列</li><li>共享内存</li><li>信号量</li><li>Socket</li></ol><p>以开启一个新 tab 为例</p><ul><li>Browser进程中的UI线程处理用户交互，接收到用户请求，转交给IO线程</li><li>Browser进程中的IO线程获取页面内容（通过网络请求或本地缓存），随后将该任务通过 RendererHost 接口传递给 Renderer 进程</li><li>Renderer进程 的 Renderer接口 收到消息，简单解释后交给渲染线程，进行 html 、css 解析，渲染页面，js 执行等任务</li><li>Renderer 进程将得到的结果传递给 Browser 进程</li><li>Browser进程 接收到结果并在界面上绘制出图像。</li></ul><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="多进程浏览器-有哪些进程、线程"><a href="#多进程浏览器-有哪些进程、线程" class="headerlink" title="多进程浏览器 有哪些进程、线程"></a>多进程浏览器 有哪些进程、线程</h3><ul><li>GPU 进程。Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了GPU 进程。</li><li>V8代理解析工具（v8代码解释器）Google的开源高性能javascript和WebAssembly引擎，用C编写，它实现ECMAScript和WebAssembly，可独立运行或嵌入到任何C应用程序中，如Chrome和Node.js。</li><li>NetWork进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li>浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li>插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li><li>渲染进程。核心任务是将 HTML、CSS 和 javascript 转换为用户可以与之交互的网页，排版引擎 Blink 和 javascript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li></ul><p>渲染进程下有多个线程：</p><ul><li>GUI渲染线程：负责渲染页面，布局和绘制、页面需要重绘和回流时，该线程就会执行、与js引擎线程互斥，防止渲染结果不可预期</li><li>JS引擎线程：负责处理解析和执行javascript脚本程序、只有一个JS引擎线程（单线程）、与GUI渲染线程互斥，防止渲染结果不可预期</li><li>事件触发线程：用来控制事件循环（鼠标点击、setTimeout、ajax等）当处理一些不能立即执行的代码时，会将对应的任务在其可以触发的时机，添加到事件队列的末端事件循环机制会在JS引擎线程空闲时，循环访问事件队列的头部，如果有函数，则会将该函数推到执行栈中并立即执行</li><li>定时触发器线程：setInterval与setTimeout所在的线程、定时任务并不是由JS引擎计时的，是由定时触发线程来计时的、计时完毕后，将回调事件放入到事件队列中</li><li>异步http请求线程：浏览器有一个单独的线程用于处理AJAX请求、当请求完成时，若有回调函数，将回调事件放入到事件队列中。</li></ul><h3 id="操作系统下进程与线程的区别"><a href="#操作系统下进程与线程的区别" class="headerlink" title="操作系统下进程与线程的区别"></a>操作系统下进程与线程的区别</h3><p>做个简单的比喻：进程&#x3D;火车，线程&#x3D;车厢</p><ul><li>线程在进程下行进（单纯的车厢无法运行）</li><li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li><li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li><li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li><li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li><li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li><li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”</li><li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”‘</li></ul><p>除此以外还有协程的概念<br>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。<br>一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。<br>与其让操作系统调度，不如我自己来，这就是协程</p><h2 id="严格模式与非严格模式的主要区别"><a href="#严格模式与非严格模式的主要区别" class="headerlink" title="严格模式与非严格模式的主要区别"></a>严格模式与非严格模式的主要区别</h2><ol><li>变量规范：非严格模式下，变量可以不进行声明，可直接赋值，严格模式中，变量必须声明才能赋值</li><li>函数this指向：非严格模式下，普通函数指向Window，严格模式下，this为undefined</li><li>构造函数调用：非严格模式下，构造函数可以直接调用，严格模式中不行</li><li>删除变量：非严格模式下，可以使用delete删除已经声明的变量，严格模式下回报错</li><li>在定时器函数中，this的指向都为window</li><li>函数中传递的形参不能重复</li></ol><h2 id="浏览器性能监控"><a href="#浏览器性能监控" class="headerlink" title="浏览器性能监控"></a>浏览器性能监控</h2><p><a href="https://blog.csdn.net/qq_29438877/article/details/103998284">https://blog.csdn.net/qq_29438877/article/details/103998284</a></p><p><strong>需要监控的内容：</strong></p><ol><li>页面访问速度：白屏、首屏时间、可交互时间</li><li>页面稳定性：页面出错情况、资源加载错误、JS 执行报错</li><li>外部服务调用：CGI 耗时、CGI 成功率、CDN 资源耗时</li></ol><p><strong>监控的方法：</strong></p><ol><li><p>合成监控：用 web 浏览器模拟器来加载网页，通过模拟终端用户可能的操作来采集对应的性能指标，最后输出一个网站性能报<strong>Lighthouse</strong>、PageSpeed、WebPageTest。</p></li><li><p>真实用户监控：真实用户监控是一种被动监控技术，是一种应用服务，被监控的 web 应用通过 sdk 等方式接入该服务，将真实的用户访问、交互等性能指标数据收集上报、通过数据清洗加工后形成性能分析报表。例如 <strong>FrontJs、oneapm、Datadog</strong> 等。</p></li></ol><h2 id="Dom树、CSS树、渲染树"><a href="#Dom树、CSS树、渲染树" class="headerlink" title="Dom树、CSS树、渲染树"></a>Dom树、CSS树、渲染树</h2><p>首先你要了解浏览器渲染的顺序：</p><ol><li>构建dom 树</li><li>构建css 树</li><li>构建渲染树</li><li>节点布局</li><li>页面渲染</li></ol><p><strong>什么是dom树？</strong></p><p>浏览器将HTML解析成树形的数据结构，简称DOM。<br>DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 javascript）与 HTML 元素之间的接口。 解析树的根节点是Document对象。</p><p>你还可以这样理解 dom 树：<br>  1.DOM树揭示了DOM对象之间的层次关系，这样就方便动态地对html文档进行增删改查。<br>  2.增删改查必须要遵循层次关系<br>  3.文本对象是最底层的节点<br>  4.获取对象的值 .value</p><p><strong>什么是css树</strong></p><p><img src="https://img-blog.csdnimg.cn/20201011173136831.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgyMDQ0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="css树"></p><p> 看着有点像 less 写法（less这种预处理语言，就是借用DOM树的思想，来将less这种语法结构，转译成普通的css语法，最终我们用的还是普通的css语法构成的css文件）。</p><p><strong>那渲染树(render树)是什么呢？</strong></p><p>要明白这点，需要理解浏览器是如何渲染 UI 的？<br>（1）浏览器获取 HTML 文件，然后对文件进行解析，形成 DOM Tree<br>（2）与此同时，进行 CSS 解析，生成 Style Rules<br>（3）接着将 DOM Tree 与 Style Rules 合成为 Render Tree<br>（4）元素在页面中布局，然后绘制<br><strong>render 树就是根据 可视化节点 和 css 样式表 结合诞生出来的树；</strong></p><p>注意：PS: display: none 的元素会出现在 DOM树 中，但不会出现在 render 树中；</p><p><strong>渲染树构建(renderTree)</strong><br>渲染树是dom树结合css树形成的一个新的树。当renderTree构建完毕后，浏览器会根据它去绘制页面。</p><p>特点:<br>(1)渲染树每个节点都有自己的样式。<br>(2)不包含隐藏节点(display: none)、不需要绘制的节点(html&#x2F;head&#x2F;style&#x2F;title)，这些节点在renderTree形成之前就会被剔除。<br>(3)visibility: hidden相对应的节点是包含在渲染树上的，因为它影响布局(layout)。<br>(4)渲染树上的每一个节点都会被当成一个盒子，具有内容填充、边距、边框、位置、大小及其它样式。</p><p><strong>节点布局</strong><br>其实DOM节点可以分为 可视化节点 和 非可视化节点，<br>像 div、p 等这种结构性的标签节点可被称为可视化节点，<br>而 script、meta 等这种在页面上显示不出来的节点则被称为非可视化节点；</p><p><strong>页面渲染</strong><br>页面渲染机制主要分为解析和加载</p><p>解析：解析就是把整个html结构变成一个又一个的节点，然后挂在dom树上面形成dom树</p><p>加载：加载就是加载html里面的资源</p><p>先有解析，再有加载，而解析和加载的过程是一个异步的过程</p><p>示例1</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"baidu.png"</span> alt<span class="token operator">=</span><span class="token string">""</span> <span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>先是解析img标签变成节点再挂到dom树上，图片的加载并不在解析的过程当中，加载在当前节点解析完成之后</p><p>示例2<br>在构建dom树的时候，span和div会挂在dom树上面吗？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>span style<span class="token operator">=</span><span class="token string">"display: none"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token keyword">var</span> oDiv <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oDiv<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>会，因为节点树不会管样式，只管dom节点，动态创建也是dom节点</p><h2 id="前端代码规范"><a href="#前端代码规范" class="headerlink" title="前端代码规范"></a>前端代码规范</h2><h3 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h3><ul><li>所有类名、id名、方法名等涉及到名称的，统一使用驼峰命名，命名要具有业务意义，语义化简洁明了</li><li>代码中不得出现警告</li><li>代码中不得出现数字（插件除外）</li><li>结构（html），表现(css)，行为(js)代码需分离</li></ul><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><ul><li>代码力求简洁，不要写大量重复的逻辑代码（公共方法需封装，公共样式提取到公共样式中）</li><li>代码要有可读性，函数和元素命名要具有业务意义，关键业务要有详细的注释</li><li>代码要有扩展性，要尽可能适应未来的业务变化，不得生搬硬套现有业务逻辑</li><li>代码要有通用性，一个方法只专注于该方法需要做的事情（对外暴露相应的参数），一个模块只专</li></ul><h3 id="html规范"><a href="#html规范" class="headerlink" title="html规范"></a>html规范</h3><ul><li><p>Html代码大小写<br>HTML标签名、类名、标签属性和大部分属性值统一用小写<br>推荐：<code>&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;</code></p></li><li><p>元素属性</p></li></ul><p>属性值使用双引号语法<br>  例：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot; &gt; </code></p><ul><li>特殊字符引用</li></ul><p>不得使用‘&gt;’和‘&lt;’特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体</p><ul><li>代码嵌套</li></ul><p>每个块级元素独占一行，内联元素可选</p><ul><li>引用规范</li></ul><p>将所有页面公共样式（如common.css）、插件样式写入head内的底部；<br>将所有页面公共js、插件js放入body内底部；</p><h3 id="css规范"><a href="#css规范" class="headerlink" title="css规范"></a>css规范</h3><ul><li>代码格式化</li></ul><ol><li>样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写</li><li>每个属性声明末尾都要加分号；</li><li>css属性值需要用到引号时，统一使用双引号</li><li>尽量不要用固定的宽高，多使用padding 和 margin</li><li>尽量少用通用选择器*</li><li>不使用ID选择器</li><li>不使用无具体语义定义的标签选择器</li><li>尽量少用！Important</li></ol><ul><li>代码可读性</li></ul><p>左括号与类名之间一个空格，冒号与属性值之间一个空格<br>逗号分隔的取值，逗号之后一个空格<br> 推荐：box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc; </p><ul><li>不要为0指明单位</li></ul><p> 推荐：margin：0 10px;<br> 不推荐：margin：0px 10px;</p><ul><li>属性书写顺序</li></ul><h3 id="js规范"><a href="#js规范" class="headerlink" title="js规范"></a>js规范</h3><ul><li>文件命名</li></ul><p>文件命名和html中的功能相对应</p><ul><li>语言规范</li></ul><ol><li>尽量不要定义全局变量，否则很容易造成全局变量污染。</li><li>变量先定义再使用，尽量避免使用全局变量分号</li><li>语句结束总是使用分号</li><li>使用严格相等号</li><li>尽量使用&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;</li><li>条件判断语句必须放入{}中</li><li>在if&#x2F;else&#x2F;for&#x2F;do&#x2F;while语句中，即使只有一行，也不得省略块{…}</li><li>If嵌套不能超过2层</li><li>一个函数的长度必须限制在50行以内，不然看完有时候会懵逼，可以分割成多个函数，一个函数只做一件事（单一原则）</li><li>函数定义结束不允许添加分号</li><li>common.js文件里面的函数必须保证是项目中大多数地方都会用到，且通用，common.js中的函数名要唯一。</li></ol><h2 id="浏览器页面通信方法"><a href="#浏览器页面通信方法" class="headerlink" title="浏览器页面通信方法"></a>浏览器页面通信方法</h2><p>实现多个标签页之间的通信，本质上都是通过<strong>中介者模式</strong>来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p><ul><li>使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li><li>使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li><li>使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</li><li>使用 postMessage 方法，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。</li></ul><h2 id="前端页面性能测试与测试指标"><a href="#前端页面性能测试与测试指标" class="headerlink" title="前端页面性能测试与测试指标"></a>前端页面性能测试与测试指标</h2><h3 id="基本指标介绍"><a href="#基本指标介绍" class="headerlink" title="基本指标介绍"></a>基本指标介绍</h3><p>首先前端性能指标一般分为以下几种：</p><p>首屏绘制（First Paint，FP）</p><p>首屏内容绘制（First Contentful Paint，FCP）</p><p>可交互时间（Time to Interactive，TTI）</p><p>最大内容绘制（Largest Contentful Paint，LCP)</p><p>首次有效绘制（First Meaning Paint, FMP）</p><p>FP 是时间线上的第一个“时间点”，是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间，简而言之就是浏览器第一次发生变化的时间。</p><p>FCP（全称“First Contentful Paint”，翻译为“首次内容绘制”），是指浏览器从响应用户输入网络地址，在页面首次绘制文本，图片（包括背景图）、非白色的 canvas 或者SVG 才算做 FCP，有些文章说 FCP 是首屏渲染事件，这其实是不对的。</p><p>TTI，翻译为“可交互时间”表示网页第一次完全达到可交互状态的时间点。可交互状态指的是页面上的 UI 组件是可以交互的（可以响应按钮的点击或在文本框输入文字等），不仅如此，此时主线程已经达到“流畅”的程度，主线程的任务均不超过50毫秒。在一般的管理系统中，TTI 是一个很重要的指标。</p><p>FMP（全称“First Meaningful Paint”，翻译为“首次有效绘制”表示页面的“主要内容”开始出现在屏幕上的时间点，它以前是我们测量用户加载体验的主要指标。本质上是通过一个算法来猜测某个时间点可能是 FMP，但是最好的情况也只有77%的准确率，在lighthouse6.0 的时候废弃掉了这个指标，取而代之的是 LCP 这个指标。</p><p>LCP（全称“Largest Contentful Paint”）表示可视区“内容”最大的可见元素开始出现在屏幕上的时间点。</p><h2 id="如何使用cdn"><a href="#如何使用cdn" class="headerlink" title="如何使用cdn"></a>如何使用cdn</h2><ol><li>为什么要用cdn加速服务<br>优点：</li></ol><ul><li>JS体积变小，使用CDN的第三方资源的JS代码，将不再打包到本地服务的JS包中。减小本地JS包体积，提高加载速度</li><li>给网页加载提速</li><li>CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低</li><li>大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载。<br>缺点：</li><li>请求变多</li><li>万一CDN资源路径有变动需要更改，建议自行搭建CDN库。</li></ul><ol start="2"><li><p>哪些需要使用CDN<br>在项目根目录下运行npm run build –report<br>打包完成后，会打开一个页面，展示各个依赖包的大小，查看哪些第三方依赖包的体积大，就干掉它，从CDN上获取。</p></li><li><p>推荐BootCDN<br><a href="http://www.bootcdn.cn/">www.bootcdn.cn/</a></p></li><li><p>确认包和版本<br>确认需要使用CDN加载的资源，在package-lock.json文件中，找到对应的版本号。<br>在BootCDN网站找到对应的资源路径。</p></li><li><p>修改index.html文件<br>link添加在头部，script添加在尾部</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/element-ui/2.4.4/theme-chalk/index.css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- built files will be auto injected --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/vue/2.5.16/vue.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/three.js/100/three.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/echarts/4.1.0/echarts.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/axios/0.17.1/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/element-ui/2.4.4/index.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/babel-polyfill/6.26.0/polyfill.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改webpack.base.conf.js文件<br>在module.exports下添加externals，将通过cdn引入的包忽略，在webpack打包中则无需打包。</p></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">externals</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token string-property property">'vue'</span><span class="token operator">:</span> <span class="token string">'Vue'</span><span class="token punctuation">,</span>    <span class="token string-property property">'vue-router'</span><span class="token operator">:</span> <span class="token string">'VueRouter'</span><span class="token punctuation">,</span>    <span class="token string-property property">'vuex'</span><span class="token operator">:</span> <span class="token string">'Vuex'</span><span class="token punctuation">,</span>    <span class="token string-property property">'three'</span><span class="token operator">:</span> <span class="token string">'THREE'</span><span class="token punctuation">,</span>    <span class="token string-property property">'echarts'</span><span class="token operator">:</span> <span class="token string">'echarts'</span><span class="token punctuation">,</span>    <span class="token string-property property">'axios'</span><span class="token operator">:</span> <span class="token string">'axios'</span><span class="token punctuation">,</span>    <span class="token string-property property">'element-ui'</span><span class="token operator">:</span> <span class="token string">'ElementUI'</span><span class="token punctuation">,</span>    <span class="token string-property property">'babel-polyfill'</span><span class="token operator">:</span> <span class="token string">'_babelPolyfill'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>属性名称vue表明该模块vue中import Vue from ‘vue’应排除在外。为了替换此模块，该值Vue将用于检索全局Vue变量。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">externals</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token string-property property">'vue-router'</span><span class="token operator">:</span> <span class="token string">'VueRouter'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">linkActiveClass</span><span class="token operator">:</span> <span class="token string">'on'</span><span class="token punctuation">,</span>  <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">'history'</span><span class="token punctuation">,</span>  <span class="token literal-property property">routes</span><span class="token operator">:</span> routerArray<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>babel-polyfill的配置全局变量_babelPolyfill，同样是查看源码可得。</p><ol start="7"><li><p>注释掉其他地方包的引入</p></li><li><p>使用预获取<br>只需在链接属性上增加 rel&#x3D;”prefetch”,rel&#x3D;”dns-prefetch”，或者 rel&#x3D;”preload” 标记。</p></li></ol><p>preload：<br>代码会被优先加载，并且会占用http并发数，从而也导致页面加载时间变长，特别是首屏时间会变长。<br>本页面接下来大概率要使用的资源重要资源。</p><p>prefetch：<br>代码被安排在后面加载，这样才达到了优化效果。<br>下个页面很可能会去访问的非重要的资源。<br>然后修改代码如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/vue/2.5.16/vue.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/three.js/100/three.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/echarts/4.1.0/echarts.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/axios/0.17.1/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/element-ui/2.4.4/index.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>被preload修饰的three会优先加载，而被prefetch修饰的echarts会延后加载。</p><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><h3 id="什么是单点登录"><a href="#什么是单点登录" class="headerlink" title="什么是单点登录"></a>什么是单点登录</h3><p>单点登录的英文名叫做：Single Sign On（简称SSO），指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的系统。简而言之，多个系统，统一登陆。</p><p>为什么需要做单点登录系统呢？在一些互联网公司中，公司旗下可能会有多个子系统，每个登陆实现统一管理，多个账户信息统一管理 SSO单点登陆认证授权系统。比如阿里系的淘宝和天猫，显而易见这是两个系统，但是在使用过程中，只要你登录了淘宝，同时也意味着登录了天猫，如果每个子系统都需要登录认证，用户早就疯了，所以我们要解决的问题就是，用户只需要登录一次就可以访问所有相互信任的应用系统。</p><p>sso需要一个独立的认证中心，所有子系统都通过认证中心的登录入口进行登录，登录时带上自己的地址，子系统只接受认证中心的授权，授权通过令牌（token）实现，sso认证中心验证用户的用户名密码正确，创建全局会话和token，token作为参数发送给各个子系统，子系统拿到token，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p><p>三、单点登录实现方式<br>单点登录的实现方案，一般就包含：Cookies，Session同步，分布式Session，目前的网站采用比较多的方式是token令牌和分布式Session的方式。</p><ol><li>基于Cookie+Redis的单点登录<br>最简单的单点登录实现方式，用cookie作为媒介存放用户凭证。 用户登录系统之后，会返回一个加密的cookie，当用户访问子应用的时候会带上这个cookie，授权以解密cookie并进行校验，校验通过后即可登录当前用户。</li></ol><p>redis：在key：生成唯一随机值（ip、用户id等等），在value：用户数据<br>cookie：把redis里面生成key值放到cookie里面</p><ol start="2"><li>分布式session方式实现单点登录<br>流程运行：</li></ol><ul><li>用户第一次登录时，将会话信息（用户Id和用户信息），比如以用户Id为Key，写入分布式Session；</li><li>用户再次登录时，获取分布式Session，是否有会话信息，如果没有则调到登录页；</li><li>一般采用Cache中间件实现，建议使用Redis，因此它有持久化功能，方便分布式Session宕机后，可以从持久化存储中加载会话信息；</li><li>存入会话时，可以设置会话保持的时间，比如15分钟，超过后自动超时；<br>结合Cache中间件，实现的分布式Session，可以很好的模拟Session会话。</li></ul><ol start="3"><li>token验证<br>在项目某个模块进行登录，登录之后，按照jwt规则生成字符串，把登录之后用户包含到生成字符串里面，把字符串返回</li></ol><ul><li>可以把宁符串通过cookie返回</li><li>把字符串通过地址栏返回</li></ul><p>前端收到token之后将token存储在自己的请求头之中或者url后面，这样每次请求都可以带着token请求。</p><p>再去访问项目其他模块，获取地址栏或者请求头里面的token，根据宇符串获职用户信息。</p><p>同时为了设置失效时间，可以将token放在redis中，设置失效时间，判断过期。</p><h2 id="防止localStorage被篡改"><a href="#防止localStorage被篡改" class="headerlink" title="防止localStorage被篡改"></a>防止localStorage被篡改</h2><ol><li>让localStorage值无法修改，不推荐</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'storage'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>oldValue<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>localStorage里面被篡改的部分 和原来数据  会来回进行切换<br>2. localStorage值被修改的时候清除他并且跳转到登录页，只有localStorage发送变化，包括新增，都会清除，并跳转到登录，不推荐</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'storage'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    localStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> baseRout <span class="token operator">+</span> <span class="token string">'/login.html'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>对 localStorage进行加密和解密，推荐</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//加密</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function">btoa</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">encodeURIComponent</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>、<span class="token comment">//解密，根据key获取值</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token function">decodeURIComponent</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">atob</span><span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>window.btoa(str)<br>用于编码形成 base-64 编码的字符串。</p><p>window.atob(str)<br>用于解码使用 base-64 编码的字符串（base64图片下载时候通常需要先解码，然后将解码内容转化为二进制数据下载）。</p><p>window.encodeURIComponent(str)<br>用于url的组成部分编码，不能用于整个url编码。把字符串作为 URI 组件进行编码。该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。其他字符（比如 ：;&#x2F;?:@&amp;&#x3D;+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。假定任何保留字符都代表普通文本，所以必须编码它们。</p><p>window.decodeURIComponent(str)<br>对 encodeURIComponent() 函数编码的 URI 进行解码。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端安全 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 网络传输 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/zyhxwing/2022/09/03/javascript/"/>
      <url>/zyhxwing/2022/09/03/javascript/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><p>基本数据类型<br><strong>Number，String，Boolean，null，undefined，symbol，bigint（后两个为ES6新增）</strong></p></li><li><p>引用数据类型<br><strong>普通对象，数组对象，正则对象，日期对象，Math数学函数对象。</strong></p></li><li><p>包装数据类型<br><strong>Number，String，Boolean</strong></p></li></ul><p><strong>两种数据存储方式：</strong></p><ul><li><p>基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基本类型值和执行代码的空间。</p></li><li><p>引用数据类型是存储在堆内存中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。</p></li></ul><p><strong>两种数据类型的区别：</strong></p><ul><li>堆比栈空间大，栈比堆运行速度快。</li><li>堆内存是无序存储，可以根据引用直接获取。</li><li>基础数据类型比较稳定，而且相对来说占用的内存小。</li><li>引用数据类型大小是动态的，而且是无限的。</li><li>复制方式不一样：值类型直接赋值就是复制，引用类型的变量直接赋值实际上是传递引用，只是浅复制</li><li>基本数据类型无法添加属性和方法，引用类型可以添加属性和方法</li><li>基本数据类型的比较是值的比较，只有当它们的值相等的时候它们才相等，引用类型是引用地址的比较（比较的时候&#x3D;&#x3D;是在比较的时候做了类型转换，而&#x3D;&#x3D;&#x3D;是值和类型相等才能相等）</li><li>基本数据类型的变量在函数中被修改时，只在函数作用域内部生效，函数被销毁后此次修改立即失效，而引用类型在函数中被修改时修改的是运行时数据区中的值，即使函数被销毁，变量的值依旧被改变。</li></ul><p>BigInt类型<br>BigInt数据类型提供了一种方法来表示大于2^53-1的整数。BigInt可以表示任意大的整数。</p><p>Symbol类型<br>Symbol 是一种在ES6 中新添加的数据类型，本质上是一种唯一标识符，可用作对象的唯一属性名，这样其他人就不会改写或覆盖你设置的属性值，同时具备隐藏性（for in不能访问）。</p><h2 id="js常见函数"><a href="#js常见函数" class="headerlink" title="js常见函数"></a>js常见函数</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign(target, …sources)</p><p><strong>Object.assign会将source里面的可枚举属性复制到target</strong>，如果和target的已有属性重名，则会覆盖。后续的source会覆盖前面的source的同名属性。Object.assign复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。</p><h3 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h3><ul><li><p>相同<br>三者都可以改变函数的this对象指向。<br>三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。</p></li><li><p>区别<br>三者都可以传参，但是apply是数组，即一个数组对象，而call是参数列表，可以有多个对象，且apply和call是一次性传入参数，而bind可以分为多次传入。<br>bind 改变this指向后不会立即执行，而是返回一个永久改变this指向的函数；而apply 、call 则是立即执行当前函数 。</p></li></ul><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a<span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>  value<span class="token operator">:</span><span class="token number">123</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个参数：目标对象<br>第二个参数：需要定义的属性或方法的名字。<br>第三个参数：目标属性所拥有的特性。（descriptor）</p><h3 id="可枚举属性"><a href="#可枚举属性" class="headerlink" title="可枚举属性"></a>可枚举属性</h3><p>可枚举可以理解为是否可以被遍历被列举出来，可枚举性决定了这个属性能否被<strong>for…in</strong>查找遍历到。<br>js中基本包装类型的原型属性是不可枚举的（不可被 for…in… 遍历），比如：Boolean,Number和String三个的原型属性，或是 Boolean,Number值，都是不可枚举的，即是基本类型。基本包装类型还可以像引用类型一样访问它自带的一些方法，但是不能像引用类型那样自定义方法。</p><p>判断属性是否可枚举<br>1.<strong>for…in</strong><br>2.<strong>propertyIsEnumerable( )</strong> 方法返回一个布尔值，表示属性是否可以枚举</p><p>每个对象都有一个propertyIsEnumerable方法。该方法可以确定对象中的指定属性是否可以通过for…in循环枚举，但通过原型链继承的属性除外。如果对象不具有指定的属性，则此方法返回false。</p><h3 id="String-prototype"><a href="#String-prototype" class="headerlink" title="String.prototype"></a>String.prototype</h3><p>String.prototype用于为某字符串对象新增方法</p><h3 id="forEach、filter、map、some、every、find、findIndex、reduce"><a href="#forEach、filter、map、some、every、find、findIndex、reduce" class="headerlink" title="forEach、filter、map、some、every、find、findIndex、reduce"></a>forEach、filter、map、some、every、find、findIndex、reduce</h3><p>这里有一堆土豆，如果换成代码，可以表示如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> potatos <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'1001'</span><span class="token punctuation">,</span> <span class="token literal-property property">weight</span><span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'1002'</span><span class="token punctuation">,</span> <span class="token literal-property property">weight</span><span class="token operator">:</span> <span class="token number">80</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'1003'</span><span class="token punctuation">,</span> <span class="token literal-property property">weight</span><span class="token operator">:</span> <span class="token number">120</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'1004'</span><span class="token punctuation">,</span> <span class="token literal-property property">weight</span><span class="token operator">:</span> <span class="token number">40</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'1005'</span><span class="token punctuation">,</span> <span class="token literal-property property">weight</span><span class="token operator">:</span> <span class="token number">110</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'1006'</span><span class="token punctuation">,</span> <span class="token literal-property property">weight</span><span class="token operator">:</span> <span class="token number">60</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时把上面的重量（g）记录成一个数组</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> w <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">110</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="批量操作-foreach"><a href="#批量操作-foreach" class="headerlink" title="批量操作 foreach"></a>批量操作 foreach</h4><p>数组里所有元素的weight增加，修改原数组，无返回值<br>map可实现，但不修改原数组，返回新数组</p><pre class="line-numbers language-none"><code class="language-none">potatos.forEach(potato &#x3D;&gt; potato.weight +&#x3D; 20 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="生成原始数据的特征信息map"><a href="#生成原始数据的特征信息map" class="headerlink" title="生成原始数据的特征信息map"></a>生成原始数据的特征信息map</h4><p>map最适合做的事是映射，生成原始数据的特征信息的map</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">w <span class="token operator">=</span> potatos<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">potato</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> potato<span class="token punctuation">.</span>weight <span class="token operator">+=</span> <span class="token number">20</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//[ 70, 100, 140, 60, 130, 80 ]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="筛选过滤filter"><a href="#筛选过滤filter" class="headerlink" title="筛选过滤filter"></a>筛选过滤filter</h4><p>filter是滤波的意思 从名字上看，就知道筛选过滤这样的活是filter<br>返回一个新的对象数组，并不会改变原数组</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> bigOnes <span class="token operator">=</span> potatos<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">potato</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> potato<span class="token punctuation">.</span>weight <span class="token operator">></span> <span class="token number">100</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//[ &#123; id: '1003', weight: 120 &#125;, &#123; id: '1005', weight: 110 &#125; ]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="判断数组中有没有符合条件的时候some"><a href="#判断数组中有没有符合条件的时候some" class="headerlink" title="判断数组中有没有符合条件的时候some"></a>判断数组中有没有符合条件的时候some</h4><p>当只需要判断数组中有没有符合条件的时候（一个就行） 就需要我们的some方法登场了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> hasbig <span class="token operator">=</span> potatos<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token parameter">potato</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> potato<span class="token punctuation">.</span>weight <span class="token operator">></span> <span class="token number">100</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们的some小伙计，去土豆存放的仓库进行寻找，只要找到一个符合条件的，就回来报告true 所以并不会全部遍历，不做多余的活（性能优良）</p><h4 id="判断数组元素是否全符合every"><a href="#判断数组元素是否全符合every" class="headerlink" title="判断数组元素是否全符合every"></a>判断数组元素是否全符合every</h4><p>every对每一个元素执行一个callback，直到它找到一个使 callback 返回 false的元素（没那么大的土豆），就返回false，直到遍历完成也没有返回false的话，就返回true</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> allbig <span class="token operator">=</span> potatos<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token parameter">potato</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> potato<span class="token punctuation">.</span>weight <span class="token operator">></span> <span class="token number">100</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="寻找数组元素中一个符合的find"><a href="#寻找数组元素中一个符合的find" class="headerlink" title="寻找数组元素中一个符合的find"></a>寻找数组元素中一个符合的find</h4><p>来了一个顾客，想要一个大土豆 find自告奋勇，我去找给他</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> big <span class="token operator">=</span> potatos<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">potato</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> potato<span class="token punctuation">.</span>weight <span class="token operator">></span> <span class="token number">100</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//&#123; id: '1003', weight: 120 &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>find和some很类似，都是寻找符合条件的，有一个就可以 不过some进去搜罗了一圈回来报了个“有”（true），而find则把那个土豆抱了出来（返回第一个符合条件的对象）</p><h4 id="当需要知道所需元素的索引findIndex"><a href="#当需要知道所需元素的索引findIndex" class="headerlink" title="当需要知道所需元素的索引findIndex"></a>当需要知道所需元素的索引findIndex</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> i <span class="token operator">=</span> potatos<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">potato</span><span class="token operator">=></span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> potato<span class="token punctuation">.</span>weight <span class="token operator">></span> <span class="token number">100</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当需要知道所需元素的索引，就可以用findIndex，findIndex返回第一个符合条件的索引号</p><h4 id="递归累加reduce"><a href="#递归累加reduce" class="headerlink" title="递归累加reduce"></a>递归累加reduce</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> sum <span class="token operator">=</span> weight<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">sum<span class="token punctuation">,</span> w</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> w <span class="token operator">+</span> sum <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//460</span><span class="token comment">//并不会改变原表格</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>reduce()方法接收一个回调函数作为第一个参数，回调函数又接受四个参数，分别是；<br>1、previousValue &#x3D;&gt;初始值或上一次回调函数叠加的值；<br>2、currentValue &#x3D;&gt; 本次回调（循环）将要执行的值；<br>3、index&#x3D;&gt;“currentValue”的索引值；<br>4、arr &#x3D;&gt; 数组本身；<br>reduce()方法返回的是最后一次调用回调函数的返回值；能够实现递归累加</p><h3 id="常见数据类型检测的方式"><a href="#常见数据类型检测的方式" class="headerlink" title="常见数据类型检测的方式"></a>常见数据类型检测的方式</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>其中数组、对象、null都会被判断为Object，其他判断都正确</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>只能判断引用数据类型,不能判断基本数据类型</p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型,constructor就不能来判断数据类型了</p><h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h4><p>无论是Array,还是Date，所有数据类型。都是从对象衍生而来的。本质上，Array和Date还有Function啥的他们就是对象。虽然他们都被称为对象，对象也是有很多类型的。比如Date,他就是时间对象‘ [object Date] ’, Array,他就是数组对象‘[object Array]’等等。简而言之，js中所有的数据类型，都只是对象的一种类型。所以，js中有一句话叫，万物皆对象。而<strong>Object.prototype.toString() 这个函数作用就是，返回当前调用者的对象类型。</strong></p><p>因为Object.prototype.toString()返回的是调用者的类型。不论你toString()本身的入参写的是什么，在Object.prototype.toString()中，他的调用者永远都是Object.prototype；所以，在不加call()情况下，我们的出来的结果永远都是 ‘[object Object]’</p><h4 id="isNaN-检测数据是否是数字"><a href="#isNaN-检测数据是否是数字" class="headerlink" title="isNaN 检测数据是否是数字"></a>isNaN 检测数据是否是数字</h4><h4 id="Array-isArray-检测数据是否是数组"><a href="#Array-isArray-检测数据是否是数组" class="headerlink" title="Array.isArray()检测数据是否是数组"></a>Array.isArray()检测数据是否是数组</h4><h3 id="slice、splice、split"><a href="#slice、splice、split" class="headerlink" title="slice、splice、split"></a>slice、splice、split</h3><h4 id="slice-start-end"><a href="#slice-start-end" class="headerlink" title="slice(start,[end])"></a>slice(start,[end])</h4><p>slice(start,[end])方法：该方法是对数组进行部分截取，该方法返回一个新数组<br>参数start是截取的开始数组索引，end参数等于你要取的最后一个字符的位置值加上1（可选）。<br>包含了源函数从start到 end 所指定的元素，但是不包括end元素，比如a.slice(0,3)；<br>如果出现负数就把负数与长度相加后再划分。<br>slice中的负数的绝对值若大于数组长度就会显示所有数组<br>若参数只有一个，并且参数大于length，则为空。<br> 如果结束位置小于起始位置，则返回空数组<br> 返回的个数是end-start的个数<br>不会改变原数组</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token comment">/*console.log(arr.slice(3))//[4,5,6] 从下标为0的到3，截取3之后的数console.log(arr.slice(0,3))//[1,2,3] 从下标为0的地方截取到下标为3之前的数console.log(arr.slice(0,-2))//[1,2,3,4]console.log(arr.slice(-4,4))//[3,4]console.log(arr.slice(-7))//[1,2,3,4,5,6]console.log(arr.slice(-3,-3))// []console.log(arr.slice(8))//[]*/</span><span class="token comment">// 个人总结：slice的参数如果是正数就从左往右数，如果是负数的话就从右往左边数，</span><span class="token comment">// 截取的数组与数的方向一致，如果是2个参数则截取的是数的交集，没有交集则返回空数组</span><span class="token comment">// ps：slice也可以切割字符串，用法和数组一样，但要注意空格也算字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="splice-start-deletecount-item"><a href="#splice-start-deletecount-item" class="headerlink" title="splice(start,deletecount,item)"></a>splice(start,deletecount,item)</h4><p> start：起始位置<br> deletecount：删除位数<br>item：替换的item<br> 返回值为被删除的字符串<br>如果有额外的参数，那么item会插入到被移除元素的位置上。<br> splice:移除，splice方法从array中移除一个或多个数组，并用新的item替换它们。<br>举一个简单的例子</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> b<span class="token operator">=</span>a<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//['a', 'e', 'f', 'c']</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">//['b']</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//console.log("被删除的为：",a.splice(1, 1, 8, 9)); //被删除的为：2</span><span class="token comment">// console.log("a数组元素：",a); //1,8,9,3,4,5,6</span><span class="token comment">// console.log("被删除的为：", a.splice(0, 2)); //被删除的为：1,2</span><span class="token comment">// console.log("a数组元素：", a) //3,4,5,6</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"被删除的为："</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//插入 第二个数为0，表示删除0个  </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"a数组元素："</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment">//1,2,2,2,3,4,5,6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="split-字符串"><a href="#split-字符串" class="headerlink" title="split(字符串)"></a>split(字符串)</h4><p>string.split(separator,limit)：split方法把这个string分割成片段来创建一个字符串数组。<br>可选参数limit可以限制被分割的片段数量。<br>separator参数可以是一个字符串或一个正则表达式。<br>如果separator是一个空字符，会返回一个单字符的数组，不会改变原数组。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token string">"0123456"</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> b<span class="token operator">=</span>a<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//b=["0","1","2"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：String.split() 执行的操作与 Array.join 执行的操作是相反的。</p><h3 id="for-in、Object-keys和for-of"><a href="#for-in、Object-keys和for-of" class="headerlink" title="for in、Object.keys和for-of"></a>for in、Object.keys和for-of</h3><p><strong>for-in</strong><br>for … in是为遍历对象属性而构建的，<br>主要用于遍历对象的<strong>可枚举属性</strong>，包括自有属性、继承自原型的属性</p><p><strong>for-of</strong><br>es6 中添加的循环遍历语法；<br>支持遍历数组，类数组对象（DOM NodeList），字符串，Map 对象，Set 对象；<br>不支持遍历对象； 遍历后输出的结果为数组元素的值</p><p><strong>Object.keys()</strong> <br>对数组的遍历顺序和 for in 一致<br>此方法返回一个数组，元素均为对象自有可枚举的属性<br>Object.keys主要用于遍历对象自有的可枚举属性，不包括继承自原型的属性和不可枚举的属性</p><p><strong>Object.getOwnProperty</strong><br>此方法用于返回对象的自有属性，包括可枚举和不可枚举的属性</p><h2 id="var、function变量、函数提升"><a href="#var、function变量、函数提升" class="headerlink" title="var、function变量、函数提升"></a>var、function变量、函数提升</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">'global'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">'local'</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于函数内声明提升，所以上面的代码实际上是这样的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">'global'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> scope<span class="token punctuation">;</span>    <span class="token comment">//变量声明提升到函数顶部</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>    scope <span class="token operator">=</span> <span class="token string">'local'</span><span class="token punctuation">;</span>    <span class="token comment">//变量初始化依然保留在原来的位置</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过这样变形之后，答案就就非常明显了。由于scope在第一个console.log(scope)语句之前就已经定义了，但是并没有赋值，因此此时scope的指是undefined.第二个console.log(scope)语句之前，scope已经完成赋值为’local’，所以输出的结果是local。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//函数表达式为变量声明，变量声明提升优先级较低</span><span class="token keyword">function</span> <span class="token function">getName</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//函数声明，函数声明提升优先级更高</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们来分析一下，这个例子涉及到了变量声明提升和函数声明提升。正如前面说到的函数声明提升，函数声明function getName(){}的声明会被提前到顶部。而函数表达式var getName &#x3D; function(){}则表现出变量声明提升。因此在这种情况下，getName也是一个变量，因此这个变量的声明也将提升到底部，而变量的赋值依然保留在原来的位置。<strong>需要注意的是，函数优先，虽然函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量</strong>。因此上面的函数可以转换成下面的样子:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//函数声明提升到顶部</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> getName<span class="token punctuation">;</span>    <span class="token comment">//变量声明提升</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//变量赋值依然保留在原来的位置</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 最终输出：2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以最终的输出结果是：2。在原来的例子中，函数声明虽然是在函数表达式后面，但由于函数声明提升到顶部，因此后面getName又被函数表达式的赋值操作给覆盖了，所以输出2。</p><h2 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h2><h3 id="parseInt方法"><a href="#parseInt方法" class="headerlink" title="parseInt方法"></a>parseInt方法</h3><h3 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h3><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><h3 id="异步Promise、Generator和Async"><a href="#异步Promise、Generator和Async" class="headerlink" title="异步Promise、Generator和Async"></a>异步Promise、Generator和Async</h3><h3 id="数组遍历方法for-in、Object-keys"><a href="#数组遍历方法for-in、Object-keys" class="headerlink" title="数组遍历方法for in、Object.keys()"></a>数组遍历方法for in、Object.keys()</h3><h3 id="Symbol-bigInt"><a href="#Symbol-bigInt" class="headerlink" title="Symbol\bigInt"></a>Symbol\bigInt</h3><h3 id="数据结构Set和Map"><a href="#数据结构Set和Map" class="headerlink" title="数据结构Set和Map"></a>数据结构Set和Map</h3><h3 id="class定义类"><a href="#class定义类" class="headerlink" title="class定义类"></a>class定义类</h3><h3 id="reflect对象"><a href="#reflect对象" class="headerlink" title="reflect对象"></a>reflect对象</h3><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。</p><ol><li><p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</p></li><li><p>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</p></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//Reflect.defineProperty会返回false来代表此次操作失败</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'鲨鱼辣椒'</span> <span class="token punctuation">&#125;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// 25</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// 25</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'鲨鱼辣椒'</span> <span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 鲨鱼辣椒</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 鲨鱼辣椒</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Proxy可以最大限度的弥补Object.defineProperty带来的缺点，而Proxy也不仅仅只能代理对象，还可以代理数组等其它对象。代理可以捕获13种不同的操作，而每种操作都会有一个所对应的ReflectApi，这就使Proxy对象可以方便的调用对应的Reflect方法来完成默认行为。我们前面已经对Proxy与Reflect进行了讲解，现在就让它们结合起来吧</p><h3 id="let-const-var"><a href="#let-const-var" class="headerlink" title="let const var"></a>let const var</h3><p>var ——ES5 变量声明方式变量未赋值时，变量undefined（为使用声明变量时也为undefined）<br>作用域——var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用</p><p>let——ES6变量声明方式<br>在变量为声明前直接使用会报错<br>作用域——let为块作用域——通常let比var 范围要小<br>let禁止重复声明变量，否则会报错；var可以重复声明</p><p>const——ES6变量声明方式</p><ol><li>const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改该常量的值</li><li>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动</li></ol><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>暂时性死区：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p><p>暂时性死区和不能变量提升的意义在于: 为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// 声明</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  tmp <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span> <span class="token comment">// 报错 因为本区域有tmp声明变量</span>  <span class="token keyword">let</span> tmp<span class="token punctuation">;</span> <span class="token comment">// 绑定if这个块级的作用域 不能出现tmp变量</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p><strong>概念</strong>：多个作用域对象连续引用形成的链式结构。</p><p><strong>使用方面解释</strong>：当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域，如果在全局作用域里仍然找不到该变量，它就会直接报错。</p><p><strong>存储方面解释</strong>：作用域链在JS内部中是以数组的形式存储的，数组的第一个索引对应的是函数本身的执行期上下文，也就是当前执行的代码所在环境的变量对象，下一个索引对应的空间存储的是该对象的外部执行环境，依次类推，一直到全局执行环境</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">200</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//100</span><span class="token comment">// fun函数局部作用域中没有变量a，于是从它的上一级，也就是全局作用域中找，</span><span class="token comment">//在全局中a被赋值为100，于是输出100</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token comment">//200 fun函数局部作用域中有变量b，并且它被赋值为了200，输出200</span><span class="token punctuation">&#125;</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span>   <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">//10，而不是20; 函数的作用域是在函数定义的时候就被决定了，与函数在哪里被调用无关</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">show</span><span class="token punctuation">(</span>fun<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于变量的查找是沿着作用域链来实现的，所以也称作用域链为变量查找的机制。是不是很好理解，这里再来补充一点作用域的作用</p><ul><li><p>作用域最为重要的一点是安全。变量只能在特定的区域内才能被访问，外部环境不能访问内部环境的任何变量和函数，即可以向上搜索，但不可以向下搜索， 有了作用域我们就可以避免在程序其它位置意外对某个变量做出修改导致程序发生事故。</p></li><li><p>作用域能够减轻命名的压力。我们可以在不同的作用域内定义相同的变量名，并且这些变量名不会产生冲突。。</p></li></ul><h4 id="为什么let在编译后实际还是var？"><a href="#为什么let在编译后实际还是var？" class="headerlink" title="为什么let在编译后实际还是var？"></a>为什么let在编译后实际还是var？</h4><p><strong>原因：</strong></p><ol><li>let 和 const 是 ES6 新增的变量申明关键字， 和 var 的主要区别在于作用域的不同，var 支持全局作用域和函数作用域，而 let 和 const 是块作用域。Babel 使用 babel-plugin-transform-block-scoping 插件完成 let 到 var 的转换，本质是块作用域到函数作用域或全局作用域的转换。</li><li>Babel 在生成 AST 之后，定义了一个访问者（visitor），用于遍历 AST 的过程中，根据语法规则生成作用域对象(Scope)，该对象中定义了该作用域下绑定的变量，这些变量是否被引用以及每个引用具体的路径。这些信息是后续修改作用域以及变量更换绑定的基础。</li><li>let 直接变为 var 很容易导致语义变化，需要结合作用域和上下文来进行判断，如果变成 var 后，和同层作用域的变量名称发生冲突，可以修改名称解决。如果 let 被内层作用域的方法引用，则需要修改代码，形成闭包。</li><li>babel-plugin-transform-block-scoping 插件是 Babel 中负责块级作用域转换的插件，实现了收集作用域下变量，判断是否存在闭包，let 节点修改等功能。我们在自己编写插件的时候，最好能多看几个 Babel 的原生插件，不仅可以了解 Babel 编译的原理，还可以学一些 AST 操作的方法。</li></ol><p><strong>如何变化</strong></p><ol><li>let 处于全局作用域，那么 let 直接变成 var。</li><li>let 处于块作用域，那就要判断该变量升级至上级的函数作用域或者全局作用域后，是否会与同一作用域的变量发生重名现象，如果重名，那就换个变量名。同时修改所有引用这个变量的代码。</li><li>let 处于循环语句中，形成类似闭包的效果，此时需要将循环内部的方法转换为立即执行函数的写法，利用闭包的特性保存循环次数。</li></ol><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>可以看出，定义箭头函在数语法上要比普通函数简洁得多。箭头函数省去了function关键字，采用箭头&#x3D;&gt;来定义函数。</p><p>关于箭头函数的参数：① 如果箭头函数没有参数，直接写一个空括号即可。② 如果箭头函数的参数只有一个，也可以省去包裹参数的括号。③ 如果箭头函数有多个参数，将参数依次用逗号(,)分隔，包裹在括号中即可。</p><p>① 如果箭头函数的函数体只有一句代码，就是简单返回某个变量或者返回一个简单的JS表达式，可以省去函数体的大括号{ }。</p><p>② 如果箭头函数的函数体只有一句代码，就是返回一个对象，可以像下面这样写</p><p>③ 如果箭头函数的函数体只有一条语句并且不需要返回值（最常见是调用一个函数），可以给这条语句前面加一个void关键字</p><p>区别：</p><ul><li>语法更加简洁、清晰。箭头函数的定义要比普通函数定义简洁、清晰得多，很快捷。</li><li>箭头函数不会创建自己的this。箭头函数没有自己的this，它会捕获自己在定义时（注意，是定义时，不是调用时）所处的外层执行环境的this，并继承这个this值。所以，箭头函数中this的指向在它被定义的时候就已经确定了，之后永远不会改变。</li><li>箭头函数继承而来的this指向永远不变。call()&#x2F;.apply()&#x2F;.bind()无法改变箭头函数中this的指向.call()&#x2F;.apply()&#x2F;.bind()方法可以用来动态修改函数执行时this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数this的指向，虽然这么做代码不会报错。</li><li>箭头函数不能作为构造函数使用。因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，</li><li>箭头函数没有自己的arguments</li><li>箭头函数没有原型prototype</li><li>箭头函数不能用作Generator函数，不能使用yeild关键字</li></ul><h2 id="new做了什么"><a href="#new做了什么" class="headerlink" title="new做了什么"></a>new做了什么</h2><ol><li>创建一个空对象</li><li>this指向这个对象</li><li>执行构造函数的语句</li><li>返回该对象</li></ol><h2 id="js继承"><a href="#js继承" class="headerlink" title="js继承"></a>js继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>将父类的实例作为子类的原型</p><p>优点</p><ul><li>父类方法可以复用<br>缺点</li><li>父类的所有引用属性（info）会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响</li><li>子类型实例不能给父类型构造函数传参</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>isShow <span class="token operator">=</span> <span class="token boolean">true</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>info <span class="token operator">=</span> <span class="token punctuation">&#123;</span>       <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"yhd"</span><span class="token punctuation">,</span>       <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getInfo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>isShow<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> Child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Child1<span class="token punctuation">.</span>info<span class="token punctuation">.</span>gender <span class="token operator">=</span> <span class="token string">"男"</span><span class="token punctuation">;</span>Child1<span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &#123;name: "yhd", age: 18, gender: "男"&#125;</span><span class="token keyword">let</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child2<span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &#123;name: "yhd", age: 18, gender: "男"&#125;</span>child2<span class="token punctuation">.</span>isShow <span class="token operator">=</span> <span class="token boolean">false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>isShow<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="盗用构造函数继承"><a href="#盗用构造函数继承" class="headerlink" title="盗用构造函数继承"></a>盗用构造函数继承</h3><ul><li>先定义一个父构造函数(this指向为window)</li><li>再定义一个子构造函数(this指向为new出的实例化对象)</li><li>子构造函数通过call()改变父的this指向继承父构造函数属性</li></ul><p>优点</p><ul><li>可以在子类构造函数中向父类传参数</li><li>父类的引用属性不会被共享<br>缺点</li><li>不能继承原型属性，无法实现函数复用，所有方法都只能放在构造函数中。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>info <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"yhd"</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">19</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child1<span class="token punctuation">.</span>info<span class="token punctuation">.</span>gender <span class="token operator">=</span> <span class="token string">"男"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;name: "yhd", age: 19, gender: "男"&#125;;</span><span class="token keyword">let</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;name: "yhd", age: 19&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承综合了<strong>原型链继承</strong>和<strong>盗用构造函数继承</strong>(构造函数继承)，将两者的优点结合了起来，</p><p>基本的思路就是使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性，这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name   <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"yellow"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 继承父类属性</span>   <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 继承父类方法</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"yhd"</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"pink"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["red", "blue", "yellow", "pink"]</span>child1<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 19</span>child1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "yhd"</span><span class="token keyword">let</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"wxb"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ["red", "blue", "yellow"]</span>child2<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span>child2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "wxb"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面例子中，Parent构造函数定义了name，colors两个属性，接着又在他的原型上添加了个sayName()方法。Child构造函数内部调用了Parent构造函数，同时传入了name参数，同时Child.prototype也被赋值为Parent实例，然后又在他的原型上添加了个sayAge()方法。这样就可以创建 child1，child2两个实例，让这两个实例都有自己的属性，包括colors，同时还共享了父类的sayName方法</p><p>优点</p><ul><li>父类的方法可以复用</li><li>可以在Child构造函数中向Parent构造函数中传参</li><li>父类构造函数中的引用属性不会被共享</li></ul><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>对参数对象的一种浅复制</p><p>优点：</p><ul><li>父类方法可复用<br>缺点：</li><li>父类的引用会被所有子类所共享</li><li>子类实例不能向父类传参</li><li>ES5的Object.create()方法在只有第一个参数时，与这里的objectCopy()方法效果相同</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">objectCopy</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">function</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token class-name">Fun</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//此处的objectCopy可以改用 ES5 里面的 Object.create 方法</span><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"yhd"</span><span class="token punctuation">,</span>  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>  <span class="token literal-property property">friends</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"jack"</span><span class="token punctuation">,</span> <span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token string">"rose"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function-variable function">sayName</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token function">objectCopy</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"wxb"</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"lily"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// wxb</span><span class="token keyword">let</span> person2 <span class="token operator">=</span> <span class="token function">objectCopy</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>person2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"gsr"</span><span class="token punctuation">;</span>person2<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"kobe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "gsr"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["jack", "tom", "rose", "lily", "kobe"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</p><p>虽然其优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。</p><p><strong>设计模式：装饰器模式</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">objectCopy</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">function</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token class-name">Fun</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token function">objectCopy</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>  clone<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> clone<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>     <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"yhd"</span><span class="token punctuation">,</span>     <span class="token literal-property property">friends</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"rose"</span><span class="token punctuation">,</span> <span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token string">"jack"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"lily"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yhd</span><span class="token keyword">let</span> person2 <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["rose", "tom", "jack", "lily"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>寄生式继承+组合继承</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">objectCopy</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">function</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token class-name">Fun</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> prototype <span class="token operator">=</span> <span class="token function">objectCopy</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建对象</span>  <span class="token keyword">let</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//上一句可以用Object.create来代替</span>  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> child<span class="token punctuation">;</span> <span class="token comment">// 增强对象</span>  <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span> <span class="token comment">// 赋值对象</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"rose"</span><span class="token punctuation">,</span> <span class="token string">"lily"</span><span class="token punctuation">,</span> <span class="token string">"tom"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">inheritPrototype</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"yhd"</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child1<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 23</span>child1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yhd</span>child1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["rose", "lily", "tom", "jack"]</span><span class="token keyword">let</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"yl"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span>child2<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 22</span>child2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yl</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["rose", "lily", "tom"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：</p><ul><li>只调用一次父类构造函数</li><li>Child可以向Parent传参</li><li>父类方法可以复用</li><li>父类的引用属性不会被共享</li></ul><p>寄生式组合继承可以算是引用类型继承的最佳模式</p><h3 id="ES6-的-extends-关键字"><a href="#ES6-的-extends-关键字" class="headerlink" title="ES6 的 extends 关键字"></a>ES6 的 extends 关键字</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token punctuation">&#125;</span>  <span class="token comment">// 原型方法</span>  <span class="token comment">// 即 Person.prototype.getName = function() &#123; &#125;</span>  <span class="token comment">// 下面可以简写为 getName() &#123;...&#125;</span>  <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Person:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Gamer</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> juiceice <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gamer</span><span class="token punctuation">(</span><span class="token string">'juiceice'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>juiceice<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 成功访问到父类的方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><p>对象里的属性分为两种：数据属性 和 访问器属性。首先我们看看数据属性。</p><p><strong>数据属性</strong></p><ol><li>[[<strong>Configurable</strong>]]：翻译：adj. 可配置的；结构的 表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特 性都是 true，如前面的例子所示。</li><li>[[<strong>Enumerable</strong>]]：翻译：adj. 可列举的；可点数的 表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对 象上的属性的这个特性都是 true，如前面的例子所示。</li><li>[[<strong>Writable</strong>]]：翻译：adj. 可写的，能写成文的 表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的 这个特性都是 true，如前面的例子所示。</li><li>[[<strong>Value</strong>]]：翻译：值 包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性 的默认值为 undefined</li></ol><p><strong>访问器属性</strong></p><ol><li>[[<strong>Configurable</strong>]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特 性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</li><li>[[<strong>Enumerable</strong>]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对 象上的属性的这个特性都是 true。</li><li>[[<strong>Get</strong>]]：获取函数，在读取属性时调用。默认值为 undefined。</li><li>[[<strong>Set</strong>]]：设置函数，在写入属性时调用。默认值为 undefined。</li></ol><h2 id="js事件流"><a href="#js事件流" class="headerlink" title="js事件流"></a>js事件流</h2><p>事件流一共由三个阶段分别是<br>1.捕获阶段<br>2.目标阶段<br>3.冒泡阶段</p><p>通俗一点来说就是一个事件被触发时，浏览器会自动从用户操作标签外的最上级标签逐渐向里检查是否有相同事件，如果有则触发，如果没有则继续向下检查直到用户操作的标签，这过程称为捕获，此时浏览器会继续由用户操作标签继续向上级标签检查，如果有相同事件则触发，如果没有则继续向上检查直到最上级元素为止，此过程称为冒泡。</p><p>从外向内找监听函数，叫做事件捕捉<br>从内向外找监听函数，叫做事件冒泡</p><p><strong>取消冒泡 e.stopPropagation()</strong><br>捕获是不可取消的，但是冒泡可以取消。所有冒泡皆可取消，默认动作有的可以取消有的不能取消。e.stopPropagation() 可以中断冒泡，浏览器不再向上走了。</p><p>事件委托<br>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'li'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// some code</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，click事件的监听函数定义在节点，但是实际上，它处理的是子节点的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p><p><strong>优点</strong><br>省监听数（内存）<br>可以监听动态元素</p><h2 id="js的事件循环"><a href="#js的事件循环" class="headerlink" title="js的事件循环"></a>js的事件循环</h2><p><img src="/zyhxwing/../images/JavaScript/1363_1.png" alt="js事件循环"></p><p>S是单线程的，但是我们在写代码的时候，会有同步执行的代码和异步执行的代码。EventLoop就是一种解决异步回调的一种机制。具体的解决办法就是使用一个执行栈和事件队列，事件队列又分为宏任务队列和微任务队列。简单的来讲，就是把代码从上到下，会把同步任务压入到执行栈，遇到异步的任务，根据异步任务的类型，放入不同的事件队列，交给其它线程进行处理。如果执行栈空的话，就从事件队列当中取出结果，放入到执行栈中执行并执行。Event Loop 的每一次循环称为一个tick，具体是先拿出一个宏任务，然后检查它里面的微任务，如果有的话，就执行所有的微任务，结束之后，进行一次渲染。再拿出一个宏任务，按照刚刚的过程继续进行</p><h3 id="宏任务MacroTask"><a href="#宏任务MacroTask" class="headerlink" title="宏任务MacroTask"></a>宏任务MacroTask</h3><p>script代码、settimeout、promise、async、setInterval、ajax、dom监听、UI Rendering</p><h3 id="微任务MicroTask"><a href="#微任务MicroTask" class="headerlink" title="微任务MicroTask"></a>微任务MicroTask</h3><p>promise的回调函数（then、catch、finally）、await、queueMicrotask、MutationObserver的Api</p><h3 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick"></a>Vue.nextTick</h3><p>与此同时，针对于vue的mvvn框架，在修改数据之后，视图并不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。<br>Vue.nextTick将回调函数放到微任务或者宏任务当中以延迟它地执行顺序</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//改变数据</span>vm<span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">'changed'</span><span class="token comment">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">// 并不会得到'changed'</span><span class="token comment">//这样可以，nextTick里面的代码会在DOM更新后执行Vue.nextTick(function()&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">//可以得到'changed'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="settimeout倒计时为什么会出现误差"><a href="#settimeout倒计时为什么会出现误差" class="headerlink" title="settimeout倒计时为什么会出现误差"></a>settimeout倒计时为什么会出现误差</h3><p>setTimeout作为异步任务，在实现倒计时功能的时候，除了执行我们功能的实现代码，还会有主线程对任务队列的读取及执行等过程，这些过程也需要耗费一些时间，所以会因为event loop的机制出现些许误差。</p><h3 id="为什么使用setTimeout实现倒计时，而不是setInterval"><a href="#为什么使用setTimeout实现倒计时，而不是setInterval" class="headerlink" title="为什么使用setTimeout实现倒计时，而不是setInterval?"></a>为什么使用setTimeout实现倒计时，而不是setInterval?</h3><p>setInterval指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。<br>为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间。</p><h3 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h3><p>MutationObserver能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.</p><ul><li><p>监视 DOM 变动的接口<br>当监视的 DOM 发生变动时 MutationObserver 将收到通知并触发事先设定好的回调函数。</p></li><li><p>类似于事件，但是异步触发<br>添加监视时，MutationObserver 上的 observer 函数与 addEventListener 有相似之处，但不同于后者的同步触发，MutationObserver 是异步触发，此举是为了避免 DOM 频繁变动导致回调函数被频繁调用，造成浏览器卡顿。</p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="queueMicrotask"><a href="#queueMicrotask" class="headerlink" title="queueMicrotask"></a>queueMicrotask</h3><p>queueMicrotask()的作用是创建一个微任务</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">self<span class="token punctuation">.</span><span class="token function">queueMicrotask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 函数的内容</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">queueMicrotask</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token comment">//等同于Promise.resolve().then(fn);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果和使用Promise一样的，都是将任务加入微任务队列<br>待宏任务结束后依次执行</p><h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><p>你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。requestAnimationFrame(rAF) 需要传入一个回调函数作为参数，同时该回调函数会在浏览器下一次重绘之前执行。</p><p>requestAnimationFrame(rAF) 的回调有两个特征：<br>在重新渲染前调用。<br>很可能在宏任务之后不调用。</p><p>我们来分析一下，为什么要在重新渲染前去调用？因为 rAF 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这显然是不合理的。<br>rAF在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。下面我用一个 setTimeout的例子来对比。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">"red"</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">"blue"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//这个结果是非常不可控的，如果这两个 Task 之间正好遇到了浏览器认定的渲染机会，那么它会重绘，否则就不会。由于这俩宏任务的间隔周期太短了，所以很大概率是不会的。</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">let</span> <span class="token function-variable function">req</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  i<span class="token operator">--</span>  <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">"red"</span>    <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">"blue"</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">req</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">req</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//浏览器会非常规律的把这 10 组也就是 20 次颜色变化绘制出来，</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="js异步方法"><a href="#js异步方法" class="headerlink" title="js异步方法"></a>js异步方法</h2><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>是异步操作最基本的方法，比如AJAX回调，回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。此外它不能使用try catch捕获错误，不能之间return。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>包装了一个异步调用并生成一个Promise实例，当异步调用返回的时候根据调用的结果分别调用实例化时传入的resolve和reject方法，then接收到对应的数据，做出相应的处理。Promise不仅能够捕获错误，而且也能很好地解决了回调地狱的问题，缺点是无法取消Promise，错误需要通过回调函数捕获。，Promise有四种状态：<code>pending:</code>初始状态, 非<code>fulfilled</code>或<code>rejected</code>. <code>fulfilled:</code>成功的操作. <code>rejected:</code>失败的操作，<code>settled:</code> <code>Promise</code>已被<code>fulfilled</code>或<code>rejected</code>，且不是<code>pending</code></p><p><strong>Promise.then方法的链式调用</strong></p><ul><li>前一个then里面返回的字符串，会被下一个then方法接收到。但是没有意义；</li><li>前一个then里面返回的Promise对象，并且调用resolve的时候传递了数据，数据会被下一个then接收到</li><li>前一个then里面如果没有调用resolve，则后续的then不会接收到任何值</li></ul><p><strong>Promise.all方法</strong><br>要实现 Promise.all,首先我们需要知道 Promise.all 的功能：</p><ol><li>如果传入的参数是一个空的可迭代对象，那么此promise对象回调完成(resolve)，只有此情况，是同步执行的，其它都是异步返回的。</li><li>如果传入的参数不包含任何 promise，则返回一个异步完成.</li></ol><p>promises 中所有的promise都“完成”时或参数中不包含 promise 时回调完成。</p><ol><li>如果参数中有一个promise失败，那么Promise.all返回的promise对象失败</li><li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</li></ol><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>函数是ES6提供的一种异步编程解决方案，Generator函数是一个状态机，封装了多个内部状态，可暂停函数，yield可暂停，next方法可启动，每次返回的是yield后的表达式结果。优点是异步语义清晰，缺点是手动迭代Generator函数很麻烦，实现逻辑优点。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行 Generator 会返回一个Object,而不是像普通函数返回return 后面的值</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &#123; value: 7, done: false &#125;</span><span class="token comment">//调用指针的 next 方法,会从函数的头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式或return语句暂停,也就是执行yield 这一行</span><span class="token comment">// 执行完成会返回一个 Object,</span><span class="token comment">// value 就是执行 yield 后面的值,done 表示函数是否执行完毕</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &#123; value: undefined, done: true &#125;</span><span class="token comment">// 因为最后一行 return y 被执行完成,所以done 为 true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><p>是于Promise实现的，async&#x2F;awt使得异步代码看起来像同步代码，所以优点是使用方法清晰明了，缺点是await将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了await会导致性能上的降低，代码没有依赖性的话，完全可以使用Promise.all的方式。</p><p>1）async&#x2F;await 就是 Generator 的语法糖，使得异步操作变得更加方便<br>2）async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成await<br>3）async 是 Generator 的语法糖，这个糖体现在这几个方面：</p><ul><li>async函数内置执行器，函数调用之后，会自动执行，输出最后结果，而Generator需要调用next或者配合co模块使用</li><li>更好的语义，async和await，比起星号和yield，语义更清楚了，async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果</li><li>更广的适用性，co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值</li><li>返回值是Promise，async函数的返回值是 Promise 对象，Generator的返回值是 Iterator，Promise 对象使用起来更加方便</li></ul><p>4）<strong>async&#x2F;await 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里</strong></p><h2 id="异步网络请求xhr、ajax、fetch与axios"><a href="#异步网络请求xhr、ajax、fetch与axios" class="headerlink" title="异步网络请求xhr、ajax、fetch与axios"></a>异步网络请求xhr、ajax、fetch与axios</h2><p>现代浏览器，最开始与服务器交换数据，都是通过 XMLHttpRequest 对象。它可以使用JSON、XML、HTML和text文本等格式发送和接收数据。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>XMLHttpRequest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// model browser</span>  xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>ActiveXObject<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// IE 6 and older</span>  xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">'Microsoft.XMLHTTP'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//创建xhr对象</span>xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment">//调用xhr.open()函数</span><span class="token comment">//设置Content-Type属性</span>xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token comment">//调用xhr.send()函数</span>xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//监听xhr.onreadStatechange()事件</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 处理响应</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 请求正常</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 处理响应</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 请求遇到一些问题，处理异常</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 还处于未准备好的状态</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 通信错误的事件中（例如服务器宕机）</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Caught Exception: '</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>description<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：</p><p>不重新加载页面的情况下更新网页<br>在页面已加载后从服务器请求&#x2F;接收数据<br>在后台向服务器发送数据。<br>缺点：</p><p>使用起来也比较繁琐，需要设置很多值。<br>早期的IE浏览器有自己的实现，这样需要写兼容代码。</p><p>xhr的readyState，状态码<br>0 对象被创建但没有使用open方法<br>1 open方法已经被调用<br>2 send方法已经被调用<br>3 数据接受，response属性已经包含部分数据<br>4 ajax请求完成</p><ol start="2"><li><p>jQuery ajax<br>为了更快捷的操作 DOM，并且规避一些浏览器兼容问题，产生了 jQuery 。它里面的 AJAX 请求也兼容了各浏览器，可以有简单易用的方法 $.get, $.post 。简单点说，就是对 XMLHttpRequest 对象的封装。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>  <span class="token literal-property property">url</span><span class="token operator">:</span> url<span class="token punctuation">,</span>   <span class="token literal-property property">data</span><span class="token operator">:</span> data<span class="token punctuation">,</span>  <span class="token literal-property property">dataType</span><span class="token operator">:</span> dataType<span class="token punctuation">,</span>  <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function-variable function">error</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：<br>XHR  JSONP<br>缺点：<br>如果有多个请求，并且有依赖关系的话，容易形成回调地狱。<br>本身是针对MVC的编程，不符合现在前端MVVM的浪潮。<br>ajax是jQuery中的一个方法。如果只是要使用ajax却要引入整个jQuery非常的不合理。</p></li><li><p>fetch<br>Fetch API提供了一个 JavaScript 接口，用于访问和操作HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p></li></ol><p>fetch 是底层API，代替 XHR ，可以轻松处理各种格式，非文本化格式。可以很容易的被其他技术使用，例如 Service Workers 。但是想要很好的使用 fetch ，需要做一些封装处理。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://example.com/movies.json'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">myJson</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myJson<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：跨域的处理</p><p>在配置中，添加mode： ‘no-cors’就可以跨域了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/users.json'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'post'</span><span class="token punctuation">,</span>     <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">'no-cors'</span><span class="token punctuation">,</span>    <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* handle response */</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缺点：</p><p>fetch 只对网络请求报错，对 400 ， 500 都当做成功的请求，需要封装去处理<br>fetch 默认不会带 cookie ，需要添加配置项。<br>fetch 不支持 abort ，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费。<br>fetch 没有办法原生监测请求的进度，而 XHR 可以。<br>请注意， fetch 规范与 jQuery.ajax() 主要有三点不同，牢记：</p><p>当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject ， 即使该 HTTP 响应的状态码是 404 或 500 。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject 。<br>fetch() 不会接受跨域 cookies ；你也不能使用 fetch() 建立起跨域会话。其他网站的 Set-Cookie 头部字段将会被无视。<br>fetch 不会发送 cookies 。除非你使用了 credentials 的 初始化选项。（自2017年8月25日以后，默认的 credentials 策略变更为 same-origin 。Firefox也在61.0b13版本中，对默认值进行修改）<br>4. axios<br>axios 是一个基于 promise 的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生 XMLHttpRequest 的封装，只不过它是 Promise 的实现版本，符合最新的ES规范。</p><p>这是官方的并发案例:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">getUserAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/user/12345'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">function</span> <span class="token function">getUserPermissions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/user/12345/permissions'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> axios<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">getUserAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getUserPermissions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>axios<span class="token punctuation">.</span><span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">acct<span class="token punctuation">,</span> perms</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Both requests are now complete</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>axios是尤雨溪大神推荐使用的,</p><p>优点：</p><p>XMLHttpRequests<br>node.js<br>Promise API<br>JSON<br>XSRF<br>缺点：</p><p>只持现代浏览器</p><h2 id="JS的arugments"><a href="#JS的arugments" class="headerlink" title="JS的arugments"></a>JS的arugments</h2><p>在函数调用的时候，浏览器每次都会传递进两个隐式参数：<br>一个是函数的上下文对象this，另一个则是封装实参的类数组对象arguments。</p><p>1、arguments是一个类数组对象，用来存储实参；具有length、callee等属性；可以用arguments[0]这个形式访问实参；可以转换为真实数组。<br>2、arguments和函数相关联，其只有在函数执行时可用，不能显式创建。<br>3、arguments可以用来遍历参数；通过callee实现递归；也可以模拟函数重载。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 可以使用slice来将arguments转换为真实数组</span>    <span class="token keyword">var</span> args1 <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> args2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 也可以使用Array.from()方法或者扩展运算符来将arguments转换为真实数组</span>    <span class="token keyword">var</span> args3 <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> args4 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">f5</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JS的原型链"><a href="#JS的原型链" class="headerlink" title="JS的原型链"></a>JS的原型链</h2><p>什么是原型：任何对象实例都有一个原型，也叫原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的 prototype 指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有 prototype，只有方法才有 prototype。</p><p>什么是原型链：<strong>原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</strong>当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的__proto__中查找，也就是构造函数的显式原型prototype中查找，如果构造函数的显式原型prototype中也没有该属性，因为构造函数的显式原型prototype也是对象，也有__proto__，那么会去它的__proto__指向的另一个显式原型prototype中查找，一直到null，如果没有则返回undefined</p><ul><li><p>所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型)</p></li><li><p>所有函数除了有_proto_属性之外还拥有prototype属性（显式原型）</p></li></ul><h2 id="JS-set、map、weakset、weakmap区别"><a href="#JS-set、map、weakset、weakmap区别" class="headerlink" title="JS set、map、weakset、weakmap区别"></a>JS set、map、weakset、weakmap区别</h2><p>共同点：<br>他们都是构造函数</p><p>不同点：<br>1、weakset、set不允许有重复的数据，set可以存储原始值和对象引用，存储的数据必须是唯一值<br>2、weakset是弱集合，存储的数据只能是对象，对对象的引用是弱引用；在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收；不可枚举<br>3、map表示字典，用键值对的形式存放数据，键和值可以是原始值和对象引用<br>4、weakmap是弱字典，以键值对形式存放，键只能是对象，对对象的引用是弱引用；在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收；不可枚举<br>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的；所以不容易造成内存泄漏。</p><h2 id="js-垃圾回收机制"><a href="#js-垃圾回收机制" class="headerlink" title="js 垃圾回收机制"></a>js 垃圾回收机制</h2><p>我们知道，程序运行中会有一些垃圾数据不再使用，需要及时释放出去，如果我们没有及时释放，这就是内存泄露。JavaScript 是一门具有自动垃圾收集机制的编程语言，由执行环境负责在代码执行时管理内存。JS 中的垃圾数据都是由垃圾回收（Garbage Collection，缩写为 GC）器自动回收的，不需要手动释放。JS 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，观察对象是否可被访问，然后按照固定的时间间隔周期性的删除掉那些不可访问的对象即可。</p><p>常见的垃圾回收方法：1）引用计数方法；2）标记清除方法。</p><p><strong>1）引用计数</strong><br>引用计数就是给一个占用物理空间的对象附加一个引用计数器，当有其它对象引用这个对象时，这个对象的引用计数加一，反之解除时就减一，当该对象引用计数为 0 时就会被回收。如果出现循环引用，则一直不会被回收，还是会造成内存泄漏。</p><p>解决办法：及时销毁绑定的事件、使用弱引用 weakMap、weakSet。</p><p><strong>2）标记清除方法。</strong></p><p>V8 中主垃圾回收器就采用标记清除法进行垃圾回收。主要流程如下：<br>标记：遍历调用栈，看老生代区域堆中的对象是否被引用，被引用的对象标记为活动对象，没有被引用的对象（待清理）标记为垃圾数据。<br>清除：将所有垃圾数据清理掉。</p><p><img src="/zyhxwing/../images/JavaScript/1365_1.png" alt="标记清除方法"></p><p>垃圾回收算法垃圾回收的实现简单分为以下三个步骤：<br><strong>1）可访问性</strong><br>从 GC Roots 对象出发，遍历 GC Root 中的所有对象：<br>a、可访问对象：通过 GC Root 遍历到的对象，我们就认为该对象是可访问的（reachable），那么必须保证这些对象应该在内存中保留。<br>b、不可访问对象：通过 GC Roots 没有遍历到的对象，则是不可访问的（unreachable），并会对其做上标记，那么这些不可访问的对象就可能被回收。</p><p>GC Root 有很多，通常包括了以下几种 (但是不止于这几种)：全局的 window 对象（位于每个 iframe 中）；文档 DOM 树，可以通过遍历文档到达的所有原生 DOM 节点组成；存放栈上变量。</p><p><strong>2）回收不可访问对象所占据的内存</strong><br>在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p><p><strong>3）内存整理</strong><br>频繁回收对象后，内存中就会存在大量不连续空间，称为内存碎片。当出现了大量的内存碎片之后，如果需要分配较大的连续内存时，就会出现内存不足的情况，所以最后一步需要整理这些内存碎片。</p><p>在我们的实际开发过程中，如果我们想要让垃圾回收器回收某一对象，就将对象的引用直接设置为 null。但如果一个对象被多次引用时，例如作为另一对象的键、值或子元素时，将该对象引用设置为 null 时，该对象是不会被回收的，依然存在。</p><h2 id="Cookie、LocalStorage、SessionStorage"><a href="#Cookie、LocalStorage、SessionStorage" class="headerlink" title="Cookie、LocalStorage、SessionStorage"></a>Cookie、LocalStorage、SessionStorage</h2><p><img src="/zyhxwing/../images/JavaScript/1367_1.png" alt="Cookie、LocalStorage、SessionStorage"></p><h3 id="cookies属性有哪些"><a href="#cookies属性有哪些" class="headerlink" title="cookies属性有哪些"></a>cookies属性有哪些</h3><ul><li>cookieName&#x3D;cookieValue 设置 cookie 的名字和值，必填项。</li><li>HttpOnly 只能通过 HTTP 响应报文的 Set-Cookie 来新增或更新 cookie ，客户端无法通过脚本的方式来读写 cookie。</li><li>Expires cookie 的过期时间点</li><li>Max-Age cookie 的有效时间长度</li><li>Path 设置 cookie 的路径作用域</li><li>Domain 设置 cookie 的 domain 作用域。</li><li>Secure 该属性没有值，属性本身存在就代表设置为安全模式。即请求必须为安全连接（HTTPS），cookie 才会被保存下来。HTTP 协议下，cookie 无效。</li><li>SameSite cookie 在跨域时是否应该被发送。</li></ul><h2 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h2><p>闭包是指有权访问另外一个函数作用域中的变量的函数。 <br>内部的函数存在外部作用域的引用就会导致闭包。</p><p>闭包中的变量存储的位置是堆内存。</p><p><strong>作用：</strong><br>保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化。局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。</p><p><strong>闭包使用场景</strong><br>return一个函数<br>函数作为参数<br>循环赋值<br>防抖节流</p><p><strong>闭包缺点</strong><br>容易导致内存泄漏。闭包会携带包含它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多</p><h2 id="js内存泄漏"><a href="#js内存泄漏" class="headerlink" title="js内存泄漏"></a>js内存泄漏</h2><h3 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h3><p>当内存中本应该在垃圾回收周期中清理的对象，因为被另一个对象的无意引用而从根能够保持可访问时，就会发生内存泄漏。将冗余对象保留在内存中会导致应用程序内部使用过多的内存，并可能导致性能下降。</p><h3 id="performance工具"><a href="#performance工具" class="headerlink" title="performance工具"></a>performance工具</h3><ul><li>打开浏览器输入目标网址</li><li>进入开发人员工具面板，选择性能</li><li>开启录制功能，访问具体界面</li><li>执行用户行为，一段时间后停止录制</li><li>分析界面中记录的内存信息</li></ul><h3 id="那该如何判断代码正在泄漏内存呢？"><a href="#那该如何判断代码正在泄漏内存呢？" class="headerlink" title="那该如何判断代码正在泄漏内存呢？"></a>那该如何判断代码正在泄漏内存呢？</h3><ul><li>内存使用检查最快的方法就是<strong>查看浏览器的任务管理器</strong>。 它们提供了当前在浏览器中运行的所有选项卡和进程的概览。在任务管理器中查看每个选项卡的 JavaScript 内存占用情况。如果网站什么都不做，但是 JavaScript 内存使用量却在逐渐增加，那们很有可能发生了内存泄漏。（快捷键 shift+esc）</li><li>timeline时序图记录（控制台 性能 记录 ）</li><li>堆快照查找分离DOM（控制台 内存 堆快照）</li><li>判断是否存在频繁的垃圾回收GC<ul><li>timeline中频繁的上升下降</li><li>任务管理器中数据频繁的增加减少</li></ul></li></ul><h3 id="什么会导致内存泄漏呢"><a href="#什么会导致内存泄漏呢" class="headerlink" title="什么会导致内存泄漏呢"></a>什么会导致内存泄漏呢</h3><ol><li>意外的全局变量：由于使用未声明的变量,而意外的创建了一个全局变量,而使这个变量一直留在内存中无法被回收。<strong>通过使用严格模式“use strict”来避免这一切。在JavaScript文件的开头，它将开启更严格的JavaScript解析模式，从而防止意外的创建全局变量。</strong></li><li>被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。<strong>修改计时器回调中引用的对象；必要时使用从计时器返回的句柄（定时器的标识符）取消它clearInterval()。</strong></li><li>脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。要解决此问题，<strong>可以在完成后，删除指向DOM元素的变量。</strong></li><li>闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。<strong>了解何时创建闭包以及闭包保留了哪些对象；了解闭包的预期寿命和用法（尤其是用作回调时）。</strong></li><li>事件监听器：事件侦听器将防止在其范围内捕获的所有变量被垃圾收集。添加后，事件侦听器将一直有效，直到：<strong>使用 removeEventListener() 显式删除或者关联的 DOM 元素被移除。</strong></li><li>缓存：如果不断地将内存添加到缓存中，而不删除未使用的对象，并且没有一些限制大小的逻辑，那么缓存可以无限增长。</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> user_1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Peter"</span><span class="token punctuation">,</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">12345</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> user_2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Mark"</span><span class="token punctuation">,</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">54321</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> mapCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">cache</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mapCache<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>obj<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> has an id of </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>obj<span class="token punctuation">.</span>id<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>    mapCache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>value<span class="token punctuation">,</span> <span class="token string">'computed'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span>mapCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'cached'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">cache</span><span class="token punctuation">(</span>user_1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['Peter has an id of 12345', 'computed']</span><span class="token function">cache</span><span class="token punctuation">(</span>user_1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['Peter has an id of 12345', 'cached']</span><span class="token function">cache</span><span class="token punctuation">(</span>user_2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['Mark has an id of 54321', 'computed']</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mapCache<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;&#123;…&#125; => 'Peter has an id of 12345', &#123;…&#125; => 'Mark has an id of 54321'&#125;</span>user_1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mapCache<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;&#123;…&#125; => 'Peter has an id of 12345', &#123;…&#125; => 'Mark has an id of 54321'&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的示例中，缓存仍然保留 user_1 对象。因此，我们需要将那些永远不会被重用的变量从缓存中清除。<strong>可以使用 WeakMap 来解决此问题。</strong>它是一种具有弱键引用的数据结构，仅接受对象作为键。如果我们使用一个对象作为键，并且它是对该对象的唯一引用——相关变量将从缓存中删除并被垃圾收集。在以下示例中，将 user_1 对象清空后，相关变量会在下一次垃圾回收后自动从 WeakMap 中删除。</p><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><p>深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/1/170965259fb768fd~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="深拷贝和浅拷贝"></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><p>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</p></li><li><p>浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。</p></li><li><p>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。</p></li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>浅拷贝：</p><ul><li>Object.assign()</li><li>lodash.clone</li><li>展开运算符…</li><li>Array.prototype.concat() </li><li>Array.prototype.slice()<br>深拷贝：</li><li>JSON.parse(JSON.stringify())</li><li>lodash.cloneDeep</li><li>jQuery.extend()</li><li>手写递归方法</li></ul><h2 id="JSON-stringify有什么缺点？"><a href="#JSON-stringify有什么缺点？" class="headerlink" title="JSON.stringify有什么缺点？"></a>JSON.stringify有什么缺点？</h2><ol><li>如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式</li><li>如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；</li><li>如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；</li><li>如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null</li><li>JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；<br>6、如果对象中存在循环引用的情况也无法正确实现深拷贝；</li></ol><h2 id="函数执行作用域"><a href="#函数执行作用域" class="headerlink" title="函数执行作用域"></a>函数执行作用域</h2><p>函数执行时做的事情</p><ol><li>确定作用域链： 当前执行上下文，上级执行上下文</li><li>确定this指向：window </li><li>初始化arguments对象</li><li>形参赋值</li><li>执行代码</li></ol><h2 id="js阴间面试题"><a href="#js阴间面试题" class="headerlink" title="js阴间面试题"></a>js阴间面试题</h2><h3 id="0-1-0-2-x3D-x3D-0-3"><a href="#0-1-0-2-x3D-x3D-0-3" class="headerlink" title="0.1+0.2!&#x3D;&#x3D;0.3"></a>0.1+0.2!&#x3D;&#x3D;0.3</h3><p>原因总结：<br>进制转换 ：js 在做数字计算的时候，<strong>0.1 和 0.2 都会被转成二进制后无限循环</strong>，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。<br>对阶运算 ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0舍1入），尾数位移时可能会发生数丢失的情况，影响精度。</p><p>解决办法：</p><ol><li>转为整数（大数）运算。</li><li>使用 Number.EPSILON 误差范围。</li><li>转成字符串，对字符串做加法运算。</li></ol><h3 id="后端返回一万条数据"><a href="#后端返回一万条数据" class="headerlink" title="后端返回一万条数据"></a>后端返回一万条数据</h3><ol><li>直接渲染</li><li>setTimeOut分片渲染，每次默认渲染200条</li><li>requestAnimationFrame，用createElement创建列表元素，减少重排次数</li><li>requestAnimationFrame，用document.createDocumentFragment方法创建列表元素，不会触发DOM树的重新渲染</li><li>在页面中加入空元素，监听空元素是否存在，当存在的时候加载下一页</li><li>虚拟列表</li></ol><p>虚拟列表的实现，实际上就是在首屏加载的时候，只加载可视区域内需要的列表项，当滚动发生时，动态通过计算获得可视区域内的列表项，并将非可视区域内存在的列表项删除。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/29/16e1519a393dee2c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="虚拟列表"></p><p>计算当前可视区域起始数据索引(startIndex)<br>计算当前可视区域结束数据索引(endIndex)<br>计算当前可视区域的数据，并渲染到页面中<br>计算startIndex对应的数据在整个列表中的偏移位置startOffset并设置到列表上</p><p>上述实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。而实际应用的时候，当列表中包含文本之类的可变内容，会导致列表项的高度并不相同。</p><p>可以以预估高度先行渲染，然后获取真实高度并缓存。</p><h2 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h2><p>为什么说 WebAssembly 更为高效，性能更好？</p><p>在 JS 引擎中性能消耗的分布大致为：将源码转为解释器可运行代码 -&gt; 基线&amp;优化编译器的运行 -&gt; 优化-丢弃优化的过程 -&gt; 执行代码 -&gt; 垃圾回收&amp;内存清理，这个过程是交叉进行的。</p><p><img src="https://user-images.githubusercontent.com/3983192/37875422-882e5cf2-3071-11e8-873f-497d45040084.png" alt="img"></p><p>而 WebAssembly 却只要简单的三个步骤即可完成 JS 引擎的整个交叉执行过程。</p><p><img src="https://user-images.githubusercontent.com/3983192/37875442-e3e03a5c-3071-11e8-9186-b65843520aa0.png" alt="img"></p><h4 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h4><p>当到达浏览器时，JS 源码需要被解析成 AST（抽象语法树）变成字节码提供给引擎编译，而 WebAssembly 却不需要这种转换，因为其本身就是字节码，因此它只需对代码进行 decode 并检查其正确性即可。</p><h4 id="Compile-Optimize"><a href="#Compile-Optimize" class="headerlink" title="Compile + Optimize"></a>Compile + Optimize</h4><p>这是执行代码编译和优化的阶段，在这个阶段 WebAssembly 的性能优于 JS 的主要原因为：</p><ul><li>WebAssembly 是有类型定义的代码，不需要在编译前运行代码来获取变量类型</li><li>WebAssembly 不需要像 JS 那样当变量类型改变时需要将代码编译成不同版本</li><li>WebAssembly 不需要在编译阶段做太多的优化工作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/zyhxwing/2022/09/02/http/"/>
      <url>/zyhxwing/2022/09/02/http/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h2><h3 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h3><p>超文本传输协议：<br>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p><h3 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h3><p><img src="/zyhxwing/../images/http/1347_1.png" alt="HTTP常见状态码"></p><ul><li>1xx 提示信息，表示目前是协议处理的中间状态</li><li>2xx 成功，报文已经被收到并且被正确处理<ul><li>200 表示一切正常</li><li>204 功能与200基本相同，但是本身响应头没有数据</li><li>206 表示响应的资源是其中的一部分，一般应用于HTTP分块下载</li></ul></li><li>3xx表示客户端请求的资源发生了变动<ul><li>301 表示永久重定向，说明请求的资源已经不存在，需要改用新的url来访问</li><li>302 表示临时重定向，说明请求的资源还在，但是需要用另一个url来访问<br>  301、302会在响应头用location，指明后续要跳转的url</li><li>304 协商缓存</li></ul></li><li>4xx表示客户端发送的报文有误，服务器无法处理，表示错误<ul><li>400 表示出现错误</li><li>403 服务器禁止访问</li><li>404 客户端请求的资源服务器没有找到</li></ul></li><li>5xx表示客户端请求报文正确，但服务器处理错误<ul><li>500 表示出现错误</li><li>501 服务器不支持该功能</li><li>502 服务器网关错误</li><li>503 服务器繁忙，暂无法响应</li></ul></li></ul><h3 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h3><p><img src="https://img-blog.csdnimg.cn/20200329115525160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTgwNDYz,size_16,color_FFFFFF,t_70" alt="http 请求报文格式"></p><p><img src="https://img-blog.csdnimg.cn/20200329115559434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTgwNDYz,size_16,color_FFFFFF,t_70" alt="http 响应报文格式"></p><ul><li>host：表示服务器请求的域名</li><li>content-length: 表示服务器在返回数据的时候，本次返回的数据长度</li><li>connection：keep-alive 表示客户端要求服务器使用tcp持久连接</li><li>content-type：服务器回应时告诉客户端本次数据是什么格式 一般取值为utf-8</li><li>content-encoding：表示返回的数据用了哪种压缩方法</li></ul><h3 id="get与post请求"><a href="#get与post请求" class="headerlink" title="get与post请求"></a>get与post请求</h3><p>get代表从服务器获取资源，post代表根据请求负载对指定资源做出处理</p><ul><li><p>GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p></li><li><p>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。</p></li><li><p>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</p></li><li><p>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。</p></li></ul><h3 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h3><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。<br>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。<br>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><p>GET请求指定的页面信息，并返回实体主体。<br>HEAD类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头<br>POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。<br>PUT从客户端向服务器传送的数据取代指定的文档的内容。<br>DELETE请求服务器删除指定的页面。<br>CONNECTHTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。<br>OPTIONS允许客户端查看服务器的性能。<br>TRACE回显服务器收到的请求，主要用于测试或诊断。<br>PATCH是对 PUT 方法的补充，用来对已知资源进行局部更新 。</p><h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>200（from disk cache）<br>强缓存根据下面两个http响应头部来实现，表示资源在客户端缓存的有效期</p><ul><li>cache-control 相对时间，优先级更高</li><li>expires 绝对时间</li></ul><p>实现步骤：<br>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>304<br>协商缓存可以通过两种方式来实现</p><p>请求头部 if-modified-since，响应头部 last-modified </p><ul><li>响应头部 last-modified 该响应资源的最后修改时间</li><li>请求头部 if-modified-since 当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li></ul><p>请求头部 if-none-match，响应头部 etag</p><ul><li>响应头部 etag 唯一标识响应资源</li><li>请求头部 if-none-match 当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p><p>如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， Etag 的优先级更高，也就是先会判断 Etag 是否变化了，如果 Etag 没有变化，然后再看 Last-Modified。</p><p>注意，协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p><h4 id="三种刷新操作对-http-缓存的影响"><a href="#三种刷新操作对-http-缓存的影响" class="headerlink" title="三种刷新操作对 http 缓存的影响"></a>三种刷新操作对 http 缓存的影响</h4><p>正常操作：地址栏输入 url，跳转链接，前进后退等。强制缓存有效，协商缓存有效<br>手动刷新：f5，点击刷新按钮，右键菜单刷新。强制缓存失效，协商缓存有效<br>强制刷新：ctrl + f5，shift+command+r。强制缓存失效，协商缓存失效。</p><h3 id="HTTP特性与演变"><a href="#HTTP特性与演变" class="headerlink" title="HTTP特性与演变"></a>HTTP特性与演变</h3><h4 id="HTTP1-1优点"><a href="#HTTP1-1优点" class="headerlink" title="HTTP1.1优点"></a>HTTP1.1优点</h4><ul><li>简单，header+body，头部内容为key-value</li><li>灵活、易于拓展</li><li>应用广泛</li></ul><h4 id="HTTP1-1缺点"><a href="#HTTP1-1缺点" class="headerlink" title="HTTP1.1缺点"></a>HTTP1.1缺点</h4><ul><li>无状态，减少服务器负担的同时也需要进行额外的身份认证（cookie）</li><li>明文传输，不安全</li></ul><h4 id="HTTP1-1特性"><a href="#HTTP1-1特性" class="headerlink" title="HTTP1.1特性"></a>HTTP1.1特性</h4><ul><li>长连接，服务器和客户端可以长时间保持连接</li><li>管道网络传输，发送请求不用等响应就可以发送接下来的请求</li><li>队头堵塞，响应请求需要一步一步响应，如果队伍头部的响应很慢，接下来的响应就会堵塞</li></ul><hr><h4 id="HTTP2特性"><a href="#HTTP2特性" class="headerlink" title="HTTP2特性"></a>HTTP2特性</h4><ul><li><strong>头部压缩</strong>，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</li><li><strong>二进制格式</strong>，增加了信息传输的效率</li><li><strong>数据流</strong>，对数据包做标记，指出它属于哪个回应。在 HTTP&#x2F;2 中每个请求或响应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号（Stream ID），不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息</li><li><strong>多路复用</strong>，在一个连接中并发多个请求或回应，而不用按照顺序一一对应。移除了 HTTP&#x2F;1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。</li><li><strong>服务器推送</strong>，服务端不再是被动地响应，可以主动向客户端发送消息。</li></ul><h4 id="HTTP2缺点"><a href="#HTTP2缺点" class="headerlink" title="HTTP2缺点"></a>HTTP2缺点</h4><ul><li>TCP队头堵塞问题。HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</li></ul><p><strong>简而言之就是某个TCP的packet也就是序列号丢失了，那么之后所有的TCP都需要等待重传机制返回丢失的包，才能继续运行，否则数据不连续是无法被读取到的</strong></p><hr><h4 id="HTTP3优点"><a href="#HTTP3优点" class="headerlink" title="HTTP3优点"></a>HTTP3优点</h4><ul><li><strong>无队头堵塞，基于UDP实现HTTP链接</strong>，通过QUIC协议实现可靠传输。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。</li><li><strong>更快的连接速度</strong>，QUIC内部包含了TLS可以同时完成建立连接与密钥协商 </li><li><strong>连接迁移</strong>。基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。<strong>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己</strong>，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。</li></ul><h4 id="HTTP3缺点"><a href="#HTTP3缺点" class="headerlink" title="HTTP3缺点"></a>HTTP3缺点</h4><p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="HTTP与HTTPS区别"><a href="#HTTP与HTTPS区别" class="headerlink" title="HTTP与HTTPS区别"></a>HTTP与HTTPS区别</h3><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h3 id="HTTPS改进内容之TLS协议"><a href="#HTTPS改进内容之TLS协议" class="headerlink" title="HTTPS改进内容之TLS协议"></a>HTTPS改进内容之TLS协议</h3><ul><li>信息加密： HTTP 交互信息是被加密的，第三方就无法被窃取；</li><li>校验机制：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；</li><li>身份证书：证明淘宝是真的淘宝网；</li></ul><h3 id="SSL-x2F-TLS握手详解"><a href="#SSL-x2F-TLS握手详解" class="headerlink" title="SSL&#x2F;TLS握手详解"></a>SSL&#x2F;TLS握手详解</h3><ul><li>TLS第一次握手<ul><li>客户端发送Client Hello消息，包含了版本号、支持的密码套件列表、随机数Client Random</li></ul></li><li>TLS第二次握手<ul><li>服务端收到Client Hello消息之后，首先会确认版本号是否支持，然后从密码套件列表中选择一个密码套件RSA，然后生成出一个随机数Server Random，最后返回Server Hello消息，包含了以上内容</li><li>服务端发送Server Certificate给客户端，这个消息里含有数字证书</li><li>服务端发送Server Hello Done给客户端，代表本次握手结束，已经把东西给了客户端</li></ul></li><li>TLS第三次握手<ul><li>证书认证机构CA签发证书流程<ul><li>CA把持有者的信息打包，进行hash计算，得到一个hash值、</li><li>CA会使用自己的私钥对hash值加密，生成签名 Certificate Signature</li><li>将签名添加到文件证书上，形成数字证书</li></ul></li><li>客户端验证数字证书流程<ul><li>客户端会使用相同的算法也生成一个hash值</li><li>客户端再收到数字证书后，根据操作系统提供的CA的公钥对证书解密，获得了CA传递的hash值</li><li>两个hash值对比，相同则为可以信赖的证书</li></ul></li><li>客户端验证证书完毕之后，会生成一个新的随机数pre-master，用服务器RSA公钥加密该随机数，通过Client Key Exchange消息传递给服务端</li><li>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)</li><li>客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master</li><li>于是，双方根据已经得到的三个随机数，生成会话密钥（Master Secret），它是 <strong>对称密钥</strong>，用于对后续的 HTTP 请求&#x2F;响应的数据加解密。</li><li>生成完「会话密钥」后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息。</li><li>然后，客户端再发一个「Encrypted Handshake Message（Finishd） 」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</li></ul></li><li>TLS第四次握手<ul><li>服务器发送Change Cipher Spec、Encrypted Handshake Message（Finishd） 消息，此时双方都验证加密和解密没问题，则握手完毕</li></ul></li></ul><p><strong>密钥交换算法：因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。</strong></p><h2 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p><ul><li>面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li>字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：源地址、源端口、目的地址、目的端口</p><h3 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h3><p><strong>连接</strong></p><ol><li>连接TCP 是面向连接的传输层协议，传输数据前先要建立连接。UDP 是不需要连接，即刻传输数据。</li></ol><p><strong>服务对象、连接数</strong><br>2. 服务对象TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对多的交互通信</p><p><strong>可靠性</strong><br>3. 可靠性TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。UDP 是尽最大努力交付，不保证可靠交付数据。</p><p><strong>流量控制</strong><br>4. 拥塞控制、流量控制TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</p><p><strong>首部开销</strong><br>5. 首部开销TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</p><p><strong>传输方式</strong><br>6. 传输方式TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</p><p><strong>分片传播</strong><br>7. 分片不同TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</p><p><strong>应用</strong><br>8. 由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：FTP 文件传输；HTTP &#x2F; HTTPS；由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：包总量较少的通信，如 DNS 、SNMP 等；视频、音频等多媒体通信；广播通信。</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/zyhxwing/../images/http/1349_1.png" alt="三次握手"></p><ul><li><p>一开始，客户端和服务端都处于<strong>CLOSED</strong> 状态。先是服务端主动监听某个端口，处于 <strong>LISTEN</strong> 状态</p></li><li><p>客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把<strong>SYN 标志位置为 1</strong> ，表示 SYN 报文。接着<strong>把第一个 SYN 报文发送给服务端</strong>，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <strong>SYN-SENT</strong> 状态。</p></li><li></li><li><p>服务端在收到客户端的SYN请求之后，会初始化自己的序号，将此序号填入TCP首部的序号字段中，其次把TCP首部的确认应答号字段填入client_isn + 1，接着把 <strong>SYN 和 ACK 标志位置为1</strong> 。把该报文发给客户端，该报文也不包含应用层数据，之后服务器处于 <strong>SYN-RCVD</strong> 状态。</p></li><li><p>客户端在收到服务端报文后，还要再向服务端回应最后一个应答报文，首先将该报文的<strong>ACK置为1</strong>，其次确认应答号填入server_isn+1，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，指挥客户端处于<strong>ESTABLISHED</strong>状态。</p></li><li><p>服务端在收到客户端的应答报文之后，也进入<strong>ESTABLISHED</strong>状态。</p></li></ul><h3 id="为什么不是四次握手、两次握手"><a href="#为什么不是四次握手、两次握手" class="headerlink" title="为什么不是四次握手、两次握手"></a>为什么不是四次握手、两次握手</h3><p>1.三次握手才可以阻止重复历史连接的初始化（主要原因）</p><p>我们考虑一个场景，客户端先发送了 SYN（seq &#x3D; 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq &#x3D; 100） 报文（注意不是重传 SYN，重传的 SYN 的序列号是一样的）。<br>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵情况下：<br>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；<br>那么此时服务端就会回一个 SYN + ACK 报文给客户端；<br>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</p><p>如果是两次握手连接，就无法阻止历史连接，那为什么 TCP 两次握手为什么无法阻止历史连接呢？</p><p><strong>我先直接说结论，主要是因为在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费。</strong></p><p>你想想，两次握手的情况下，「被动发起方」在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据给，但是「主动发」起方此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，主动发起方判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而「被动发起方」在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。</p><p>因此，要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。所以，TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。</p><p>2.三次握手才可以同步双方的初始序列号</p><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：接收方可以去除重复的数据；接收方可以根据数据包的序列号按序接收；可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。</p><p><strong>四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</strong></p><p>3.三次握手才可以避免资源浪费</p><p>如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</p><p><strong>不使用「两次握手」和「四次握手」的原因：<br>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；<br>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</strong></p><h3 id="三次握手每次丢失都会发生什么"><a href="#三次握手每次丢失都会发生什么" class="headerlink" title="三次握手每次丢失都会发生什么"></a>三次握手每次丢失都会发生什么</h3><h4 id="第一次握手丢失"><a href="#第一次握手丢失" class="headerlink" title="第一次握手丢失"></a>第一次握手丢失</h4><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 SYN_SENT 状态。</p><p><strong>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文。如果在重传次数超过最大重传次数之后，服务端依旧没响应ACK，则会断开TCP连接</strong></p><h4 id="第二次握手丢失"><a href="#第二次握手丢失" class="headerlink" title="第二次握手丢失"></a>第二次握手丢失</h4><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 SYN_RCVD 状态。</p><p>第二次握手的 SYN-ACK 报文其实有两个目的 ：第二次握手里的 ACK， 是对第一次握手的确认报文；第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；所以，如果第二次握手丢了，就会发生比较有意思的事情，具体会怎么样呢？</p><p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 SYN-ACK 报文。在 Linux 下，SYN-ACK 报文的最大重传次数由 tcp_synack_retries内核参数决定，默认值是 5。</p><p><strong>因此，当第二次握手丢失了，客户端和服务端都会重传：<br>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 tcp_syn_retries内核参数决定；服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 tcp_synack_retries 内核参数决定。</strong></p><h4 id="第三次握手丢失"><a href="#第三次握手丢失" class="headerlink" title="第三次握手丢失"></a>第三次握手丢失</h4><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISH 状态。</p><p><strong>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</strong></p><p>注意，ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/zyhxwing/../images/http/1351_1.png" alt="四次挥手"></p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 <strong>FIN 报文</strong>，之后客户端进入 <strong>FIN_WAIT_1</strong>状态。</li><li>服务端收到该报文后，就向客户端发送 <strong>ACK</strong> 应答报文，接着服务端进入 <strong>CLOSED_WAIT</strong> 状态。</li><li>客户端收到服务端的 ACK 应答报文后，之后进入 <strong>FIN_WAIT_2</strong>状态。</li><li>等待服务端处理完数据后，也向客户端发送<strong>FIN 报文</strong>，之后服务端进入 <strong>LAST_ACK</strong> 状态。</li><li>客户端收到服务端的 FIN 报文后，<strong>回一个 ACK应答报文</strong>，之后进入 <strong>TIME_WAIT</strong> 状态</li><li>服务器收到了 ACK 应答报文后，就进入了 <strong>CLOSED</strong> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 2MSL 一段时间后，自动进入 <strong>CLOSED</strong> 状态，至此客户端也完成连接的关闭。</li></ul><p>你可以看到，每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。</p><h3 id="为什么需要挥手四次"><a href="#为什么需要挥手四次" class="headerlink" title="为什么需要挥手四次"></a>为什么需要挥手四次</h3><p>再来回顾下四次挥手双方发 FIN 包的过程，就能理解为什么需要四次了。</p><p>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</p><p>从上面过程可知，<strong>服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。</strong></p><h3 id="四次挥手丢失了会发生什么"><a href="#四次挥手丢失了会发生什么" class="headerlink" title="四次挥手丢失了会发生什么"></a>四次挥手丢失了会发生什么</h3><h4 id="第一次挥手丢失"><a href="#第一次挥手丢失" class="headerlink" title="第一次挥手丢失"></a>第一次挥手丢失</h4><p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，<strong>重传 FIN 报文</strong>，重发次数由 tcp_orphan_retries 参数控制。当客户端重传 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，直接进入到 close 状态。</p><h4 id="第二次挥手丢失"><a href="#第二次挥手丢失" class="headerlink" title="第二次挥手丢失"></a>第二次挥手丢失</h4><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 CLOSE_WAIT 状态。在前面我们也提了，<strong>ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文</strong>，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p><h4 id="第三次挥手丢失"><a href="#第三次挥手丢失" class="headerlink" title="第三次挥手丢失"></a>第三次挥手丢失</h4><p><strong>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文</strong>，重发次数仍然由 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p><h4 id="第四次挥手丢失"><a href="#第四次挥手丢失" class="headerlink" title="第四次挥手丢失"></a>第四次挥手丢失</h4><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 TIME_WAIT 状态。在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。如果第四次挥手的 ACK 报文没有到达服务端，<strong>服务端就会重发 FIN 报文</strong>，重发次数仍然由前面介绍过的</p><h3 id="TCP如何实现可靠传输"><a href="#TCP如何实现可靠传输" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h3><h4 id="TCP-重传机制"><a href="#TCP-重传机制" class="headerlink" title="TCP 重传机制"></a>TCP 重传机制</h4><p>超时重传<br>在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。</p><p>快速重传<br>快速重传的工作方式是当收到三个相同的 ACK 报文时，代表某一个报文丢失了。则会在定时器过期之前，重传丢失的报文段。</p><p>SACK选择性确认<br>可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。<br>发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p><p>Duplicate SACK<br>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</p><h4 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h4><p>有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。<strong>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</strong>即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p><h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><p>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p><h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><p>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，<strong>当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。于是，就有了拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。</strong>为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。</p><h2 id="你输入一条网址会发生了什么"><a href="#你输入一条网址会发生了什么" class="headerlink" title="你输入一条网址会发生了什么"></a>你输入一条网址会发生了什么</h2><ol><li><p>解析URL：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p></li><li><p>缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p></li><li><p>DNS解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。<strong>本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，</strong>本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p></li><li><p>获取MAC地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，<strong>本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址通过ARP协议来获取</strong>需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。  <strong>ARP协议会先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。</strong></p></li><li><p>TCP三次握手：<strong>下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向客户端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了</strong>。</p></li><li><p>HTTPS握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。<strong>首先由客户端向服务器端发送使用的协议的版本号、一个随机数client random和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数server random和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数pre-master，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</strong></p></li><li><p>返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p></li><li><p>页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</p></li><li><p>TCP四次挥手：<strong>最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</strong></p></li></ol><h2 id="OSI七层模型和TCP-x2F-IP四层模型"><a href="#OSI七层模型和TCP-x2F-IP四层模型" class="headerlink" title="OSI七层模型和TCP&#x2F;IP四层模型"></a>OSI七层模型和TCP&#x2F;IP四层模型</h2><p><img src="/zyhxwing/../images/http/1355_1.png" alt="OSI七层模型和TCP/IP四层模型"></p><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><ul><li><p>应用层<br>网络服务与最终用户的一个接口。<br>协议有： HTTP（超文本传输协议） FTP（文本传输协议） TFTP（简单文本传输协议） SMTP（简单邮件传输协议） SNMP（简单网络管理协议） DNS（域名系统） TELNET（远程终端协议） HTTPS（超文本传输安全协议） POP3（邮件协议版本3） DHCP（动态主机配置协议）</p></li><li><p>表示层<br>数据的表示、安全、压缩。<br>格式有：JPEG、ASCll、EBCDIC、加密格式等</p></li><li><p>会话层<br>建立、管理、终止会话。<br>对应主机进程，指本地与远程主机正在进行的会话</p></li><li><p>传输层<br>定义传输数据的协议端口号，以及流控和差错校验<br>协议有：TCP、UD，数据包一旦离开网卡即进入网络传输层</p></li><li><p>网络层<br>进行逻辑地址寻址，实现不通网络之间的路径选择（路由选路）<br>协议有：ICMP、IGMP、IP（IPV4  IPV6）</p></li><li><p>数据链路层<br>建立逻辑连接、进行硬件寻址，差错校验等功能（有底层网络定义协议）<br>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不纠正</p></li><li><p>物理层<br>建立、维护、断开物理连接（由底层网络定义协议）</p></li></ul><h3 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h3><ul><li><p>应用层<br>应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等.</p></li><li><p>传输层<br>传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP).</p></li></ul><p>TCP协议提供的是一种可靠的、通过“三次握手”来连接的数据传输服务；而UDP协议提供的则是不保证可靠的（并不是不可靠）、无连接的数据传输服务.</p><ul><li>网络层<br>主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</li></ul><p>IP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务</p><ul><li>网络接口层<br>网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP&#x2F;IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP&#x2F;IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/zyhxwing/2022/09/01/hello-world/"/>
      <url>/zyhxwing/2022/09/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to xwing! </p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
